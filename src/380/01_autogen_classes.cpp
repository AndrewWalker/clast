

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include "internal.h"

#include <clang/AST/AST.h>
#include <clang/ASTMatchers/ASTMatchers.h>
#include <clang/ASTMatchers/ASTMatchFinder.h>


namespace py = pybind11;

void autogenerated_classes_0(pybind11::module& m)
{
    // Skipping generation of llvm::StringRef

    py::class_<clang::SourceLocation>(m, "SourceLocation" )
        .def("isFileID", [](const clang::SourceLocation& self) -> bool {
           return  self.isFileID();
        })
        .def("isMacroID", [](const clang::SourceLocation& self) -> bool {
           return  self.isMacroID();
        })
        .def("isValid", [](const clang::SourceLocation& self) -> bool {
           return  self.isValid();
        })
        .def("isInvalid", [](const clang::SourceLocation& self) -> bool {
           return  self.isInvalid();
        })
        .def("getLocWithOffset", [](const clang::SourceLocation& self, int Offset) -> clang::SourceLocation {
           return  self.getLocWithOffset(Offset);
        })
        .def("getRawEncoding", [](const clang::SourceLocation& self) -> unsigned int {
           return  self.getRawEncoding();
        })
        .def("getPtrEncoding", [](const clang::SourceLocation& self) -> void * {
           return  self.getPtrEncoding();
        })
        //.def("print", [](const clang::SourceLocation& self, llvm::raw_ostream & OS , const clang::SourceManager & SM)  {
        //     self.print(OS, SM);
        //})
        .def("printToString", [](const clang::SourceLocation& self, const clang::SourceManager & SM) -> std::basic_string<char> {
           return  self.printToString(SM);
        })
        .def("dump", [](const clang::SourceLocation& self, const clang::SourceManager & SM)  {
             self.dump(SM);
        })
    ;

    py::class_<clang::SourceRange>(m, "SourceRange" )
        .def("getBegin", [](const clang::SourceRange& self) -> clang::SourceLocation {
           return  self.getBegin();
        })
        .def("getEnd", [](const clang::SourceRange& self) -> clang::SourceLocation {
           return  self.getEnd();
        })
        .def("setBegin", []( clang::SourceRange& self, clang::SourceLocation b)  {
             self.setBegin(b);
        })
        .def("setEnd", []( clang::SourceRange& self, clang::SourceLocation e)  {
             self.setEnd(e);
        })
        .def("isValid", [](const clang::SourceRange& self) -> bool {
           return  self.isValid();
        })
        .def("isInvalid", [](const clang::SourceRange& self) -> bool {
           return  self.isInvalid();
        })
    ;

    py::class_<clang::DeclarationName>(m, "DeclarationName" )
        .def("isEmpty", [](const clang::DeclarationName& self) -> bool {
           return  self.isEmpty();
        })
        .def("isIdentifier", [](const clang::DeclarationName& self) -> bool {
           return  self.isIdentifier();
        })
        .def("isObjCZeroArgSelector", [](const clang::DeclarationName& self) -> bool {
           return  self.isObjCZeroArgSelector();
        })
        .def("isObjCOneArgSelector", [](const clang::DeclarationName& self) -> bool {
           return  self.isObjCOneArgSelector();
        })
        .def("getNameKind", [](const clang::DeclarationName& self) -> clang::DeclarationName::NameKind {
           return  self.getNameKind();
        })
        .def("isDependentName", [](const clang::DeclarationName& self) -> bool {
           return  self.isDependentName();
        })
        .def("getAsString", [](const clang::DeclarationName& self) -> std::basic_string<char> {
           return  self.getAsString();
        })
        //.def("getAsIdentifierInfo", [](const clang::DeclarationName& self) -> clang::IdentifierInfo * {
        //   return  self.getAsIdentifierInfo();
        //})
        .def("getAsOpaqueInteger", [](const clang::DeclarationName& self) -> unsigned long {
           return  self.getAsOpaqueInteger();
        })
        .def("getAsOpaquePtr", [](const clang::DeclarationName& self) -> void * {
           return  self.getAsOpaquePtr();
        })
        .def("getCXXNameType", [](const clang::DeclarationName& self) -> clang::QualType {
           return  self.getCXXNameType();
        })
        .def("getCXXOverloadedOperator", [](const clang::DeclarationName& self) -> clang::OverloadedOperatorKind {
           return  self.getCXXOverloadedOperator();
        })
        //.def("getCXXLiteralIdentifier", [](const clang::DeclarationName& self) -> clang::IdentifierInfo * {
        //   return  self.getCXXLiteralIdentifier();
        //})
        //.def("getObjCSelector", [](const clang::DeclarationName& self) -> clang::Selector {
        //   return  self.getObjCSelector();
        //})
        .def("setFETokenInfo", []( clang::DeclarationName& self, void * T)  {
             self.setFETokenInfo(T);
        })
        //.def("print", []( clang::DeclarationName& self, llvm::raw_ostream & OS , const clang::PrintingPolicy & Policy)  {
        //     self.print(OS, Policy);
        //})
        .def("dump", [](const clang::DeclarationName& self)  {
             self.dump();
        })
    ;

    py::class_<clang::DeclarationNameInfo>(m, "DeclarationNameInfo" )
        .def("getName", [](const clang::DeclarationNameInfo& self) -> clang::DeclarationName {
           return  self.getName();
        })
        .def("setName", []( clang::DeclarationNameInfo& self, clang::DeclarationName N)  {
             self.setName(N);
        })
        .def("getLoc", [](const clang::DeclarationNameInfo& self) -> clang::SourceLocation {
           return  self.getLoc();
        })
        .def("setLoc", []( clang::DeclarationNameInfo& self, clang::SourceLocation L)  {
             self.setLoc(L);
        })
        //.def("getInfo", [](const clang::DeclarationNameInfo& self) -> const clang::DeclarationNameLoc & {
        //   return  self.getInfo();
        //})
        //.def("getInfo", []( clang::DeclarationNameInfo& self) -> clang::DeclarationNameLoc & {
        //   return  self.getInfo();
        //})
        //.def("setInfo", []( clang::DeclarationNameInfo& self, const clang::DeclarationNameLoc & Info)  {
        //     self.setInfo(Info);
        //})
        .def("getNamedTypeInfo", [](const clang::DeclarationNameInfo& self) -> clang::TypeSourceInfo * {
           return  self.getNamedTypeInfo();
        })
        .def("setNamedTypeInfo", []( clang::DeclarationNameInfo& self, clang::TypeSourceInfo * TInfo)  {
             self.setNamedTypeInfo(TInfo);
        })
        .def("getCXXOperatorNameRange", [](const clang::DeclarationNameInfo& self) -> clang::SourceRange {
           return  self.getCXXOperatorNameRange();
        })
        .def("setCXXOperatorNameRange", []( clang::DeclarationNameInfo& self, clang::SourceRange R)  {
             self.setCXXOperatorNameRange(R);
        })
        .def("getCXXLiteralOperatorNameLoc", [](const clang::DeclarationNameInfo& self) -> clang::SourceLocation {
           return  self.getCXXLiteralOperatorNameLoc();
        })
        .def("setCXXLiteralOperatorNameLoc", []( clang::DeclarationNameInfo& self, clang::SourceLocation Loc)  {
             self.setCXXLiteralOperatorNameLoc(Loc);
        })
        .def("isInstantiationDependent", [](const clang::DeclarationNameInfo& self) -> bool {
           return  self.isInstantiationDependent();
        })
        .def("containsUnexpandedParameterPack", [](const clang::DeclarationNameInfo& self) -> bool {
           return  self.containsUnexpandedParameterPack();
        })
        .def("getAsString", [](const clang::DeclarationNameInfo& self) -> std::basic_string<char> {
           return  self.getAsString();
        })
        //.def("printName", [](const clang::DeclarationNameInfo& self, llvm::raw_ostream & OS)  {
        //     self.printName(OS);
        //})
        .def("getBeginLoc", [](const clang::DeclarationNameInfo& self) -> clang::SourceLocation {
           return  self.getBeginLoc();
        })
        .def("getEndLoc", [](const clang::DeclarationNameInfo& self) -> clang::SourceLocation {
           return  self.getEndLoc();
        })
        .def("getSourceRange", [](const clang::DeclarationNameInfo& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getLocStart", [](const clang::DeclarationNameInfo& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::DeclarationNameInfo& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
    ;

    py::class_<clang::Decl, decl_deleter<clang::Decl>::type>(m, "Decl" )
        .def("getSourceRange", [](const clang::Decl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getLocStart", [](const clang::Decl& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::Decl& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getLocation", [](const clang::Decl& self) -> clang::SourceLocation {
           return  self.getLocation();
        })
        .def("setLocation", []( clang::Decl& self, clang::SourceLocation L)  {
             self.setLocation(L);
        })
        .def("getKind", [](const clang::Decl& self) -> clang::Decl::Kind {
           return  self.getKind();
        })
        .def("getDeclKindName", [](const clang::Decl& self) -> const char * {
           return  self.getDeclKindName();
        })
        .def("getNextDeclInContext", []( clang::Decl& self) -> clang::Decl * {
           return  self.getNextDeclInContext();
        })
        .def("getNextDeclInContext", [](const clang::Decl& self) -> const clang::Decl * {
           return  self.getNextDeclInContext();
        })
        .def("getDeclContext", []( clang::Decl& self) -> clang::DeclContext * {
           return  self.getDeclContext();
        })
        .def("getDeclContext", [](const clang::Decl& self) -> const clang::DeclContext * {
           return  self.getDeclContext();
        })
        .def("getNonClosureContext", []( clang::Decl& self) -> clang::Decl * {
           return  self.getNonClosureContext();
        })
        .def("getNonClosureContext", [](const clang::Decl& self) -> const clang::Decl * {
           return  self.getNonClosureContext();
        })
        .def("getTranslationUnitDecl", []( clang::Decl& self) -> clang::TranslationUnitDecl * {
           return  self.getTranslationUnitDecl();
        })
        .def("getTranslationUnitDecl", [](const clang::Decl& self) -> const clang::TranslationUnitDecl * {
           return  self.getTranslationUnitDecl();
        })
        .def("isInAnonymousNamespace", [](const clang::Decl& self) -> bool {
           return  self.isInAnonymousNamespace();
        })
        .def("isInStdNamespace", [](const clang::Decl& self) -> bool {
           return  self.isInStdNamespace();
        })
        .def("getASTContext", [](const clang::Decl& self) -> clang::ASTContext & {
           return  self.getASTContext();
        })
        .def("setAccess", []( clang::Decl& self, clang::AccessSpecifier AS)  {
             self.setAccess(AS);
        })
        .def("getAccess", [](const clang::Decl& self) -> clang::AccessSpecifier {
           return  self.getAccess();
        })
        .def("getAccessUnsafe", [](const clang::Decl& self) -> clang::AccessSpecifier {
           return  self.getAccessUnsafe();
        })
        .def("hasAttrs", [](const clang::Decl& self) -> bool {
           return  self.hasAttrs();
        })
        //.def("setAttrs", []( clang::Decl& self, const llvm::SmallVector<clang::Attr *, 2> & Attrs)  {
        //     self.setAttrs(Attrs);
        //})
        //.def("getAttrs", []( clang::Decl& self) -> llvm::SmallVector<clang::Attr *, 2> & {
        //   return  self.getAttrs();
        //})
        //.def("getAttrs", [](const clang::Decl& self) -> const llvm::SmallVector<clang::Attr *, 2> & {
        //   return  self.getAttrs();
        //})
        .def("dropAttrs", []( clang::Decl& self)  {
             self.dropAttrs();
        })
        //.def("addAttr", []( clang::Decl& self, clang::Attr * A)  {
        //     self.addAttr(A);
        //})
        //.def("attrs", [](const clang::Decl& self) -> llvm::iterator_range<clang::Attr *const *> {
        //   return  self.attrs();
        //})
        .def("getMaxAlignment", [](const clang::Decl& self) -> unsigned int {
           return  self.getMaxAlignment();
        })
        .def("setInvalidDecl", []( clang::Decl& self, bool Invalid)  {
             self.setInvalidDecl(Invalid);
        })
        .def("isInvalidDecl", [](const clang::Decl& self) -> bool {
           return  self.isInvalidDecl();
        })
        .def("isImplicit", [](const clang::Decl& self) -> bool {
           return  self.isImplicit();
        })
        .def("setImplicit", []( clang::Decl& self, bool I)  {
             self.setImplicit(I);
        })
        .def("isUsed", [](const clang::Decl& self, bool CheckUsedAttr) -> bool {
           return  self.isUsed(CheckUsedAttr);
        })
        .def("setIsUsed", []( clang::Decl& self)  {
             self.setIsUsed();
        })
        .def("markUsed", []( clang::Decl& self, clang::ASTContext & C)  {
             self.markUsed(C);
        })
        .def("isReferenced", [](const clang::Decl& self) -> bool {
           return  self.isReferenced();
        })
        .def("isThisDeclarationReferenced", [](const clang::Decl& self) -> bool {
           return  self.isThisDeclarationReferenced();
        })
        .def("setReferenced", []( clang::Decl& self, bool R)  {
             self.setReferenced(R);
        })
        .def("isTopLevelDeclInObjCContainer", [](const clang::Decl& self) -> bool {
           return  self.isTopLevelDeclInObjCContainer();
        })
        .def("setTopLevelDeclInObjCContainer", []( clang::Decl& self, bool V)  {
             self.setTopLevelDeclInObjCContainer(V);
        })
        .def("isModulePrivate", [](const clang::Decl& self) -> bool {
           return  self.isModulePrivate();
        })
        .def("hasDefiningAttr", [](const clang::Decl& self) -> bool {
           return  self.hasDefiningAttr();
        })
        //.def("getDefiningAttr", [](const clang::Decl& self) -> const clang::Attr * {
        //   return  self.getDefiningAttr();
        //})
        .def("getAvailability", [](const clang::Decl& self, std::basic_string<char> * Message) -> clang::AvailabilityResult {
           return  self.getAvailability(Message);
        })
        .def("isDeprecated", [](const clang::Decl& self, std::basic_string<char> * Message) -> bool {
           return  self.isDeprecated(Message);
        })
        .def("isUnavailable", [](const clang::Decl& self, std::basic_string<char> * Message) -> bool {
           return  self.isUnavailable(Message);
        })
        .def("isWeakImported", [](const clang::Decl& self) -> bool {
           return  self.isWeakImported();
        })
        .def("canBeWeakImported", [](const clang::Decl& self, bool & IsDefinition) -> bool {
           return  self.canBeWeakImported(IsDefinition);
        })
        .def("isFromASTFile", [](const clang::Decl& self) -> bool {
           return  self.isFromASTFile();
        })
        .def("getGlobalID", [](const clang::Decl& self) -> unsigned int {
           return  self.getGlobalID();
        })
        .def("getOwningModuleID", [](const clang::Decl& self) -> unsigned int {
           return  self.getOwningModuleID();
        })
        //.def("getImportedOwningModule", [](const clang::Decl& self) -> clang::Module * {
        //   return  self.getImportedOwningModule();
        //})
        //.def("getLocalOwningModule", [](const clang::Decl& self) -> clang::Module * {
        //   return  self.getLocalOwningModule();
        //})
        //.def("setLocalOwningModule", []( clang::Decl& self, clang::Module * M)  {
        //     self.setLocalOwningModule(M);
        //})
        .def("getIdentifierNamespace", [](const clang::Decl& self) -> unsigned int {
           return  self.getIdentifierNamespace();
        })
        .def("isInIdentifierNamespace", [](const clang::Decl& self, unsigned int NS) -> bool {
           return  self.isInIdentifierNamespace(NS);
        })
        .def("hasTagIdentifierNamespace", [](const clang::Decl& self) -> bool {
           return  self.hasTagIdentifierNamespace();
        })
        .def("getLexicalDeclContext", []( clang::Decl& self) -> clang::DeclContext * {
           return  self.getLexicalDeclContext();
        })
        .def("getLexicalDeclContext", [](const clang::Decl& self) -> const clang::DeclContext * {
           return  self.getLexicalDeclContext();
        })
        .def("isOutOfLine", [](const clang::Decl& self) -> bool {
           return  self.isOutOfLine();
        })
        .def("setDeclContext", []( clang::Decl& self, clang::DeclContext * DC)  {
             self.setDeclContext(DC);
        })
        .def("setLexicalDeclContext", []( clang::Decl& self, clang::DeclContext * DC)  {
             self.setLexicalDeclContext(DC);
        })
        .def("isDefinedOutsideFunctionOrMethod", [](const clang::Decl& self) -> bool {
           return  self.isDefinedOutsideFunctionOrMethod();
        })
        .def("isLexicallyWithinFunctionOrMethod", [](const clang::Decl& self) -> bool {
           return  self.isLexicallyWithinFunctionOrMethod();
        })
        .def("getParentFunctionOrMethod", [](const clang::Decl& self) -> const clang::DeclContext * {
           return  self.getParentFunctionOrMethod();
        })
        .def("getParentFunctionOrMethod", []( clang::Decl& self) -> clang::DeclContext * {
           return  self.getParentFunctionOrMethod();
        })
        .def("getCanonicalDecl", []( clang::Decl& self) -> clang::Decl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::Decl& self) -> const clang::Decl * {
           return  self.getCanonicalDecl();
        })
        .def("isCanonicalDecl", [](const clang::Decl& self) -> bool {
           return  self.isCanonicalDecl();
        })
        //.def("redecls", [](const clang::Decl& self) -> llvm::iterator_range<clang::Decl::redecl_iterator> {
        //   return  self.redecls();
        //})
        .def("getPreviousDecl", []( clang::Decl& self) -> clang::Decl * {
           return  self.getPreviousDecl();
        })
        .def("getPreviousDecl", [](const clang::Decl& self) -> const clang::Decl * {
           return  self.getPreviousDecl();
        })
        .def("isFirstDecl", [](const clang::Decl& self) -> bool {
           return  self.isFirstDecl();
        })
        .def("getMostRecentDecl", []( clang::Decl& self) -> clang::Decl * {
           return  self.getMostRecentDecl();
        })
        .def("getMostRecentDecl", [](const clang::Decl& self) -> const clang::Decl * {
           return  self.getMostRecentDecl();
        })
        .def("getBody", [](const clang::Decl& self) -> clang::Stmt * {
           return  self.getBody();
        })
        .def("hasBody", [](const clang::Decl& self) -> bool {
           return  self.hasBody();
        })
        .def("getBodyRBrace", [](const clang::Decl& self) -> clang::SourceLocation {
           return  self.getBodyRBrace();
        })
        .def("isTemplateParameter", [](const clang::Decl& self) -> bool {
           return  self.isTemplateParameter();
        })
        .def("isTemplateParameterPack", [](const clang::Decl& self) -> bool {
           return  self.isTemplateParameterPack();
        })
        .def("isParameterPack", [](const clang::Decl& self) -> bool {
           return  self.isParameterPack();
        })
        .def("isTemplateDecl", [](const clang::Decl& self) -> bool {
           return  self.isTemplateDecl();
        })
        .def("isFunctionOrFunctionTemplate", [](const clang::Decl& self) -> bool {
           return  self.isFunctionOrFunctionTemplate();
        })
        .def("getDescribedTemplate", [](const clang::Decl& self) -> clang::TemplateDecl * {
           return  self.getDescribedTemplate();
        })
        .def("getAsFunction", []( clang::Decl& self) -> clang::FunctionDecl * {
           return  self.getAsFunction();
        })
        .def("getAsFunction", [](const clang::Decl& self) -> const clang::FunctionDecl * {
           return  self.getAsFunction();
        })
        .def("setLocalExternDecl", []( clang::Decl& self)  {
             self.setLocalExternDecl();
        })
        .def("isLocalExternDecl", []( clang::Decl& self) -> bool {
           return  self.isLocalExternDecl();
        })
        .def("setObjectOfFriendDecl", []( clang::Decl& self, bool PerformFriendInjection)  {
             self.setObjectOfFriendDecl(PerformFriendInjection);
        })
        .def("getFriendObjectKind", [](const clang::Decl& self) -> clang::Decl::FriendObjectKind {
           return  self.getFriendObjectKind();
        })
        .def("setNonMemberOperator", []( clang::Decl& self)  {
             self.setNonMemberOperator();
        })
        //.def("print", [](const clang::Decl& self, llvm::raw_ostream & Out , unsigned int Indentation , bool PrintInstantiation)  {
        //     self.print(Out, Indentation, PrintInstantiation);
        //})
        //.def("print", [](const clang::Decl& self, llvm::raw_ostream & Out , const clang::PrintingPolicy & Policy , unsigned int Indentation , bool PrintInstantiation)  {
        //     self.print(Out, Policy, Indentation, PrintInstantiation);
        //})
        .def("dump", [](const clang::Decl& self)  {
             self.dump();
        })
        .def("dumpColor", [](const clang::Decl& self)  {
             self.dumpColor();
        })
        //.def("dump", [](const clang::Decl& self, llvm::raw_ostream & Out)  {
        //     self.dump(Out);
        //})
        //.def("getFunctionType", [](const clang::Decl& self, bool BlocksToo) -> const clang::FunctionType * {
        //   return  self.getFunctionType(BlocksToo);
        //})
    ;

    py::class_<clang::DeclContext>(m, "DeclContext" )
        .def("getDeclKind", [](const clang::DeclContext& self) -> clang::Decl::Kind {
           return  self.getDeclKind();
        })
        .def("getDeclKindName", [](const clang::DeclContext& self) -> const char * {
           return  self.getDeclKindName();
        })
        .def("getParent", []( clang::DeclContext& self) -> clang::DeclContext * {
           return  self.getParent();
        })
        .def("getParent", [](const clang::DeclContext& self) -> const clang::DeclContext * {
           return  self.getParent();
        })
        .def("getLexicalParent", []( clang::DeclContext& self) -> clang::DeclContext * {
           return  self.getLexicalParent();
        })
        .def("getLexicalParent", [](const clang::DeclContext& self) -> const clang::DeclContext * {
           return  self.getLexicalParent();
        })
        .def("getLookupParent", []( clang::DeclContext& self) -> clang::DeclContext * {
           return  self.getLookupParent();
        })
        .def("getLookupParent", [](const clang::DeclContext& self) -> const clang::DeclContext * {
           return  self.getLookupParent();
        })
        .def("getParentASTContext", [](const clang::DeclContext& self) -> clang::ASTContext & {
           return  self.getParentASTContext();
        })
        .def("isClosure", [](const clang::DeclContext& self) -> bool {
           return  self.isClosure();
        })
        .def("isObjCContainer", [](const clang::DeclContext& self) -> bool {
           return  self.isObjCContainer();
        })
        .def("isFunctionOrMethod", [](const clang::DeclContext& self) -> bool {
           return  self.isFunctionOrMethod();
        })
        .def("isLookupContext", [](const clang::DeclContext& self) -> bool {
           return  self.isLookupContext();
        })
        .def("isFileContext", [](const clang::DeclContext& self) -> bool {
           return  self.isFileContext();
        })
        .def("isTranslationUnit", [](const clang::DeclContext& self) -> bool {
           return  self.isTranslationUnit();
        })
        .def("isRecord", [](const clang::DeclContext& self) -> bool {
           return  self.isRecord();
        })
        .def("isNamespace", [](const clang::DeclContext& self) -> bool {
           return  self.isNamespace();
        })
        .def("isStdNamespace", [](const clang::DeclContext& self) -> bool {
           return  self.isStdNamespace();
        })
        .def("isInlineNamespace", [](const clang::DeclContext& self) -> bool {
           return  self.isInlineNamespace();
        })
        .def("isDependentContext", [](const clang::DeclContext& self) -> bool {
           return  self.isDependentContext();
        })
        .def("isTransparentContext", [](const clang::DeclContext& self) -> bool {
           return  self.isTransparentContext();
        })
        .def("isExternCContext", [](const clang::DeclContext& self) -> bool {
           return  self.isExternCContext();
        })
        .def("isExternCXXContext", [](const clang::DeclContext& self) -> bool {
           return  self.isExternCXXContext();
        })
        .def("Equals", [](const clang::DeclContext& self, const clang::DeclContext * DC) -> bool {
           return  self.Equals(DC);
        })
        .def("Encloses", [](const clang::DeclContext& self, const clang::DeclContext * DC) -> bool {
           return  self.Encloses(DC);
        })
        .def("getNonClosureAncestor", []( clang::DeclContext& self) -> clang::Decl * {
           return  self.getNonClosureAncestor();
        })
        .def("getNonClosureAncestor", [](const clang::DeclContext& self) -> const clang::Decl * {
           return  self.getNonClosureAncestor();
        })
        .def("getPrimaryContext", []( clang::DeclContext& self) -> clang::DeclContext * {
           return  self.getPrimaryContext();
        })
        .def("getPrimaryContext", [](const clang::DeclContext& self) -> const clang::DeclContext * {
           return  self.getPrimaryContext();
        })
        .def("getRedeclContext", []( clang::DeclContext& self) -> clang::DeclContext * {
           return  self.getRedeclContext();
        })
        .def("getRedeclContext", [](const clang::DeclContext& self) -> const clang::DeclContext * {
           return  self.getRedeclContext();
        })
        .def("getEnclosingNamespaceContext", []( clang::DeclContext& self) -> clang::DeclContext * {
           return  self.getEnclosingNamespaceContext();
        })
        .def("getEnclosingNamespaceContext", [](const clang::DeclContext& self) -> const clang::DeclContext * {
           return  self.getEnclosingNamespaceContext();
        })
        .def("getOuterLexicalRecordContext", []( clang::DeclContext& self) -> clang::RecordDecl * {
           return  self.getOuterLexicalRecordContext();
        })
        .def("getOuterLexicalRecordContext", [](const clang::DeclContext& self) -> const clang::RecordDecl * {
           return  self.getOuterLexicalRecordContext();
        })
        .def("InEnclosingNamespaceSetOf", [](const clang::DeclContext& self, const clang::DeclContext * NS) -> bool {
           return  self.InEnclosingNamespaceSetOf(NS);
        })
        //.def("collectAllContexts", []( clang::DeclContext& self, llvm::SmallVectorImpl<clang::DeclContext *> & Contexts)  {
        //     self.collectAllContexts(Contexts);
        //})
        //.def("decls", [](const clang::DeclContext& self) -> llvm::iterator_range<clang::DeclContext::decl_iterator> {
        //   return  self.decls();
        //})
        .def("decls_empty", [](const clang::DeclContext& self) -> bool {
           return  self.decls_empty();
        })
        //.def("noload_decls", [](const clang::DeclContext& self) -> llvm::iterator_range<clang::DeclContext::decl_iterator> {
        //   return  self.noload_decls();
        //})
        .def("addDecl", []( clang::DeclContext& self, clang::Decl * D)  {
             self.addDecl(D);
        })
        .def("addDeclInternal", []( clang::DeclContext& self, clang::Decl * D)  {
             self.addDeclInternal(D);
        })
        .def("addHiddenDecl", []( clang::DeclContext& self, clang::Decl * D)  {
             self.addHiddenDecl(D);
        })
        .def("removeDecl", []( clang::DeclContext& self, clang::Decl * D)  {
             self.removeDecl(D);
        })
        .def("containsDecl", [](const clang::DeclContext& self, clang::Decl * D) -> bool {
           return  self.containsDecl(D);
        })
        //.def("lookup", [](const clang::DeclContext& self, clang::DeclarationName Name) -> clang::DeclContextLookupResult {
        //   return  self.lookup(Name);
        //})
        //.def("noload_lookup", []( clang::DeclContext& self, clang::DeclarationName Name) -> clang::DeclContextLookupResult {
        //   return  self.noload_lookup(Name);
        //})
        //.def("localUncachedLookup", []( clang::DeclContext& self, clang::DeclarationName Name , llvm::SmallVectorImpl<clang::NamedDecl *> & Results)  {
        //     self.localUncachedLookup(Name, Results);
        //})
        .def("makeDeclVisibleInContext", []( clang::DeclContext& self, clang::NamedDecl * D)  {
             self.makeDeclVisibleInContext(D);
        })
        //.def("lookups", [](const clang::DeclContext& self) -> llvm::iterator_range<clang::DeclContext::all_lookups_iterator> {
        //   return  self.lookups();
        //})
        //.def("noload_lookups", [](const clang::DeclContext& self) -> llvm::iterator_range<clang::DeclContext::all_lookups_iterator> {
        //   return  self.noload_lookups();
        //})
        //.def("using_directives", [](const clang::DeclContext& self) -> llvm::iterator_range<clang::DeclContext::udir_iterator> {
        //   return  self.using_directives();
        //})
        //.def("ddiags", [](const clang::DeclContext& self) -> llvm::iterator_range<clang::DeclContext::ddiag_iterator> {
        //   return  self.ddiags();
        //})
        .def("setMustBuildLookupTable", []( clang::DeclContext& self)  {
             self.setMustBuildLookupTable();
        })
        //.def("getLookupPtr", [](const clang::DeclContext& self) -> clang::StoredDeclsMap * {
        //   return  self.getLookupPtr();
        //})
        //.def("buildLookup", []( clang::DeclContext& self) -> clang::StoredDeclsMap * {
        //   return  self.buildLookup();
        //})
        .def("hasExternalLexicalStorage", [](const clang::DeclContext& self) -> bool {
           return  self.hasExternalLexicalStorage();
        })
        .def("setHasExternalLexicalStorage", []( clang::DeclContext& self, bool ES)  {
             self.setHasExternalLexicalStorage(ES);
        })
        .def("hasExternalVisibleStorage", [](const clang::DeclContext& self) -> bool {
           return  self.hasExternalVisibleStorage();
        })
        .def("setHasExternalVisibleStorage", []( clang::DeclContext& self, bool ES)  {
             self.setHasExternalVisibleStorage(ES);
        })
        .def("isDeclInLexicalTraversal", [](const clang::DeclContext& self, const clang::Decl * D) -> bool {
           return  self.isDeclInLexicalTraversal(D);
        })
        .def("setUseQualifiedLookup", []( clang::DeclContext& self, bool use) -> bool {
           return  self.setUseQualifiedLookup(use);
        })
        .def("shouldUseQualifiedLookup", [](const clang::DeclContext& self) -> bool {
           return  self.shouldUseQualifiedLookup();
        })
        .def("dumpDeclContext", [](const clang::DeclContext& self)  {
             self.dumpDeclContext();
        })
        .def("dumpLookups", [](const clang::DeclContext& self)  {
             self.dumpLookups();
        })
        //.def("dumpLookups", [](const clang::DeclContext& self, llvm::raw_ostream & OS , bool DumpDecls)  {
        //     self.dumpLookups(OS, DumpDecls);
        //})
    ;

    py::class_<clang::Qualifiers>(m, "Qualifiers" )
        .def("getAsOpaqueValue", [](const clang::Qualifiers& self) -> unsigned int {
           return  self.getAsOpaqueValue();
        })
        .def("hasConst", [](const clang::Qualifiers& self) -> bool {
           return  self.hasConst();
        })
        .def("setConst", []( clang::Qualifiers& self, bool flag)  {
             self.setConst(flag);
        })
        .def("removeConst", []( clang::Qualifiers& self)  {
             self.removeConst();
        })
        .def("addConst", []( clang::Qualifiers& self)  {
             self.addConst();
        })
        .def("hasVolatile", [](const clang::Qualifiers& self) -> bool {
           return  self.hasVolatile();
        })
        .def("setVolatile", []( clang::Qualifiers& self, bool flag)  {
             self.setVolatile(flag);
        })
        .def("removeVolatile", []( clang::Qualifiers& self)  {
             self.removeVolatile();
        })
        .def("addVolatile", []( clang::Qualifiers& self)  {
             self.addVolatile();
        })
        .def("hasRestrict", [](const clang::Qualifiers& self) -> bool {
           return  self.hasRestrict();
        })
        .def("setRestrict", []( clang::Qualifiers& self, bool flag)  {
             self.setRestrict(flag);
        })
        .def("removeRestrict", []( clang::Qualifiers& self)  {
             self.removeRestrict();
        })
        .def("addRestrict", []( clang::Qualifiers& self)  {
             self.addRestrict();
        })
        .def("hasCVRQualifiers", [](const clang::Qualifiers& self) -> bool {
           return  self.hasCVRQualifiers();
        })
        .def("getCVRQualifiers", [](const clang::Qualifiers& self) -> unsigned int {
           return  self.getCVRQualifiers();
        })
        .def("setCVRQualifiers", []( clang::Qualifiers& self, unsigned int mask)  {
             self.setCVRQualifiers(mask);
        })
        .def("removeCVRQualifiers", []( clang::Qualifiers& self, unsigned int mask)  {
             self.removeCVRQualifiers(mask);
        })
        .def("removeCVRQualifiers", []( clang::Qualifiers& self)  {
             self.removeCVRQualifiers();
        })
        .def("addCVRQualifiers", []( clang::Qualifiers& self, unsigned int mask)  {
             self.addCVRQualifiers(mask);
        })
        .def("hasObjCGCAttr", [](const clang::Qualifiers& self) -> bool {
           return  self.hasObjCGCAttr();
        })
        .def("getObjCGCAttr", [](const clang::Qualifiers& self) -> clang::Qualifiers::GC {
           return  self.getObjCGCAttr();
        })
        .def("setObjCGCAttr", []( clang::Qualifiers& self, clang::Qualifiers::GC type)  {
             self.setObjCGCAttr(type);
        })
        .def("removeObjCGCAttr", []( clang::Qualifiers& self)  {
             self.removeObjCGCAttr();
        })
        .def("addObjCGCAttr", []( clang::Qualifiers& self, clang::Qualifiers::GC type)  {
             self.addObjCGCAttr(type);
        })
        .def("withoutObjCGCAttr", [](const clang::Qualifiers& self) -> clang::Qualifiers {
           return  self.withoutObjCGCAttr();
        })
        .def("withoutObjCLifetime", [](const clang::Qualifiers& self) -> clang::Qualifiers {
           return  self.withoutObjCLifetime();
        })
        .def("hasObjCLifetime", [](const clang::Qualifiers& self) -> bool {
           return  self.hasObjCLifetime();
        })
        .def("getObjCLifetime", [](const clang::Qualifiers& self) -> clang::Qualifiers::ObjCLifetime {
           return  self.getObjCLifetime();
        })
        .def("setObjCLifetime", []( clang::Qualifiers& self, clang::Qualifiers::ObjCLifetime type)  {
             self.setObjCLifetime(type);
        })
        .def("removeObjCLifetime", []( clang::Qualifiers& self)  {
             self.removeObjCLifetime();
        })
        .def("addObjCLifetime", []( clang::Qualifiers& self, clang::Qualifiers::ObjCLifetime type)  {
             self.addObjCLifetime(type);
        })
        .def("hasNonTrivialObjCLifetime", [](const clang::Qualifiers& self) -> bool {
           return  self.hasNonTrivialObjCLifetime();
        })
        .def("hasStrongOrWeakObjCLifetime", [](const clang::Qualifiers& self) -> bool {
           return  self.hasStrongOrWeakObjCLifetime();
        })
        .def("hasAddressSpace", [](const clang::Qualifiers& self) -> bool {
           return  self.hasAddressSpace();
        })
        .def("getAddressSpace", [](const clang::Qualifiers& self) -> unsigned int {
           return  self.getAddressSpace();
        })
        .def("setAddressSpace", []( clang::Qualifiers& self, unsigned int space)  {
             self.setAddressSpace(space);
        })
        .def("removeAddressSpace", []( clang::Qualifiers& self)  {
             self.removeAddressSpace();
        })
        .def("addAddressSpace", []( clang::Qualifiers& self, unsigned int space)  {
             self.addAddressSpace(space);
        })
        .def("hasFastQualifiers", [](const clang::Qualifiers& self) -> bool {
           return  self.hasFastQualifiers();
        })
        .def("getFastQualifiers", [](const clang::Qualifiers& self) -> unsigned int {
           return  self.getFastQualifiers();
        })
        .def("setFastQualifiers", []( clang::Qualifiers& self, unsigned int mask)  {
             self.setFastQualifiers(mask);
        })
        .def("removeFastQualifiers", []( clang::Qualifiers& self, unsigned int mask)  {
             self.removeFastQualifiers(mask);
        })
        .def("removeFastQualifiers", []( clang::Qualifiers& self)  {
             self.removeFastQualifiers();
        })
        .def("addFastQualifiers", []( clang::Qualifiers& self, unsigned int mask)  {
             self.addFastQualifiers(mask);
        })
        .def("hasNonFastQualifiers", [](const clang::Qualifiers& self) -> bool {
           return  self.hasNonFastQualifiers();
        })
        .def("getNonFastQualifiers", [](const clang::Qualifiers& self) -> clang::Qualifiers {
           return  self.getNonFastQualifiers();
        })
        .def("hasQualifiers", [](const clang::Qualifiers& self) -> bool {
           return  self.hasQualifiers();
        })
        .def("empty", [](const clang::Qualifiers& self) -> bool {
           return  self.empty();
        })
        .def("addQualifiers", []( clang::Qualifiers& self, clang::Qualifiers Q)  {
             self.addQualifiers(Q);
        })
        .def("removeQualifiers", []( clang::Qualifiers& self, clang::Qualifiers Q)  {
             self.removeQualifiers(Q);
        })
        .def("addConsistentQualifiers", []( clang::Qualifiers& self, clang::Qualifiers qs)  {
             self.addConsistentQualifiers(qs);
        })
        .def("isAddressSpaceSupersetOf", [](const clang::Qualifiers& self, clang::Qualifiers other) -> bool {
           return  self.isAddressSpaceSupersetOf(other);
        })
        .def("compatiblyIncludes", [](const clang::Qualifiers& self, clang::Qualifiers other) -> bool {
           return  self.compatiblyIncludes(other);
        })
        .def("compatiblyIncludesObjCLifetime", [](const clang::Qualifiers& self, clang::Qualifiers other) -> bool {
           return  self.compatiblyIncludesObjCLifetime(other);
        })
        .def("isStrictSupersetOf", [](const clang::Qualifiers& self, clang::Qualifiers Other) -> bool {
           return  self.isStrictSupersetOf(Other);
        })
        .def("getAsString", [](const clang::Qualifiers& self) -> std::basic_string<char> {
           return  self.getAsString();
        })
        //.def("getAsString", [](const clang::Qualifiers& self, const clang::PrintingPolicy & Policy) -> std::basic_string<char> {
        //   return  self.getAsString(Policy);
        //})
        //.def("isEmptyWhenPrinted", [](const clang::Qualifiers& self, const clang::PrintingPolicy & Policy) -> bool {
        //   return  self.isEmptyWhenPrinted(Policy);
        //})
        //.def("print", [](const clang::Qualifiers& self, llvm::raw_ostream & OS , const clang::PrintingPolicy & Policy , bool appendSpaceIfNonEmpty)  {
        //     self.print(OS, Policy, appendSpaceIfNonEmpty);
        //})
        //.def("Profile", [](const clang::Qualifiers& self, llvm::FoldingSetNodeID & ID)  {
        //     self.Profile(ID);
        //})
    ;

    py::class_<clang::QualType>(m, "QualType" )
        .def("getLocalFastQualifiers", [](const clang::QualType& self) -> unsigned int {
           return  self.getLocalFastQualifiers();
        })
        .def("setLocalFastQualifiers", []( clang::QualType& self, unsigned int Quals)  {
             self.setLocalFastQualifiers(Quals);
        })
        .def("getTypePtr", [](const clang::QualType& self) -> const clang::Type * {
           return  self.getTypePtr();
        })
        .def("getTypePtrOrNull", [](const clang::QualType& self) -> const clang::Type * {
           return  self.getTypePtrOrNull();
        })
        //.def("getBaseTypeIdentifier", [](const clang::QualType& self) -> const clang::IdentifierInfo * {
        //   return  self.getBaseTypeIdentifier();
        //})
        //.def("split", [](const clang::QualType& self) -> clang::SplitQualType {
        //   return  self.split();
        //})
        .def("getAsOpaquePtr", [](const clang::QualType& self) -> void * {
           return  self.getAsOpaquePtr();
        })
        .def("isCanonical", [](const clang::QualType& self) -> bool {
           return  self.isCanonical();
        })
        .def("isCanonicalAsParam", [](const clang::QualType& self) -> bool {
           return  self.isCanonicalAsParam();
        })
        .def("isNull", [](const clang::QualType& self) -> bool {
           return  self.isNull();
        })
        .def("isLocalConstQualified", [](const clang::QualType& self) -> bool {
           return  self.isLocalConstQualified();
        })
        .def("isConstQualified", [](const clang::QualType& self) -> bool {
           return  self.isConstQualified();
        })
        .def("isLocalRestrictQualified", [](const clang::QualType& self) -> bool {
           return  self.isLocalRestrictQualified();
        })
        .def("isRestrictQualified", [](const clang::QualType& self) -> bool {
           return  self.isRestrictQualified();
        })
        .def("isLocalVolatileQualified", [](const clang::QualType& self) -> bool {
           return  self.isLocalVolatileQualified();
        })
        .def("isVolatileQualified", [](const clang::QualType& self) -> bool {
           return  self.isVolatileQualified();
        })
        .def("hasLocalQualifiers", [](const clang::QualType& self) -> bool {
           return  self.hasLocalQualifiers();
        })
        .def("hasQualifiers", [](const clang::QualType& self) -> bool {
           return  self.hasQualifiers();
        })
        .def("hasLocalNonFastQualifiers", [](const clang::QualType& self) -> bool {
           return  self.hasLocalNonFastQualifiers();
        })
        .def("getLocalQualifiers", [](const clang::QualType& self) -> clang::Qualifiers {
           return  self.getLocalQualifiers();
        })
        .def("getQualifiers", [](const clang::QualType& self) -> clang::Qualifiers {
           return  self.getQualifiers();
        })
        .def("getLocalCVRQualifiers", [](const clang::QualType& self) -> unsigned int {
           return  self.getLocalCVRQualifiers();
        })
        .def("getCVRQualifiers", [](const clang::QualType& self) -> unsigned int {
           return  self.getCVRQualifiers();
        })
        .def("isConstant", [](const clang::QualType& self, clang::ASTContext & Ctx) -> bool {
           return  self.isConstant(Ctx);
        })
        .def("isPODType", [](const clang::QualType& self, clang::ASTContext & Context) -> bool {
           return  self.isPODType(Context);
        })
        .def("isCXX98PODType", [](const clang::QualType& self, clang::ASTContext & Context) -> bool {
           return  self.isCXX98PODType(Context);
        })
        .def("isCXX11PODType", [](const clang::QualType& self, clang::ASTContext & Context) -> bool {
           return  self.isCXX11PODType(Context);
        })
        .def("isTrivialType", [](const clang::QualType& self, clang::ASTContext & Context) -> bool {
           return  self.isTrivialType(Context);
        })
        .def("isTriviallyCopyableType", [](const clang::QualType& self, clang::ASTContext & Context) -> bool {
           return  self.isTriviallyCopyableType(Context);
        })
        .def("addConst", []( clang::QualType& self)  {
             self.addConst();
        })
        .def("withConst", [](const clang::QualType& self) -> clang::QualType {
           return  self.withConst();
        })
        .def("addVolatile", []( clang::QualType& self)  {
             self.addVolatile();
        })
        .def("withVolatile", [](const clang::QualType& self) -> clang::QualType {
           return  self.withVolatile();
        })
        .def("addRestrict", []( clang::QualType& self)  {
             self.addRestrict();
        })
        .def("withRestrict", [](const clang::QualType& self) -> clang::QualType {
           return  self.withRestrict();
        })
        .def("withCVRQualifiers", [](const clang::QualType& self, unsigned int CVR) -> clang::QualType {
           return  self.withCVRQualifiers(CVR);
        })
        .def("addFastQualifiers", []( clang::QualType& self, unsigned int TQs)  {
             self.addFastQualifiers(TQs);
        })
        .def("removeLocalConst", []( clang::QualType& self)  {
             self.removeLocalConst();
        })
        .def("removeLocalVolatile", []( clang::QualType& self)  {
             self.removeLocalVolatile();
        })
        .def("removeLocalRestrict", []( clang::QualType& self)  {
             self.removeLocalRestrict();
        })
        .def("removeLocalCVRQualifiers", []( clang::QualType& self, unsigned int Mask)  {
             self.removeLocalCVRQualifiers(Mask);
        })
        .def("removeLocalFastQualifiers", []( clang::QualType& self)  {
             self.removeLocalFastQualifiers();
        })
        .def("removeLocalFastQualifiers", []( clang::QualType& self, unsigned int Mask)  {
             self.removeLocalFastQualifiers(Mask);
        })
        .def("withFastQualifiers", [](const clang::QualType& self, unsigned int TQs) -> clang::QualType {
           return  self.withFastQualifiers(TQs);
        })
        .def("withExactLocalFastQualifiers", [](const clang::QualType& self, unsigned int TQs) -> clang::QualType {
           return  self.withExactLocalFastQualifiers(TQs);
        })
        .def("withoutLocalFastQualifiers", [](const clang::QualType& self) -> clang::QualType {
           return  self.withoutLocalFastQualifiers();
        })
        .def("getCanonicalType", [](const clang::QualType& self) -> clang::QualType {
           return  self.getCanonicalType();
        })
        .def("getLocalUnqualifiedType", [](const clang::QualType& self) -> clang::QualType {
           return  self.getLocalUnqualifiedType();
        })
        .def("getUnqualifiedType", [](const clang::QualType& self) -> clang::QualType {
           return  self.getUnqualifiedType();
        })
        //.def("getSplitUnqualifiedType", [](const clang::QualType& self) -> clang::SplitQualType {
        //   return  self.getSplitUnqualifiedType();
        //})
        .def("isMoreQualifiedThan", [](const clang::QualType& self, clang::QualType Other) -> bool {
           return  self.isMoreQualifiedThan(Other);
        })
        .def("isAtLeastAsQualifiedAs", [](const clang::QualType& self, clang::QualType Other) -> bool {
           return  self.isAtLeastAsQualifiedAs(Other);
        })
        .def("getNonReferenceType", [](const clang::QualType& self) -> clang::QualType {
           return  self.getNonReferenceType();
        })
        .def("getNonLValueExprType", [](const clang::QualType& self, const clang::ASTContext & Context) -> clang::QualType {
           return  self.getNonLValueExprType(Context);
        })
        .def("getDesugaredType", [](const clang::QualType& self, const clang::ASTContext & Context) -> clang::QualType {
           return  self.getDesugaredType(Context);
        })
        //.def("getSplitDesugaredType", [](const clang::QualType& self) -> clang::SplitQualType {
        //   return  self.getSplitDesugaredType();
        //})
        .def("getSingleStepDesugaredType", [](const clang::QualType& self, const clang::ASTContext & Context) -> clang::QualType {
           return  self.getSingleStepDesugaredType(Context);
        })
        .def("IgnoreParens", [](const clang::QualType& self) -> clang::QualType {
           return  self.IgnoreParens();
        })
        .def("getAsString", [](const clang::QualType& self) -> std::basic_string<char> {
           return  self.getAsString();
        })
        //.def("getAsString", [](const clang::QualType& self, const clang::PrintingPolicy & Policy) -> std::basic_string<char> {
        //   return  self.getAsString(Policy);
        //})
        //.def("print", [](const clang::QualType& self, llvm::raw_ostream & OS , const clang::PrintingPolicy & Policy , const llvm::Twine & PlaceHolder , unsigned int Indentation)  {
        //     self.print(OS, Policy, PlaceHolder, Indentation);
        //})
        //.def("getAsStringInternal", [](const clang::QualType& self, std::basic_string<char> & Str , const clang::PrintingPolicy & Policy)  {
        //     self.getAsStringInternal(Str, Policy);
        //})
        //.def("stream", [](const clang::QualType& self, const clang::PrintingPolicy & Policy , const llvm::Twine & PlaceHolder , unsigned int Indentation) -> clang::QualType::StreamedQualTypeHelper {
        //   return  self.stream(Policy, PlaceHolder, Indentation);
        //})
        .def("dump", [](const clang::QualType& self, const char * s)  {
             self.dump(s);
        })
        .def("dump", [](const clang::QualType& self)  {
             self.dump();
        })
        //.def("Profile", [](const clang::QualType& self, llvm::FoldingSetNodeID & ID)  {
        //     self.Profile(ID);
        //})
        .def("getAddressSpace", [](const clang::QualType& self) -> unsigned int {
           return  self.getAddressSpace();
        })
        .def("getObjCGCAttr", [](const clang::QualType& self) -> clang::Qualifiers::GC {
           return  self.getObjCGCAttr();
        })
        .def("isObjCGCWeak", [](const clang::QualType& self) -> bool {
           return  self.isObjCGCWeak();
        })
        .def("isObjCGCStrong", [](const clang::QualType& self) -> bool {
           return  self.isObjCGCStrong();
        })
        .def("getObjCLifetime", [](const clang::QualType& self) -> clang::Qualifiers::ObjCLifetime {
           return  self.getObjCLifetime();
        })
        .def("hasNonTrivialObjCLifetime", [](const clang::QualType& self) -> bool {
           return  self.hasNonTrivialObjCLifetime();
        })
        .def("hasStrongOrWeakObjCLifetime", [](const clang::QualType& self) -> bool {
           return  self.hasStrongOrWeakObjCLifetime();
        })
        .def("isDestructedType", [](const clang::QualType& self) -> clang::QualType::DestructionKind {
           return  self.isDestructedType();
        })
        .def("isCForbiddenLValueType", [](const clang::QualType& self) -> bool {
           return  self.isCForbiddenLValueType();
        })
        //.def("substObjCTypeArgs", [](const clang::QualType& self, clang::ASTContext & ctx , llvm::ArrayRef<clang::QualType> typeArgs , clang::ObjCSubstitutionContext context) -> clang::QualType {
        //   return  self.substObjCTypeArgs(ctx, typeArgs, context);
        //})
        .def("substObjCMemberType", [](const clang::QualType& self, clang::QualType objectType , const clang::DeclContext * dc , clang::ObjCSubstitutionContext context) -> clang::QualType {
           return  self.substObjCMemberType(objectType, dc, context);
        })
        .def("stripObjCKindOfType", [](const clang::QualType& self, const clang::ASTContext & ctx) -> clang::QualType {
           return  self.stripObjCKindOfType(ctx);
        })
    ;

    py::class_<clang::Type>(m, "Type" )
        .def("getTypeClass", [](const clang::Type& self) -> clang::Type::TypeClass {
           return  self.getTypeClass();
        })
        .def("isFromAST", [](const clang::Type& self) -> bool {
           return  self.isFromAST();
        })
        .def("containsUnexpandedParameterPack", [](const clang::Type& self) -> bool {
           return  self.containsUnexpandedParameterPack();
        })
        .def("isCanonicalUnqualified", [](const clang::Type& self) -> bool {
           return  self.isCanonicalUnqualified();
        })
        .def("getLocallyUnqualifiedSingleStepDesugaredType", [](const clang::Type& self) -> clang::QualType {
           return  self.getLocallyUnqualifiedSingleStepDesugaredType();
        })
        .def("isIncompleteOrObjectType", [](const clang::Type& self) -> bool {
           return  self.isIncompleteOrObjectType();
        })
        .def("isObjectType", [](const clang::Type& self) -> bool {
           return  self.isObjectType();
        })
        .def("isLiteralType", [](const clang::Type& self, const clang::ASTContext & Ctx) -> bool {
           return  self.isLiteralType(Ctx);
        })
        .def("isStandardLayoutType", [](const clang::Type& self) -> bool {
           return  self.isStandardLayoutType();
        })
        .def("isBuiltinType", [](const clang::Type& self) -> bool {
           return  self.isBuiltinType();
        })
        .def("isSpecificBuiltinType", [](const clang::Type& self, unsigned int K) -> bool {
           return  self.isSpecificBuiltinType(K);
        })
        .def("isPlaceholderType", [](const clang::Type& self) -> bool {
           return  self.isPlaceholderType();
        })
        //.def("getAsPlaceholderType", [](const clang::Type& self) -> const clang::BuiltinType * {
        //   return  self.getAsPlaceholderType();
        //})
        .def("isSpecificPlaceholderType", [](const clang::Type& self, unsigned int K) -> bool {
           return  self.isSpecificPlaceholderType(K);
        })
        .def("isNonOverloadPlaceholderType", [](const clang::Type& self) -> bool {
           return  self.isNonOverloadPlaceholderType();
        })
        .def("isIntegerType", [](const clang::Type& self) -> bool {
           return  self.isIntegerType();
        })
        .def("isEnumeralType", [](const clang::Type& self) -> bool {
           return  self.isEnumeralType();
        })
        .def("isBooleanType", [](const clang::Type& self) -> bool {
           return  self.isBooleanType();
        })
        .def("isCharType", [](const clang::Type& self) -> bool {
           return  self.isCharType();
        })
        .def("isWideCharType", [](const clang::Type& self) -> bool {
           return  self.isWideCharType();
        })
        .def("isChar16Type", [](const clang::Type& self) -> bool {
           return  self.isChar16Type();
        })
        .def("isChar32Type", [](const clang::Type& self) -> bool {
           return  self.isChar32Type();
        })
        .def("isAnyCharacterType", [](const clang::Type& self) -> bool {
           return  self.isAnyCharacterType();
        })
        .def("isIntegralType", [](const clang::Type& self, clang::ASTContext & Ctx) -> bool {
           return  self.isIntegralType(Ctx);
        })
        .def("isIntegralOrEnumerationType", [](const clang::Type& self) -> bool {
           return  self.isIntegralOrEnumerationType();
        })
        .def("isIntegralOrUnscopedEnumerationType", [](const clang::Type& self) -> bool {
           return  self.isIntegralOrUnscopedEnumerationType();
        })
        .def("isRealFloatingType", [](const clang::Type& self) -> bool {
           return  self.isRealFloatingType();
        })
        .def("isComplexType", [](const clang::Type& self) -> bool {
           return  self.isComplexType();
        })
        .def("isAnyComplexType", [](const clang::Type& self) -> bool {
           return  self.isAnyComplexType();
        })
        .def("isFloatingType", [](const clang::Type& self) -> bool {
           return  self.isFloatingType();
        })
        .def("isHalfType", [](const clang::Type& self) -> bool {
           return  self.isHalfType();
        })
        .def("isRealType", [](const clang::Type& self) -> bool {
           return  self.isRealType();
        })
        .def("isArithmeticType", [](const clang::Type& self) -> bool {
           return  self.isArithmeticType();
        })
        .def("isVoidType", [](const clang::Type& self) -> bool {
           return  self.isVoidType();
        })
        .def("isScalarType", [](const clang::Type& self) -> bool {
           return  self.isScalarType();
        })
        .def("isAggregateType", [](const clang::Type& self) -> bool {
           return  self.isAggregateType();
        })
        .def("isFundamentalType", [](const clang::Type& self) -> bool {
           return  self.isFundamentalType();
        })
        .def("isCompoundType", [](const clang::Type& self) -> bool {
           return  self.isCompoundType();
        })
        .def("isFunctionType", [](const clang::Type& self) -> bool {
           return  self.isFunctionType();
        })
        .def("isFunctionNoProtoType", [](const clang::Type& self) -> bool {
           return  self.isFunctionNoProtoType();
        })
        .def("isFunctionProtoType", [](const clang::Type& self) -> bool {
           return  self.isFunctionProtoType();
        })
        .def("isPointerType", [](const clang::Type& self) -> bool {
           return  self.isPointerType();
        })
        .def("isAnyPointerType", [](const clang::Type& self) -> bool {
           return  self.isAnyPointerType();
        })
        .def("isBlockPointerType", [](const clang::Type& self) -> bool {
           return  self.isBlockPointerType();
        })
        .def("isVoidPointerType", [](const clang::Type& self) -> bool {
           return  self.isVoidPointerType();
        })
        .def("isReferenceType", [](const clang::Type& self) -> bool {
           return  self.isReferenceType();
        })
        .def("isLValueReferenceType", [](const clang::Type& self) -> bool {
           return  self.isLValueReferenceType();
        })
        .def("isRValueReferenceType", [](const clang::Type& self) -> bool {
           return  self.isRValueReferenceType();
        })
        .def("isFunctionPointerType", [](const clang::Type& self) -> bool {
           return  self.isFunctionPointerType();
        })
        .def("isMemberPointerType", [](const clang::Type& self) -> bool {
           return  self.isMemberPointerType();
        })
        .def("isMemberFunctionPointerType", [](const clang::Type& self) -> bool {
           return  self.isMemberFunctionPointerType();
        })
        .def("isMemberDataPointerType", [](const clang::Type& self) -> bool {
           return  self.isMemberDataPointerType();
        })
        .def("isArrayType", [](const clang::Type& self) -> bool {
           return  self.isArrayType();
        })
        .def("isConstantArrayType", [](const clang::Type& self) -> bool {
           return  self.isConstantArrayType();
        })
        .def("isIncompleteArrayType", [](const clang::Type& self) -> bool {
           return  self.isIncompleteArrayType();
        })
        .def("isVariableArrayType", [](const clang::Type& self) -> bool {
           return  self.isVariableArrayType();
        })
        .def("isDependentSizedArrayType", [](const clang::Type& self) -> bool {
           return  self.isDependentSizedArrayType();
        })
        .def("isRecordType", [](const clang::Type& self) -> bool {
           return  self.isRecordType();
        })
        .def("isClassType", [](const clang::Type& self) -> bool {
           return  self.isClassType();
        })
        .def("isStructureType", [](const clang::Type& self) -> bool {
           return  self.isStructureType();
        })
        .def("isObjCBoxableRecordType", [](const clang::Type& self) -> bool {
           return  self.isObjCBoxableRecordType();
        })
        .def("isInterfaceType", [](const clang::Type& self) -> bool {
           return  self.isInterfaceType();
        })
        .def("isStructureOrClassType", [](const clang::Type& self) -> bool {
           return  self.isStructureOrClassType();
        })
        .def("isUnionType", [](const clang::Type& self) -> bool {
           return  self.isUnionType();
        })
        .def("isComplexIntegerType", [](const clang::Type& self) -> bool {
           return  self.isComplexIntegerType();
        })
        .def("isVectorType", [](const clang::Type& self) -> bool {
           return  self.isVectorType();
        })
        .def("isExtVectorType", [](const clang::Type& self) -> bool {
           return  self.isExtVectorType();
        })
        .def("isObjCObjectPointerType", [](const clang::Type& self) -> bool {
           return  self.isObjCObjectPointerType();
        })
        .def("isObjCRetainableType", [](const clang::Type& self) -> bool {
           return  self.isObjCRetainableType();
        })
        .def("isObjCLifetimeType", [](const clang::Type& self) -> bool {
           return  self.isObjCLifetimeType();
        })
        .def("isObjCIndirectLifetimeType", [](const clang::Type& self) -> bool {
           return  self.isObjCIndirectLifetimeType();
        })
        .def("isObjCNSObjectType", [](const clang::Type& self) -> bool {
           return  self.isObjCNSObjectType();
        })
        .def("isObjCIndependentClassType", [](const clang::Type& self) -> bool {
           return  self.isObjCIndependentClassType();
        })
        .def("isObjCObjectType", [](const clang::Type& self) -> bool {
           return  self.isObjCObjectType();
        })
        .def("isObjCQualifiedInterfaceType", [](const clang::Type& self) -> bool {
           return  self.isObjCQualifiedInterfaceType();
        })
        .def("isObjCQualifiedIdType", [](const clang::Type& self) -> bool {
           return  self.isObjCQualifiedIdType();
        })
        .def("isObjCQualifiedClassType", [](const clang::Type& self) -> bool {
           return  self.isObjCQualifiedClassType();
        })
        .def("isObjCObjectOrInterfaceType", [](const clang::Type& self) -> bool {
           return  self.isObjCObjectOrInterfaceType();
        })
        .def("isObjCIdType", [](const clang::Type& self) -> bool {
           return  self.isObjCIdType();
        })
        .def("isObjCInertUnsafeUnretainedType", [](const clang::Type& self) -> bool {
           return  self.isObjCInertUnsafeUnretainedType();
        })
        .def("isObjCClassType", [](const clang::Type& self) -> bool {
           return  self.isObjCClassType();
        })
        .def("isObjCClassOrClassKindOfType", [](const clang::Type& self) -> bool {
           return  self.isObjCClassOrClassKindOfType();
        })
        .def("isBlockCompatibleObjCPointerType", [](const clang::Type& self, clang::ASTContext & ctx) -> bool {
           return  self.isBlockCompatibleObjCPointerType(ctx);
        })
        .def("isObjCSelType", [](const clang::Type& self) -> bool {
           return  self.isObjCSelType();
        })
        .def("isObjCBuiltinType", [](const clang::Type& self) -> bool {
           return  self.isObjCBuiltinType();
        })
        .def("isObjCARCBridgableType", [](const clang::Type& self) -> bool {
           return  self.isObjCARCBridgableType();
        })
        .def("isCARCBridgableType", [](const clang::Type& self) -> bool {
           return  self.isCARCBridgableType();
        })
        .def("isTemplateTypeParmType", [](const clang::Type& self) -> bool {
           return  self.isTemplateTypeParmType();
        })
        .def("isNullPtrType", [](const clang::Type& self) -> bool {
           return  self.isNullPtrType();
        })
        .def("isAtomicType", [](const clang::Type& self) -> bool {
           return  self.isAtomicType();
        })
        .def("isOCLImage1dROType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage1dROType();
        })
        .def("isOCLImage1dArrayROType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage1dArrayROType();
        })
        .def("isOCLImage1dBufferROType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage1dBufferROType();
        })
        .def("isOCLImage2dROType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dROType();
        })
        .def("isOCLImage2dArrayROType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dArrayROType();
        })
        .def("isOCLImage2dDepthROType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dDepthROType();
        })
        .def("isOCLImage2dArrayDepthROType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dArrayDepthROType();
        })
        .def("isOCLImage2dMSAAROType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dMSAAROType();
        })
        .def("isOCLImage2dArrayMSAAROType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dArrayMSAAROType();
        })
        .def("isOCLImage2dMSAADepthROType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dMSAADepthROType();
        })
        .def("isOCLImage2dArrayMSAADepthROType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dArrayMSAADepthROType();
        })
        .def("isOCLImage3dROType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage3dROType();
        })
        .def("isOCLImage1dWOType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage1dWOType();
        })
        .def("isOCLImage1dArrayWOType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage1dArrayWOType();
        })
        .def("isOCLImage1dBufferWOType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage1dBufferWOType();
        })
        .def("isOCLImage2dWOType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dWOType();
        })
        .def("isOCLImage2dArrayWOType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dArrayWOType();
        })
        .def("isOCLImage2dDepthWOType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dDepthWOType();
        })
        .def("isOCLImage2dArrayDepthWOType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dArrayDepthWOType();
        })
        .def("isOCLImage2dMSAAWOType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dMSAAWOType();
        })
        .def("isOCLImage2dArrayMSAAWOType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dArrayMSAAWOType();
        })
        .def("isOCLImage2dMSAADepthWOType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dMSAADepthWOType();
        })
        .def("isOCLImage2dArrayMSAADepthWOType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dArrayMSAADepthWOType();
        })
        .def("isOCLImage3dWOType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage3dWOType();
        })
        .def("isOCLImage1dRWType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage1dRWType();
        })
        .def("isOCLImage1dArrayRWType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage1dArrayRWType();
        })
        .def("isOCLImage1dBufferRWType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage1dBufferRWType();
        })
        .def("isOCLImage2dRWType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dRWType();
        })
        .def("isOCLImage2dArrayRWType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dArrayRWType();
        })
        .def("isOCLImage2dDepthRWType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dDepthRWType();
        })
        .def("isOCLImage2dArrayDepthRWType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dArrayDepthRWType();
        })
        .def("isOCLImage2dMSAARWType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dMSAARWType();
        })
        .def("isOCLImage2dArrayMSAARWType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dArrayMSAARWType();
        })
        .def("isOCLImage2dMSAADepthRWType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dMSAADepthRWType();
        })
        .def("isOCLImage2dArrayMSAADepthRWType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage2dArrayMSAADepthRWType();
        })
        .def("isOCLImage3dRWType", [](const clang::Type& self) -> bool {
           return  self.isOCLImage3dRWType();
        })
        .def("isImageType", [](const clang::Type& self) -> bool {
           return  self.isImageType();
        })
        .def("isSamplerT", [](const clang::Type& self) -> bool {
           return  self.isSamplerT();
        })
        .def("isEventT", [](const clang::Type& self) -> bool {
           return  self.isEventT();
        })
        .def("isClkEventT", [](const clang::Type& self) -> bool {
           return  self.isClkEventT();
        })
        .def("isQueueT", [](const clang::Type& self) -> bool {
           return  self.isQueueT();
        })
        .def("isNDRangeT", [](const clang::Type& self) -> bool {
           return  self.isNDRangeT();
        })
        .def("isReserveIDT", [](const clang::Type& self) -> bool {
           return  self.isReserveIDT();
        })
        .def("isPipeType", [](const clang::Type& self) -> bool {
           return  self.isPipeType();
        })
        .def("isOpenCLSpecificType", [](const clang::Type& self) -> bool {
           return  self.isOpenCLSpecificType();
        })
        .def("isObjCARCImplicitlyUnretainedType", [](const clang::Type& self) -> bool {
           return  self.isObjCARCImplicitlyUnretainedType();
        })
        .def("getObjCARCImplicitLifetime", [](const clang::Type& self) -> clang::Qualifiers::ObjCLifetime {
           return  self.getObjCARCImplicitLifetime();
        })
        .def("getScalarTypeKind", [](const clang::Type& self) -> clang::Type::ScalarTypeKind {
           return  self.getScalarTypeKind();
        })
        .def("isDependentType", [](const clang::Type& self) -> bool {
           return  self.isDependentType();
        })
        .def("isInstantiationDependentType", [](const clang::Type& self) -> bool {
           return  self.isInstantiationDependentType();
        })
        .def("isUndeducedType", [](const clang::Type& self) -> bool {
           return  self.isUndeducedType();
        })
        .def("isVariablyModifiedType", [](const clang::Type& self) -> bool {
           return  self.isVariablyModifiedType();
        })
        .def("hasSizedVLAType", [](const clang::Type& self) -> bool {
           return  self.hasSizedVLAType();
        })
        .def("hasUnnamedOrLocalType", [](const clang::Type& self) -> bool {
           return  self.hasUnnamedOrLocalType();
        })
        .def("isOverloadableType", [](const clang::Type& self) -> bool {
           return  self.isOverloadableType();
        })
        .def("isElaboratedTypeSpecifier", [](const clang::Type& self) -> bool {
           return  self.isElaboratedTypeSpecifier();
        })
        .def("canDecayToPointerType", [](const clang::Type& self) -> bool {
           return  self.canDecayToPointerType();
        })
        .def("hasPointerRepresentation", [](const clang::Type& self) -> bool {
           return  self.hasPointerRepresentation();
        })
        .def("hasObjCPointerRepresentation", [](const clang::Type& self) -> bool {
           return  self.hasObjCPointerRepresentation();
        })
        .def("hasIntegerRepresentation", [](const clang::Type& self) -> bool {
           return  self.hasIntegerRepresentation();
        })
        .def("hasSignedIntegerRepresentation", [](const clang::Type& self) -> bool {
           return  self.hasSignedIntegerRepresentation();
        })
        .def("hasUnsignedIntegerRepresentation", [](const clang::Type& self) -> bool {
           return  self.hasUnsignedIntegerRepresentation();
        })
        .def("hasFloatingRepresentation", [](const clang::Type& self) -> bool {
           return  self.hasFloatingRepresentation();
        })
        //.def("getAsStructureType", [](const clang::Type& self) -> const clang::RecordType * {
        //   return  self.getAsStructureType();
        //})
        //.def("getAsUnionType", [](const clang::Type& self) -> const clang::RecordType * {
        //   return  self.getAsUnionType();
        //})
        //.def("getAsComplexIntegerType", [](const clang::Type& self) -> const clang::ComplexType * {
        //   return  self.getAsComplexIntegerType();
        //})
        //.def("getAsObjCInterfaceType", [](const clang::Type& self) -> const clang::ObjCObjectType * {
        //   return  self.getAsObjCInterfaceType();
        //})
        //.def("getAsObjCInterfacePointerType", [](const clang::Type& self) -> const clang::ObjCObjectPointerType * {
        //   return  self.getAsObjCInterfacePointerType();
        //})
        //.def("getAsObjCQualifiedIdType", [](const clang::Type& self) -> const clang::ObjCObjectPointerType * {
        //   return  self.getAsObjCQualifiedIdType();
        //})
        //.def("getAsObjCQualifiedClassType", [](const clang::Type& self) -> const clang::ObjCObjectPointerType * {
        //   return  self.getAsObjCQualifiedClassType();
        //})
        //.def("getAsObjCQualifiedInterfaceType", [](const clang::Type& self) -> const clang::ObjCObjectType * {
        //   return  self.getAsObjCQualifiedInterfaceType();
        //})
        .def("getAsCXXRecordDecl", [](const clang::Type& self) -> clang::CXXRecordDecl * {
           return  self.getAsCXXRecordDecl();
        })
        .def("getAsTagDecl", [](const clang::Type& self) -> clang::TagDecl * {
           return  self.getAsTagDecl();
        })
        .def("getPointeeCXXRecordDecl", [](const clang::Type& self) -> const clang::CXXRecordDecl * {
           return  self.getPointeeCXXRecordDecl();
        })
        //.def("getContainedAutoType", [](const clang::Type& self) -> clang::AutoType * {
        //   return  self.getContainedAutoType();
        //})
        //.def("getAsArrayTypeUnsafe", [](const clang::Type& self) -> const clang::ArrayType * {
        //   return  self.getAsArrayTypeUnsafe();
        //})
        //.def("castAsArrayTypeUnsafe", [](const clang::Type& self) -> const clang::ArrayType * {
        //   return  self.castAsArrayTypeUnsafe();
        //})
        .def("getBaseElementTypeUnsafe", [](const clang::Type& self) -> const clang::Type * {
           return  self.getBaseElementTypeUnsafe();
        })
        .def("getArrayElementTypeNoTypeQual", [](const clang::Type& self) -> const clang::Type * {
           return  self.getArrayElementTypeNoTypeQual();
        })
        .def("getPointeeType", [](const clang::Type& self) -> clang::QualType {
           return  self.getPointeeType();
        })
        .def("getUnqualifiedDesugaredType", [](const clang::Type& self) -> const clang::Type * {
           return  self.getUnqualifiedDesugaredType();
        })
        .def("isPromotableIntegerType", [](const clang::Type& self) -> bool {
           return  self.isPromotableIntegerType();
        })
        .def("isSignedIntegerType", [](const clang::Type& self) -> bool {
           return  self.isSignedIntegerType();
        })
        .def("isUnsignedIntegerType", [](const clang::Type& self) -> bool {
           return  self.isUnsignedIntegerType();
        })
        .def("isSignedIntegerOrEnumerationType", [](const clang::Type& self) -> bool {
           return  self.isSignedIntegerOrEnumerationType();
        })
        .def("isUnsignedIntegerOrEnumerationType", [](const clang::Type& self) -> bool {
           return  self.isUnsignedIntegerOrEnumerationType();
        })
        .def("isConstantSizeType", [](const clang::Type& self) -> bool {
           return  self.isConstantSizeType();
        })
        .def("isSpecifierType", [](const clang::Type& self) -> bool {
           return  self.isSpecifierType();
        })
        .def("getLinkage", [](const clang::Type& self) -> clang::Linkage {
           return  self.getLinkage();
        })
        .def("getVisibility", [](const clang::Type& self) -> clang::Visibility {
           return  self.getVisibility();
        })
        .def("isVisibilityExplicit", [](const clang::Type& self) -> bool {
           return  self.isVisibilityExplicit();
        })
        //.def("getLinkageAndVisibility", [](const clang::Type& self) -> clang::LinkageInfo {
        //   return  self.getLinkageAndVisibility();
        //})
        .def("isLinkageValid", [](const clang::Type& self) -> bool {
           return  self.isLinkageValid();
        })
        //.def("getNullability", [](const clang::Type& self, const clang::ASTContext & context) -> llvm::Optional<clang::NullabilityKind> {
        //   return  self.getNullability(context);
        //})
        .def("canHaveNullability", [](const clang::Type& self) -> bool {
           return  self.canHaveNullability();
        })
        //.def("getObjCSubstitutions", [](const clang::Type& self, const clang::DeclContext * dc) -> llvm::Optional<llvm::ArrayRef<clang::QualType> > {
        //   return  self.getObjCSubstitutions(dc);
        //})
        .def("acceptsObjCTypeParams", [](const clang::Type& self) -> bool {
           return  self.acceptsObjCTypeParams();
        })
        .def("getTypeClassName", [](const clang::Type& self) -> const char * {
           return  self.getTypeClassName();
        })
        .def("getCanonicalTypeInternal", [](const clang::Type& self) -> clang::QualType {
           return  self.getCanonicalTypeInternal();
        })
        //.def("getCanonicalTypeUnqualified", [](const clang::Type& self) -> clang::CanQual<clang::Type> {
        //   return  self.getCanonicalTypeUnqualified();
        //})
        .def("dump", [](const clang::Type& self)  {
             self.dump();
        })
    ;

    py::class_<clang::TypeSourceInfo>(m, "TypeSourceInfo" )
        .def("getType", [](const clang::TypeSourceInfo& self) -> clang::QualType {
           return  self.getType();
        })
        //.def("getTypeLoc", [](const clang::TypeSourceInfo& self) -> clang::TypeLoc {
        //   return  self.getTypeLoc();
        //})
        .def("overrideType", []( clang::TypeSourceInfo& self, clang::QualType T)  {
             self.overrideType(T);
        })
    ;

    py::class_<clang::TranslationUnitDecl, decl_deleter<clang::TranslationUnitDecl>::type>(m, "TranslationUnitDecl" , py::base<clang::Decl>())
        .def("getASTContext", [](const clang::TranslationUnitDecl& self) -> clang::ASTContext & {
           return  self.getASTContext();
        })
        .def("getAnonymousNamespace", [](const clang::TranslationUnitDecl& self) -> clang::NamespaceDecl * {
           return  self.getAnonymousNamespace();
        })
        .def("setAnonymousNamespace", []( clang::TranslationUnitDecl& self, clang::NamespaceDecl * D)  {
             self.setAnonymousNamespace(D);
        })
    ;

    py::class_<clang::PragmaCommentDecl, decl_deleter<clang::PragmaCommentDecl>::type>(m, "PragmaCommentDecl" , py::base<clang::Decl>())
        .def("getCommentKind", [](const clang::PragmaCommentDecl& self) -> clang::PragmaMSCommentKind {
           return  self.getCommentKind();
        })
        .def("getArg", [](const clang::PragmaCommentDecl& self) -> llvm::StringRef {
           return  self.getArg();
        })
    ;

    py::class_<clang::PragmaDetectMismatchDecl, decl_deleter<clang::PragmaDetectMismatchDecl>::type>(m, "PragmaDetectMismatchDecl" , py::base<clang::Decl>())
        .def("getName", [](const clang::PragmaDetectMismatchDecl& self) -> llvm::StringRef {
           return  self.getName();
        })
        .def("getValue", [](const clang::PragmaDetectMismatchDecl& self) -> llvm::StringRef {
           return  self.getValue();
        })
    ;

    py::class_<clang::ExternCContextDecl, decl_deleter<clang::ExternCContextDecl>::type>(m, "ExternCContextDecl" , py::base<clang::Decl>())
    ;

    py::class_<clang::NamedDecl, decl_deleter<clang::NamedDecl>::type>(m, "NamedDecl" , py::base<clang::Decl>())
        //.def("getIdentifier", [](const clang::NamedDecl& self) -> clang::IdentifierInfo * {
        //   return  self.getIdentifier();
        //})
        .def("getName", [](const clang::NamedDecl& self) -> llvm::StringRef {
           return  self.getName();
        })
        .def("getNameAsString", [](const clang::NamedDecl& self) -> std::basic_string<char> {
           return  self.getNameAsString();
        })
        //.def("printName", [](const clang::NamedDecl& self, llvm::raw_ostream & os)  {
        //     self.printName(os);
        //})
        .def("getDeclName", [](const clang::NamedDecl& self) -> clang::DeclarationName {
           return  self.getDeclName();
        })
        .def("setDeclName", []( clang::NamedDecl& self, clang::DeclarationName N)  {
             self.setDeclName(N);
        })
        //.def("printQualifiedName", [](const clang::NamedDecl& self, llvm::raw_ostream & OS)  {
        //     self.printQualifiedName(OS);
        //})
        //.def("printQualifiedName", [](const clang::NamedDecl& self, llvm::raw_ostream & OS , const clang::PrintingPolicy & Policy)  {
        //     self.printQualifiedName(OS, Policy);
        //})
        .def("getQualifiedNameAsString", [](const clang::NamedDecl& self) -> std::basic_string<char> {
           return  self.getQualifiedNameAsString();
        })
        //.def("getNameForDiagnostic", [](const clang::NamedDecl& self, llvm::raw_ostream & OS , const clang::PrintingPolicy & Policy , bool Qualified)  {
        //     self.getNameForDiagnostic(OS, Policy, Qualified);
        //})
        .def("declarationReplaces", [](const clang::NamedDecl& self, clang::NamedDecl * OldD , bool IsKnownNewer) -> bool {
           return  self.declarationReplaces(OldD, IsKnownNewer);
        })
        .def("hasLinkage", [](const clang::NamedDecl& self) -> bool {
           return  self.hasLinkage();
        })
        .def("isHidden", [](const clang::NamedDecl& self) -> bool {
           return  self.isHidden();
        })
        .def("setHidden", []( clang::NamedDecl& self, bool Hide)  {
             self.setHidden(Hide);
        })
        .def("isCXXClassMember", [](const clang::NamedDecl& self) -> bool {
           return  self.isCXXClassMember();
        })
        .def("isCXXInstanceMember", [](const clang::NamedDecl& self) -> bool {
           return  self.isCXXInstanceMember();
        })
        .def("getLinkageInternal", [](const clang::NamedDecl& self) -> clang::Linkage {
           return  self.getLinkageInternal();
        })
        .def("getFormalLinkage", [](const clang::NamedDecl& self) -> clang::Linkage {
           return  self.getFormalLinkage();
        })
        .def("hasExternalFormalLinkage", [](const clang::NamedDecl& self) -> bool {
           return  self.hasExternalFormalLinkage();
        })
        .def("isExternallyVisible", [](const clang::NamedDecl& self) -> bool {
           return  self.isExternallyVisible();
        })
        .def("getVisibility", [](const clang::NamedDecl& self) -> clang::Visibility {
           return  self.getVisibility();
        })
        //.def("getLinkageAndVisibility", [](const clang::NamedDecl& self) -> clang::LinkageInfo {
        //   return  self.getLinkageAndVisibility();
        //})
        //.def("getExplicitVisibility", [](const clang::NamedDecl& self, clang::NamedDecl::ExplicitVisibilityKind kind) -> llvm::Optional<clang::Visibility> {
        //   return  self.getExplicitVisibility(kind);
        //})
        .def("isLinkageValid", [](const clang::NamedDecl& self) -> bool {
           return  self.isLinkageValid();
        })
        .def("hasLinkageBeenComputed", [](const clang::NamedDecl& self) -> bool {
           return  self.hasLinkageBeenComputed();
        })
        .def("getUnderlyingDecl", []( clang::NamedDecl& self) -> clang::NamedDecl * {
           return  self.getUnderlyingDecl();
        })
        .def("getUnderlyingDecl", [](const clang::NamedDecl& self) -> const clang::NamedDecl * {
           return  self.getUnderlyingDecl();
        })
        .def("getMostRecentDecl", []( clang::NamedDecl& self) -> clang::NamedDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getMostRecentDecl", [](const clang::NamedDecl& self) -> const clang::NamedDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getObjCFStringFormattingFamily", [](const clang::NamedDecl& self) -> clang::ObjCStringFormatFamily {
           return  self.getObjCFStringFormattingFamily();
        })
    ;

    py::class_<clang::LabelDecl, decl_deleter<clang::LabelDecl>::type>(m, "LabelDecl" , py::base<clang::NamedDecl>())
        .def("getStmt", [](const clang::LabelDecl& self) -> clang::LabelStmt * {
           return  self.getStmt();
        })
        .def("setStmt", []( clang::LabelDecl& self, clang::LabelStmt * T)  {
             self.setStmt(T);
        })
        .def("isGnuLocal", [](const clang::LabelDecl& self) -> bool {
           return  self.isGnuLocal();
        })
        .def("setLocStart", []( clang::LabelDecl& self, clang::SourceLocation L)  {
             self.setLocStart(L);
        })
        .def("getSourceRange", [](const clang::LabelDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("isMSAsmLabel", [](const clang::LabelDecl& self) -> bool {
           return  self.isMSAsmLabel();
        })
        .def("isResolvedMSAsmLabel", [](const clang::LabelDecl& self) -> bool {
           return  self.isResolvedMSAsmLabel();
        })
        .def("setMSAsmLabel", []( clang::LabelDecl& self, llvm::StringRef Name)  {
             self.setMSAsmLabel(Name);
        })
        .def("getMSAsmLabel", [](const clang::LabelDecl& self) -> llvm::StringRef {
           return  self.getMSAsmLabel();
        })
        .def("setMSAsmLabelResolved", []( clang::LabelDecl& self)  {
             self.setMSAsmLabelResolved();
        })
    ;

    py::class_<clang::NamespaceDecl, decl_deleter<clang::NamespaceDecl>::type>(m, "NamespaceDecl" , py::base<clang::NamedDecl>())
        .def("isAnonymousNamespace", [](const clang::NamespaceDecl& self) -> bool {
           return  self.isAnonymousNamespace();
        })
        .def("isInline", [](const clang::NamespaceDecl& self) -> bool {
           return  self.isInline();
        })
        .def("setInline", []( clang::NamespaceDecl& self, bool Inline)  {
             self.setInline(Inline);
        })
        .def("getOriginalNamespace", []( clang::NamespaceDecl& self) -> clang::NamespaceDecl * {
           return  self.getOriginalNamespace();
        })
        .def("getOriginalNamespace", [](const clang::NamespaceDecl& self) -> const clang::NamespaceDecl * {
           return  self.getOriginalNamespace();
        })
        .def("isOriginalNamespace", [](const clang::NamespaceDecl& self) -> bool {
           return  self.isOriginalNamespace();
        })
        .def("getAnonymousNamespace", [](const clang::NamespaceDecl& self) -> clang::NamespaceDecl * {
           return  self.getAnonymousNamespace();
        })
        .def("setAnonymousNamespace", []( clang::NamespaceDecl& self, clang::NamespaceDecl * D)  {
             self.setAnonymousNamespace(D);
        })
        .def("getCanonicalDecl", []( clang::NamespaceDecl& self) -> clang::NamespaceDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::NamespaceDecl& self) -> const clang::NamespaceDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getSourceRange", [](const clang::NamespaceDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getLocStart", [](const clang::NamespaceDecl& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getRBraceLoc", [](const clang::NamespaceDecl& self) -> clang::SourceLocation {
           return  self.getRBraceLoc();
        })
        .def("setLocStart", []( clang::NamespaceDecl& self, clang::SourceLocation L)  {
             self.setLocStart(L);
        })
        .def("setRBraceLoc", []( clang::NamespaceDecl& self, clang::SourceLocation L)  {
             self.setRBraceLoc(L);
        })
    ;

    py::class_<clang::ValueDecl, decl_deleter<clang::ValueDecl>::type>(m, "ValueDecl" , py::base<clang::NamedDecl>())
        .def("getType", [](const clang::ValueDecl& self) -> clang::QualType {
           return  self.getType();
        })
        .def("setType", []( clang::ValueDecl& self, clang::QualType newType)  {
             self.setType(newType);
        })
        .def("isWeak", [](const clang::ValueDecl& self) -> bool {
           return  self.isWeak();
        })
    ;

    py::class_<clang::DeclaratorDecl, decl_deleter<clang::DeclaratorDecl>::type>(m, "DeclaratorDecl" , py::base<clang::ValueDecl>())
        .def("getTypeSourceInfo", [](const clang::DeclaratorDecl& self) -> clang::TypeSourceInfo * {
           return  self.getTypeSourceInfo();
        })
        .def("setTypeSourceInfo", []( clang::DeclaratorDecl& self, clang::TypeSourceInfo * TI)  {
             self.setTypeSourceInfo(TI);
        })
        .def("getInnerLocStart", [](const clang::DeclaratorDecl& self) -> clang::SourceLocation {
           return  self.getInnerLocStart();
        })
        .def("setInnerLocStart", []( clang::DeclaratorDecl& self, clang::SourceLocation L)  {
             self.setInnerLocStart(L);
        })
        .def("getOuterLocStart", [](const clang::DeclaratorDecl& self) -> clang::SourceLocation {
           return  self.getOuterLocStart();
        })
        .def("getSourceRange", [](const clang::DeclaratorDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getLocStart", [](const clang::DeclaratorDecl& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        //.def("getQualifier", [](const clang::DeclaratorDecl& self) -> clang::NestedNameSpecifier * {
        //   return  self.getQualifier();
        //})
        //.def("getQualifierLoc", [](const clang::DeclaratorDecl& self) -> clang::NestedNameSpecifierLoc {
        //   return  self.getQualifierLoc();
        //})
        //.def("setQualifierInfo", []( clang::DeclaratorDecl& self, clang::NestedNameSpecifierLoc QualifierLoc)  {
        //     self.setQualifierInfo(QualifierLoc);
        //})
        .def("getNumTemplateParameterLists", [](const clang::DeclaratorDecl& self) -> unsigned int {
           return  self.getNumTemplateParameterLists();
        })
        //.def("getTemplateParameterList", [](const clang::DeclaratorDecl& self, unsigned int index) -> clang::TemplateParameterList * {
        //   return  self.getTemplateParameterList(index);
        //})
        //.def("setTemplateParameterListsInfo", []( clang::DeclaratorDecl& self, clang::ASTContext & Context , llvm::ArrayRef<clang::TemplateParameterList *> TPLists)  {
        //     self.setTemplateParameterListsInfo(Context, TPLists);
        //})
        .def("getTypeSpecStartLoc", [](const clang::DeclaratorDecl& self) -> clang::SourceLocation {
           return  self.getTypeSpecStartLoc();
        })
    ;

    py::class_<clang::VarDecl, decl_deleter<clang::VarDecl>::type>(m, "VarDecl" , py::base<clang::DeclaratorDecl>())
        .def("getSourceRange", [](const clang::VarDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getStorageClass", [](const clang::VarDecl& self) -> clang::StorageClass {
           return  self.getStorageClass();
        })
        .def("setStorageClass", []( clang::VarDecl& self, clang::StorageClass SC)  {
             self.setStorageClass(SC);
        })
        .def("setTSCSpec", []( clang::VarDecl& self, clang::ThreadStorageClassSpecifier TSC)  {
             self.setTSCSpec(TSC);
        })
        .def("getTSCSpec", [](const clang::VarDecl& self) -> clang::ThreadStorageClassSpecifier {
           return  self.getTSCSpec();
        })
        .def("getTLSKind", [](const clang::VarDecl& self) -> clang::VarDecl::TLSKind {
           return  self.getTLSKind();
        })
        .def("hasLocalStorage", [](const clang::VarDecl& self) -> bool {
           return  self.hasLocalStorage();
        })
        .def("isStaticLocal", [](const clang::VarDecl& self) -> bool {
           return  self.isStaticLocal();
        })
        .def("hasExternalStorage", [](const clang::VarDecl& self) -> bool {
           return  self.hasExternalStorage();
        })
        .def("hasGlobalStorage", [](const clang::VarDecl& self) -> bool {
           return  self.hasGlobalStorage();
        })
        .def("getStorageDuration", [](const clang::VarDecl& self) -> clang::StorageDuration {
           return  self.getStorageDuration();
        })
        .def("getLanguageLinkage", [](const clang::VarDecl& self) -> clang::LanguageLinkage {
           return  self.getLanguageLinkage();
        })
        .def("isExternC", [](const clang::VarDecl& self) -> bool {
           return  self.isExternC();
        })
        .def("isInExternCContext", [](const clang::VarDecl& self) -> bool {
           return  self.isInExternCContext();
        })
        .def("isInExternCXXContext", [](const clang::VarDecl& self) -> bool {
           return  self.isInExternCXXContext();
        })
        .def("isLocalVarDecl", [](const clang::VarDecl& self) -> bool {
           return  self.isLocalVarDecl();
        })
        .def("isLocalVarDeclOrParm", [](const clang::VarDecl& self) -> bool {
           return  self.isLocalVarDeclOrParm();
        })
        .def("isFunctionOrMethodVarDecl", [](const clang::VarDecl& self) -> bool {
           return  self.isFunctionOrMethodVarDecl();
        })
        .def("isStaticDataMember", [](const clang::VarDecl& self) -> bool {
           return  self.isStaticDataMember();
        })
        .def("getCanonicalDecl", []( clang::VarDecl& self) -> clang::VarDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::VarDecl& self) -> const clang::VarDecl * {
           return  self.getCanonicalDecl();
        })
        .def("isThisDeclarationADefinition", (clang::VarDecl::DefinitionKind (clang::VarDecl::*)(clang::ASTContext &) const)&clang::VarDecl::isThisDeclarationADefinition)
        .def("isThisDeclarationADefinition", [](const clang::VarDecl& self) -> clang::VarDecl::DefinitionKind {
           return  self.isThisDeclarationADefinition();
        })
        .def("hasDefinition", (clang::VarDecl::DefinitionKind (clang::VarDecl::*)(clang::ASTContext &) const)&clang::VarDecl::hasDefinition)
        .def("hasDefinition", [](const clang::VarDecl& self) -> clang::VarDecl::DefinitionKind {
           return  self.hasDefinition();
        })
        .def("getActingDefinition", []( clang::VarDecl& self) -> clang::VarDecl * {
           return  self.getActingDefinition();
        })
        .def("getActingDefinition", [](const clang::VarDecl& self) -> const clang::VarDecl * {
           return  self.getActingDefinition();
        })
        .def("getDefinition", (clang::VarDecl * (clang::VarDecl::*)(clang::ASTContext &))&clang::VarDecl::getDefinition)
        .def("getDefinition", [](const clang::VarDecl& self, clang::ASTContext & C) -> const clang::VarDecl * {
           return  self.getDefinition(C);
        })
        .def("getDefinition", []( clang::VarDecl& self) -> clang::VarDecl * {
           return  self.getDefinition();
        })
        .def("getDefinition", [](const clang::VarDecl& self) -> const clang::VarDecl * {
           return  self.getDefinition();
        })
        .def("isOutOfLine", [](const clang::VarDecl& self) -> bool {
           return  self.isOutOfLine();
        })
        .def("getOutOfLineDefinition", []( clang::VarDecl& self) -> clang::VarDecl * {
           return  self.getOutOfLineDefinition();
        })
        .def("isFileVarDecl", [](const clang::VarDecl& self) -> bool {
           return  self.isFileVarDecl();
        })
        .def("getAnyInitializer", [](const clang::VarDecl& self) -> const clang::Expr * {
           return  self.getAnyInitializer();
        })
        .def("hasInit", [](const clang::VarDecl& self) -> bool {
           return  self.hasInit();
        })
        .def("getInit", [](const clang::VarDecl& self) -> const clang::Expr * {
           return  self.getInit();
        })
        .def("getInit", []( clang::VarDecl& self) -> clang::Expr * {
           return  self.getInit();
        })
        .def("setInit", []( clang::VarDecl& self, clang::Expr * I)  {
             self.setInit(I);
        })
        .def("isUsableInConstantExpressions", [](const clang::VarDecl& self, clang::ASTContext & C) -> bool {
           return  self.isUsableInConstantExpressions(C);
        })
        //.def("ensureEvaluatedStmt", [](const clang::VarDecl& self) -> clang::EvaluatedStmt * {
        //   return  self.ensureEvaluatedStmt();
        //})
        //.def("evaluateValue", [](const clang::VarDecl& self) -> clang::APValue * {
        //   return  self.evaluateValue();
        //})
        //.def("evaluateValue", [](const clang::VarDecl& self, llvm::SmallVectorImpl<std::pair<clang::SourceLocation, clang::PartialDiagnostic> > & Notes) -> clang::APValue * {
        //   return  self.evaluateValue(Notes);
        //})
        //.def("getEvaluatedValue", [](const clang::VarDecl& self) -> clang::APValue * {
        //   return  self.getEvaluatedValue();
        //})
        .def("isInitKnownICE", [](const clang::VarDecl& self) -> bool {
           return  self.isInitKnownICE();
        })
        .def("isInitICE", [](const clang::VarDecl& self) -> bool {
           return  self.isInitICE();
        })
        .def("checkInitIsICE", [](const clang::VarDecl& self) -> bool {
           return  self.checkInitIsICE();
        })
        .def("setInitStyle", []( clang::VarDecl& self, clang::VarDecl::InitializationStyle Style)  {
             self.setInitStyle(Style);
        })
        .def("getInitStyle", [](const clang::VarDecl& self) -> clang::VarDecl::InitializationStyle {
           return  self.getInitStyle();
        })
        .def("isDirectInit", [](const clang::VarDecl& self) -> bool {
           return  self.isDirectInit();
        })
        .def("isExceptionVariable", [](const clang::VarDecl& self) -> bool {
           return  self.isExceptionVariable();
        })
        .def("setExceptionVariable", []( clang::VarDecl& self, bool EV)  {
             self.setExceptionVariable(EV);
        })
        .def("isNRVOVariable", [](const clang::VarDecl& self) -> bool {
           return  self.isNRVOVariable();
        })
        .def("setNRVOVariable", []( clang::VarDecl& self, bool NRVO)  {
             self.setNRVOVariable(NRVO);
        })
        .def("isCXXForRangeDecl", [](const clang::VarDecl& self) -> bool {
           return  self.isCXXForRangeDecl();
        })
        .def("setCXXForRangeDecl", []( clang::VarDecl& self, bool FRD)  {
             self.setCXXForRangeDecl(FRD);
        })
        .def("isARCPseudoStrong", [](const clang::VarDecl& self) -> bool {
           return  self.isARCPseudoStrong();
        })
        .def("setARCPseudoStrong", []( clang::VarDecl& self, bool ps)  {
             self.setARCPseudoStrong(ps);
        })
        .def("isConstexpr", [](const clang::VarDecl& self) -> bool {
           return  self.isConstexpr();
        })
        .def("setConstexpr", []( clang::VarDecl& self, bool IC)  {
             self.setConstexpr(IC);
        })
        .def("isInitCapture", [](const clang::VarDecl& self) -> bool {
           return  self.isInitCapture();
        })
        .def("setInitCapture", []( clang::VarDecl& self, bool IC)  {
             self.setInitCapture(IC);
        })
        .def("isPreviousDeclInSameBlockScope", [](const clang::VarDecl& self) -> bool {
           return  self.isPreviousDeclInSameBlockScope();
        })
        .def("setPreviousDeclInSameBlockScope", []( clang::VarDecl& self, bool Same)  {
             self.setPreviousDeclInSameBlockScope(Same);
        })
        .def("getInstantiatedFromStaticDataMember", [](const clang::VarDecl& self) -> clang::VarDecl * {
           return  self.getInstantiatedFromStaticDataMember();
        })
        .def("getTemplateSpecializationKind", [](const clang::VarDecl& self) -> clang::TemplateSpecializationKind {
           return  self.getTemplateSpecializationKind();
        })
        .def("getPointOfInstantiation", [](const clang::VarDecl& self) -> clang::SourceLocation {
           return  self.getPointOfInstantiation();
        })
        //.def("getMemberSpecializationInfo", [](const clang::VarDecl& self) -> clang::MemberSpecializationInfo * {
        //   return  self.getMemberSpecializationInfo();
        //})
        .def("setTemplateSpecializationKind", []( clang::VarDecl& self, clang::TemplateSpecializationKind TSK , clang::SourceLocation PointOfInstantiation)  {
             self.setTemplateSpecializationKind(TSK, PointOfInstantiation);
        })
        .def("setInstantiationOfStaticDataMember", []( clang::VarDecl& self, clang::VarDecl * VD , clang::TemplateSpecializationKind TSK)  {
             self.setInstantiationOfStaticDataMember(VD, TSK);
        })
        .def("getDescribedVarTemplate", [](const clang::VarDecl& self) -> clang::VarTemplateDecl * {
           return  self.getDescribedVarTemplate();
        })
        .def("setDescribedVarTemplate", []( clang::VarDecl& self, clang::VarTemplateDecl * Template)  {
             self.setDescribedVarTemplate(Template);
        })
    ;

    py::class_<clang::ImplicitParamDecl, decl_deleter<clang::ImplicitParamDecl>::type>(m, "ImplicitParamDecl" , py::base<clang::VarDecl>())
    ;

    py::class_<clang::ParmVarDecl, decl_deleter<clang::ParmVarDecl>::type>(m, "ParmVarDecl" , py::base<clang::VarDecl>())
        .def("getSourceRange", [](const clang::ParmVarDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("setObjCMethodScopeInfo", []( clang::ParmVarDecl& self, unsigned int parameterIndex)  {
             self.setObjCMethodScopeInfo(parameterIndex);
        })
        .def("setScopeInfo", []( clang::ParmVarDecl& self, unsigned int scopeDepth , unsigned int parameterIndex)  {
             self.setScopeInfo(scopeDepth, parameterIndex);
        })
        .def("isObjCMethodParameter", [](const clang::ParmVarDecl& self) -> bool {
           return  self.isObjCMethodParameter();
        })
        .def("getFunctionScopeDepth", [](const clang::ParmVarDecl& self) -> unsigned int {
           return  self.getFunctionScopeDepth();
        })
        .def("getFunctionScopeIndex", [](const clang::ParmVarDecl& self) -> unsigned int {
           return  self.getFunctionScopeIndex();
        })
        .def("getObjCDeclQualifier", [](const clang::ParmVarDecl& self) -> clang::Decl::ObjCDeclQualifier {
           return  self.getObjCDeclQualifier();
        })
        .def("setObjCDeclQualifier", []( clang::ParmVarDecl& self, clang::Decl::ObjCDeclQualifier QTVal)  {
             self.setObjCDeclQualifier(QTVal);
        })
        .def("isKNRPromoted", [](const clang::ParmVarDecl& self) -> bool {
           return  self.isKNRPromoted();
        })
        .def("setKNRPromoted", []( clang::ParmVarDecl& self, bool promoted)  {
             self.setKNRPromoted(promoted);
        })
        .def("getDefaultArg", []( clang::ParmVarDecl& self) -> clang::Expr * {
           return  self.getDefaultArg();
        })
        .def("getDefaultArg", [](const clang::ParmVarDecl& self) -> const clang::Expr * {
           return  self.getDefaultArg();
        })
        .def("setDefaultArg", []( clang::ParmVarDecl& self, clang::Expr * defarg)  {
             self.setDefaultArg(defarg);
        })
        .def("getDefaultArgRange", [](const clang::ParmVarDecl& self) -> clang::SourceRange {
           return  self.getDefaultArgRange();
        })
        .def("setUninstantiatedDefaultArg", []( clang::ParmVarDecl& self, clang::Expr * arg)  {
             self.setUninstantiatedDefaultArg(arg);
        })
        .def("getUninstantiatedDefaultArg", []( clang::ParmVarDecl& self) -> clang::Expr * {
           return  self.getUninstantiatedDefaultArg();
        })
        .def("getUninstantiatedDefaultArg", [](const clang::ParmVarDecl& self) -> const clang::Expr * {
           return  self.getUninstantiatedDefaultArg();
        })
        .def("hasDefaultArg", [](const clang::ParmVarDecl& self) -> bool {
           return  self.hasDefaultArg();
        })
        .def("hasUnparsedDefaultArg", [](const clang::ParmVarDecl& self) -> bool {
           return  self.hasUnparsedDefaultArg();
        })
        .def("hasUninstantiatedDefaultArg", [](const clang::ParmVarDecl& self) -> bool {
           return  self.hasUninstantiatedDefaultArg();
        })
        .def("setUnparsedDefaultArg", []( clang::ParmVarDecl& self)  {
             self.setUnparsedDefaultArg();
        })
        .def("hasInheritedDefaultArg", [](const clang::ParmVarDecl& self) -> bool {
           return  self.hasInheritedDefaultArg();
        })
        .def("setHasInheritedDefaultArg", []( clang::ParmVarDecl& self, bool I)  {
             self.setHasInheritedDefaultArg(I);
        })
        .def("getOriginalType", [](const clang::ParmVarDecl& self) -> clang::QualType {
           return  self.getOriginalType();
        })
        .def("isParameterPack", [](const clang::ParmVarDecl& self) -> bool {
           return  self.isParameterPack();
        })
        .def("setOwningFunction", []( clang::ParmVarDecl& self, clang::DeclContext * FD)  {
             self.setOwningFunction(FD);
        })
    ;

    py::class_<clang::FunctionDecl, decl_deleter<clang::FunctionDecl>::type>(m, "FunctionDecl" , py::base<clang::DeclaratorDecl>())
        .def("getNameInfo", [](const clang::FunctionDecl& self) -> clang::DeclarationNameInfo {
           return  self.getNameInfo();
        })
        //.def("getNameForDiagnostic", [](const clang::FunctionDecl& self, llvm::raw_ostream & OS , const clang::PrintingPolicy & Policy , bool Qualified)  {
        //     self.getNameForDiagnostic(OS, Policy, Qualified);
        //})
        .def("setRangeEnd", []( clang::FunctionDecl& self, clang::SourceLocation E)  {
             self.setRangeEnd(E);
        })
        .def("getSourceRange", [](const clang::FunctionDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("hasBody", [](const clang::FunctionDecl& self) -> bool {
           return  self.hasBody();
        })
        .def("hasTrivialBody", [](const clang::FunctionDecl& self) -> bool {
           return  self.hasTrivialBody();
        })
        .def("isDefined", [](const clang::FunctionDecl& self) -> bool {
           return  self.isDefined();
        })
        .def("getBody", [](const clang::FunctionDecl& self) -> clang::Stmt * {
           return  self.getBody();
        })
        .def("isThisDeclarationADefinition", [](const clang::FunctionDecl& self) -> bool {
           return  self.isThisDeclarationADefinition();
        })
        .def("doesThisDeclarationHaveABody", [](const clang::FunctionDecl& self) -> bool {
           return  self.doesThisDeclarationHaveABody();
        })
        .def("setBody", []( clang::FunctionDecl& self, clang::Stmt * B)  {
             self.setBody(B);
        })
        .def("setLazyBody", []( clang::FunctionDecl& self, unsigned long Offset)  {
             self.setLazyBody(Offset);
        })
        .def("isVariadic", [](const clang::FunctionDecl& self) -> bool {
           return  self.isVariadic();
        })
        .def("isVirtualAsWritten", [](const clang::FunctionDecl& self) -> bool {
           return  self.isVirtualAsWritten();
        })
        .def("setVirtualAsWritten", []( clang::FunctionDecl& self, bool V)  {
             self.setVirtualAsWritten(V);
        })
        .def("isPure", [](const clang::FunctionDecl& self) -> bool {
           return  self.isPure();
        })
        .def("setPure", []( clang::FunctionDecl& self, bool P)  {
             self.setPure(P);
        })
        .def("isLateTemplateParsed", [](const clang::FunctionDecl& self) -> bool {
           return  self.isLateTemplateParsed();
        })
        .def("setLateTemplateParsed", []( clang::FunctionDecl& self, bool ILT)  {
             self.setLateTemplateParsed(ILT);
        })
        .def("isTrivial", [](const clang::FunctionDecl& self) -> bool {
           return  self.isTrivial();
        })
        .def("setTrivial", []( clang::FunctionDecl& self, bool IT)  {
             self.setTrivial(IT);
        })
        .def("isDefaulted", [](const clang::FunctionDecl& self) -> bool {
           return  self.isDefaulted();
        })
        .def("setDefaulted", []( clang::FunctionDecl& self, bool D)  {
             self.setDefaulted(D);
        })
        .def("isExplicitlyDefaulted", [](const clang::FunctionDecl& self) -> bool {
           return  self.isExplicitlyDefaulted();
        })
        .def("setExplicitlyDefaulted", []( clang::FunctionDecl& self, bool ED)  {
             self.setExplicitlyDefaulted(ED);
        })
        .def("hasImplicitReturnZero", [](const clang::FunctionDecl& self) -> bool {
           return  self.hasImplicitReturnZero();
        })
        .def("setHasImplicitReturnZero", []( clang::FunctionDecl& self, bool IRZ)  {
             self.setHasImplicitReturnZero(IRZ);
        })
        .def("hasPrototype", [](const clang::FunctionDecl& self) -> bool {
           return  self.hasPrototype();
        })
        .def("hasWrittenPrototype", [](const clang::FunctionDecl& self) -> bool {
           return  self.hasWrittenPrototype();
        })
        .def("hasInheritedPrototype", [](const clang::FunctionDecl& self) -> bool {
           return  self.hasInheritedPrototype();
        })
        .def("setHasInheritedPrototype", []( clang::FunctionDecl& self, bool P)  {
             self.setHasInheritedPrototype(P);
        })
        .def("isConstexpr", [](const clang::FunctionDecl& self) -> bool {
           return  self.isConstexpr();
        })
        .def("setConstexpr", []( clang::FunctionDecl& self, bool IC)  {
             self.setConstexpr(IC);
        })
        .def("usesSEHTry", [](const clang::FunctionDecl& self) -> bool {
           return  self.usesSEHTry();
        })
        .def("setUsesSEHTry", []( clang::FunctionDecl& self, bool UST)  {
             self.setUsesSEHTry(UST);
        })
        .def("isDeleted", [](const clang::FunctionDecl& self) -> bool {
           return  self.isDeleted();
        })
        .def("isDeletedAsWritten", [](const clang::FunctionDecl& self) -> bool {
           return  self.isDeletedAsWritten();
        })
        .def("setDeletedAsWritten", []( clang::FunctionDecl& self, bool D)  {
             self.setDeletedAsWritten(D);
        })
        .def("isMain", [](const clang::FunctionDecl& self) -> bool {
           return  self.isMain();
        })
        .def("isMSVCRTEntryPoint", [](const clang::FunctionDecl& self) -> bool {
           return  self.isMSVCRTEntryPoint();
        })
        .def("isReservedGlobalPlacementOperator", [](const clang::FunctionDecl& self) -> bool {
           return  self.isReservedGlobalPlacementOperator();
        })
        .def("isReplaceableGlobalAllocationFunction", [](const clang::FunctionDecl& self) -> bool {
           return  self.isReplaceableGlobalAllocationFunction();
        })
        .def("getLanguageLinkage", [](const clang::FunctionDecl& self) -> clang::LanguageLinkage {
           return  self.getLanguageLinkage();
        })
        .def("isExternC", [](const clang::FunctionDecl& self) -> bool {
           return  self.isExternC();
        })
        .def("isInExternCContext", [](const clang::FunctionDecl& self) -> bool {
           return  self.isInExternCContext();
        })
        .def("isInExternCXXContext", [](const clang::FunctionDecl& self) -> bool {
           return  self.isInExternCXXContext();
        })
        .def("isGlobal", [](const clang::FunctionDecl& self) -> bool {
           return  self.isGlobal();
        })
        .def("isNoReturn", [](const clang::FunctionDecl& self) -> bool {
           return  self.isNoReturn();
        })
        .def("hasSkippedBody", [](const clang::FunctionDecl& self) -> bool {
           return  self.hasSkippedBody();
        })
        .def("setHasSkippedBody", []( clang::FunctionDecl& self, bool Skipped)  {
             self.setHasSkippedBody(Skipped);
        })
        .def("setPreviousDeclaration", []( clang::FunctionDecl& self, clang::FunctionDecl * PrevDecl)  {
             self.setPreviousDeclaration(PrevDecl);
        })
        .def("getCanonicalDecl", []( clang::FunctionDecl& self) -> clang::FunctionDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::FunctionDecl& self) -> const clang::FunctionDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getBuiltinID", [](const clang::FunctionDecl& self) -> unsigned int {
           return  self.getBuiltinID();
        })
        .def("param_size", [](const clang::FunctionDecl& self) -> unsigned int {
           return  self.param_size();
        })
        //.def("params", []( clang::FunctionDecl& self) -> llvm::iterator_range<clang::ParmVarDecl **> {
        //   return  self.params();
        //})
        //.def("params", [](const clang::FunctionDecl& self) -> llvm::iterator_range<clang::ParmVarDecl *const *> {
        //   return  self.params();
        //})
        .def("getNumParams", [](const clang::FunctionDecl& self) -> unsigned int {
           return  self.getNumParams();
        })
        .def("getParamDecl", [](const clang::FunctionDecl& self, unsigned int i) -> const clang::ParmVarDecl * {
           return  self.getParamDecl(i);
        })
        .def("getParamDecl", []( clang::FunctionDecl& self, unsigned int i) -> clang::ParmVarDecl * {
           return  self.getParamDecl(i);
        })
        //.def("setParams", []( clang::FunctionDecl& self, llvm::ArrayRef<clang::ParmVarDecl *> NewParamInfo)  {
        //     self.setParams(NewParamInfo);
        //})
        //.def("parameters", [](const clang::FunctionDecl& self) -> llvm::ArrayRef<clang::ParmVarDecl *> {
        //   return  self.parameters();
        //})
        //.def("getDeclsInPrototypeScope", [](const clang::FunctionDecl& self) -> llvm::ArrayRef<clang::NamedDecl *> {
        //   return  self.getDeclsInPrototypeScope();
        //})
        //.def("setDeclsInPrototypeScope", []( clang::FunctionDecl& self, llvm::ArrayRef<clang::NamedDecl *> NewDecls)  {
        //     self.setDeclsInPrototypeScope(NewDecls);
        //})
        .def("getMinRequiredArguments", [](const clang::FunctionDecl& self) -> unsigned int {
           return  self.getMinRequiredArguments();
        })
        .def("getReturnType", [](const clang::FunctionDecl& self) -> clang::QualType {
           return  self.getReturnType();
        })
        .def("getReturnTypeSourceRange", [](const clang::FunctionDecl& self) -> clang::SourceRange {
           return  self.getReturnTypeSourceRange();
        })
        .def("getCallResultType", [](const clang::FunctionDecl& self) -> clang::QualType {
           return  self.getCallResultType();
        })
        //.def("getUnusedResultAttr", [](const clang::FunctionDecl& self) -> const clang::Attr * {
        //   return  self.getUnusedResultAttr();
        //})
        .def("hasUnusedResultAttr", [](const clang::FunctionDecl& self) -> bool {
           return  self.hasUnusedResultAttr();
        })
        .def("getStorageClass", [](const clang::FunctionDecl& self) -> clang::StorageClass {
           return  self.getStorageClass();
        })
        .def("isInlineSpecified", [](const clang::FunctionDecl& self) -> bool {
           return  self.isInlineSpecified();
        })
        .def("setInlineSpecified", []( clang::FunctionDecl& self, bool I)  {
             self.setInlineSpecified(I);
        })
        .def("setImplicitlyInline", []( clang::FunctionDecl& self)  {
             self.setImplicitlyInline();
        })
        .def("isInlined", [](const clang::FunctionDecl& self) -> bool {
           return  self.isInlined();
        })
        .def("isInlineDefinitionExternallyVisible", [](const clang::FunctionDecl& self) -> bool {
           return  self.isInlineDefinitionExternallyVisible();
        })
        .def("isMSExternInline", [](const clang::FunctionDecl& self) -> bool {
           return  self.isMSExternInline();
        })
        .def("doesDeclarationForceExternallyVisibleDefinition", [](const clang::FunctionDecl& self) -> bool {
           return  self.doesDeclarationForceExternallyVisibleDefinition();
        })
        .def("isOverloadedOperator", [](const clang::FunctionDecl& self) -> bool {
           return  self.isOverloadedOperator();
        })
        .def("getOverloadedOperator", [](const clang::FunctionDecl& self) -> clang::OverloadedOperatorKind {
           return  self.getOverloadedOperator();
        })
        //.def("getLiteralIdentifier", [](const clang::FunctionDecl& self) -> const clang::IdentifierInfo * {
        //   return  self.getLiteralIdentifier();
        //})
        .def("getInstantiatedFromMemberFunction", [](const clang::FunctionDecl& self) -> clang::FunctionDecl * {
           return  self.getInstantiatedFromMemberFunction();
        })
        .def("getTemplatedKind", [](const clang::FunctionDecl& self) -> clang::FunctionDecl::TemplatedKind {
           return  self.getTemplatedKind();
        })
        //.def("getMemberSpecializationInfo", [](const clang::FunctionDecl& self) -> clang::MemberSpecializationInfo * {
        //   return  self.getMemberSpecializationInfo();
        //})
        .def("setInstantiationOfMemberFunction", []( clang::FunctionDecl& self, clang::FunctionDecl * FD , clang::TemplateSpecializationKind TSK)  {
             self.setInstantiationOfMemberFunction(FD, TSK);
        })
        .def("getDescribedFunctionTemplate", [](const clang::FunctionDecl& self) -> clang::FunctionTemplateDecl * {
           return  self.getDescribedFunctionTemplate();
        })
        .def("setDescribedFunctionTemplate", []( clang::FunctionDecl& self, clang::FunctionTemplateDecl * Template)  {
             self.setDescribedFunctionTemplate(Template);
        })
        .def("isFunctionTemplateSpecialization", [](const clang::FunctionDecl& self) -> bool {
           return  self.isFunctionTemplateSpecialization();
        })
        .def("getClassScopeSpecializationPattern", [](const clang::FunctionDecl& self) -> clang::FunctionDecl * {
           return  self.getClassScopeSpecializationPattern();
        })
        //.def("getTemplateSpecializationInfo", [](const clang::FunctionDecl& self) -> clang::FunctionTemplateSpecializationInfo * {
        //   return  self.getTemplateSpecializationInfo();
        //})
        .def("isImplicitlyInstantiable", [](const clang::FunctionDecl& self) -> bool {
           return  self.isImplicitlyInstantiable();
        })
        .def("isTemplateInstantiation", [](const clang::FunctionDecl& self) -> bool {
           return  self.isTemplateInstantiation();
        })
        .def("getTemplateInstantiationPattern", [](const clang::FunctionDecl& self) -> clang::FunctionDecl * {
           return  self.getTemplateInstantiationPattern();
        })
        .def("getPrimaryTemplate", [](const clang::FunctionDecl& self) -> clang::FunctionTemplateDecl * {
           return  self.getPrimaryTemplate();
        })
        //.def("getTemplateSpecializationArgs", [](const clang::FunctionDecl& self) -> const clang::TemplateArgumentList * {
        //   return  self.getTemplateSpecializationArgs();
        //})
        //.def("getTemplateSpecializationArgsAsWritten", [](const clang::FunctionDecl& self) -> const clang::ASTTemplateArgumentListInfo * {
        //   return  self.getTemplateSpecializationArgsAsWritten();
        //})
        //.def("setFunctionTemplateSpecialization", []( clang::FunctionDecl& self, clang::FunctionTemplateDecl * Template , const clang::TemplateArgumentList * TemplateArgs , void * InsertPos , clang::TemplateSpecializationKind TSK , const clang::TemplateArgumentListInfo * TemplateArgsAsWritten , clang::SourceLocation PointOfInstantiation)  {
        //     self.setFunctionTemplateSpecialization(Template, TemplateArgs, InsertPos, TSK, TemplateArgsAsWritten, PointOfInstantiation);
        //})
        //.def("setDependentTemplateSpecialization", []( clang::FunctionDecl& self, clang::ASTContext & Context , const clang::UnresolvedSetImpl & Templates , const clang::TemplateArgumentListInfo & TemplateArgs)  {
        //     self.setDependentTemplateSpecialization(Context, Templates, TemplateArgs);
        //})
        //.def("getDependentSpecializationInfo", [](const clang::FunctionDecl& self) -> clang::DependentFunctionTemplateSpecializationInfo * {
        //   return  self.getDependentSpecializationInfo();
        //})
        .def("getTemplateSpecializationKind", [](const clang::FunctionDecl& self) -> clang::TemplateSpecializationKind {
           return  self.getTemplateSpecializationKind();
        })
        .def("setTemplateSpecializationKind", []( clang::FunctionDecl& self, clang::TemplateSpecializationKind TSK , clang::SourceLocation PointOfInstantiation)  {
             self.setTemplateSpecializationKind(TSK, PointOfInstantiation);
        })
        .def("getPointOfInstantiation", [](const clang::FunctionDecl& self) -> clang::SourceLocation {
           return  self.getPointOfInstantiation();
        })
        .def("isOutOfLine", [](const clang::FunctionDecl& self) -> bool {
           return  self.isOutOfLine();
        })
        .def("getMemoryFunctionKind", [](const clang::FunctionDecl& self) -> unsigned int {
           return  self.getMemoryFunctionKind();
        })
    ;

    py::class_<clang::FieldDecl, decl_deleter<clang::FieldDecl>::type>(m, "FieldDecl" , py::base<clang::DeclaratorDecl>())
        .def("getFieldIndex", [](const clang::FieldDecl& self) -> unsigned int {
           return  self.getFieldIndex();
        })
        .def("isMutable", [](const clang::FieldDecl& self) -> bool {
           return  self.isMutable();
        })
        .def("isBitField", [](const clang::FieldDecl& self) -> bool {
           return  self.isBitField();
        })
        .def("isUnnamedBitfield", [](const clang::FieldDecl& self) -> bool {
           return  self.isUnnamedBitfield();
        })
        .def("isAnonymousStructOrUnion", [](const clang::FieldDecl& self) -> bool {
           return  self.isAnonymousStructOrUnion();
        })
        .def("getBitWidth", [](const clang::FieldDecl& self) -> clang::Expr * {
           return  self.getBitWidth();
        })
        .def("getBitWidthValue", [](const clang::FieldDecl& self, const clang::ASTContext & Ctx) -> unsigned int {
           return  self.getBitWidthValue(Ctx);
        })
        .def("setBitWidth", []( clang::FieldDecl& self, clang::Expr * Width)  {
             self.setBitWidth(Width);
        })
        .def("removeBitWidth", []( clang::FieldDecl& self)  {
             self.removeBitWidth();
        })
        .def("getInClassInitStyle", [](const clang::FieldDecl& self) -> clang::InClassInitStyle {
           return  self.getInClassInitStyle();
        })
        .def("hasInClassInitializer", [](const clang::FieldDecl& self) -> bool {
           return  self.hasInClassInitializer();
        })
        .def("getInClassInitializer", [](const clang::FieldDecl& self) -> clang::Expr * {
           return  self.getInClassInitializer();
        })
        .def("setInClassInitializer", []( clang::FieldDecl& self, clang::Expr * Init)  {
             self.setInClassInitializer(Init);
        })
        .def("removeInClassInitializer", []( clang::FieldDecl& self)  {
             self.removeInClassInitializer();
        })
        .def("hasCapturedVLAType", [](const clang::FieldDecl& self) -> bool {
           return  self.hasCapturedVLAType();
        })
        //.def("getCapturedVLAType", [](const clang::FieldDecl& self) -> const clang::VariableArrayType * {
        //   return  self.getCapturedVLAType();
        //})
        //.def("setCapturedVLAType", []( clang::FieldDecl& self, const clang::VariableArrayType * VLAType)  {
        //     self.setCapturedVLAType(VLAType);
        //})
        .def("getParent", [](const clang::FieldDecl& self) -> const clang::RecordDecl * {
           return  self.getParent();
        })
        .def("getParent", []( clang::FieldDecl& self) -> clang::RecordDecl * {
           return  self.getParent();
        })
        .def("getSourceRange", [](const clang::FieldDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getCanonicalDecl", []( clang::FieldDecl& self) -> clang::FieldDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::FieldDecl& self) -> const clang::FieldDecl * {
           return  self.getCanonicalDecl();
        })
    ;

    py::class_<clang::EnumConstantDecl, decl_deleter<clang::EnumConstantDecl>::type>(m, "EnumConstantDecl" , py::base<clang::ValueDecl>())
        .def("getInitExpr", [](const clang::EnumConstantDecl& self) -> const clang::Expr * {
           return  self.getInitExpr();
        })
        .def("getInitExpr", []( clang::EnumConstantDecl& self) -> clang::Expr * {
           return  self.getInitExpr();
        })
        //.def("getInitVal", [](const clang::EnumConstantDecl& self) -> const llvm::APSInt & {
        //   return  self.getInitVal();
        //})
        .def("setInitExpr", []( clang::EnumConstantDecl& self, clang::Expr * E)  {
             self.setInitExpr(E);
        })
        //.def("setInitVal", []( clang::EnumConstantDecl& self, const llvm::APSInt & V)  {
        //     self.setInitVal(V);
        //})
        .def("getSourceRange", [](const clang::EnumConstantDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getCanonicalDecl", []( clang::EnumConstantDecl& self) -> clang::EnumConstantDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::EnumConstantDecl& self) -> const clang::EnumConstantDecl * {
           return  self.getCanonicalDecl();
        })
    ;

    py::class_<clang::IndirectFieldDecl, decl_deleter<clang::IndirectFieldDecl>::type>(m, "IndirectFieldDecl" , py::base<clang::ValueDecl>())
        //.def("chain", [](const clang::IndirectFieldDecl& self) -> llvm::iterator_range<clang::NamedDecl *const *> {
        //   return  self.chain();
        //})
        .def("getChainingSize", [](const clang::IndirectFieldDecl& self) -> unsigned int {
           return  self.getChainingSize();
        })
        .def("getAnonField", [](const clang::IndirectFieldDecl& self) -> clang::FieldDecl * {
           return  self.getAnonField();
        })
        .def("getVarDecl", [](const clang::IndirectFieldDecl& self) -> clang::VarDecl * {
           return  self.getVarDecl();
        })
        .def("getCanonicalDecl", []( clang::IndirectFieldDecl& self) -> clang::IndirectFieldDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::IndirectFieldDecl& self) -> const clang::IndirectFieldDecl * {
           return  self.getCanonicalDecl();
        })
    ;

    py::class_<clang::TypeDecl, decl_deleter<clang::TypeDecl>::type>(m, "TypeDecl" , py::base<clang::NamedDecl>())
        .def("getTypeForDecl", [](const clang::TypeDecl& self) -> const clang::Type * {
           return  self.getTypeForDecl();
        })
        .def("setTypeForDecl", []( clang::TypeDecl& self, const clang::Type * TD)  {
             self.setTypeForDecl(TD);
        })
        .def("getLocStart", [](const clang::TypeDecl& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("setLocStart", []( clang::TypeDecl& self, clang::SourceLocation L)  {
             self.setLocStart(L);
        })
        .def("getSourceRange", [](const clang::TypeDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
    ;

    py::class_<clang::TypedefNameDecl, decl_deleter<clang::TypedefNameDecl>::type>(m, "TypedefNameDecl" , py::base<clang::TypeDecl>())
        .def("isModed", [](const clang::TypedefNameDecl& self) -> bool {
           return  self.isModed();
        })
        .def("getTypeSourceInfo", [](const clang::TypedefNameDecl& self) -> clang::TypeSourceInfo * {
           return  self.getTypeSourceInfo();
        })
        .def("getUnderlyingType", [](const clang::TypedefNameDecl& self) -> clang::QualType {
           return  self.getUnderlyingType();
        })
        .def("setTypeSourceInfo", []( clang::TypedefNameDecl& self, clang::TypeSourceInfo * newType)  {
             self.setTypeSourceInfo(newType);
        })
        .def("setModedTypeSourceInfo", []( clang::TypedefNameDecl& self, clang::TypeSourceInfo * unmodedTSI , clang::QualType modedTy)  {
             self.setModedTypeSourceInfo(unmodedTSI, modedTy);
        })
        .def("getCanonicalDecl", []( clang::TypedefNameDecl& self) -> clang::TypedefNameDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::TypedefNameDecl& self) -> const clang::TypedefNameDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getAnonDeclWithTypedefName", [](const clang::TypedefNameDecl& self, bool AnyRedecl) -> clang::TagDecl * {
           return  self.getAnonDeclWithTypedefName(AnyRedecl);
        })
    ;

    py::class_<clang::TypedefDecl, decl_deleter<clang::TypedefDecl>::type>(m, "TypedefDecl" , py::base<clang::TypedefNameDecl>())
        .def("getSourceRange", [](const clang::TypedefDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
    ;

    py::class_<clang::TypeAliasDecl, decl_deleter<clang::TypeAliasDecl>::type>(m, "TypeAliasDecl" , py::base<clang::TypedefNameDecl>())
        .def("getSourceRange", [](const clang::TypeAliasDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getDescribedAliasTemplate", [](const clang::TypeAliasDecl& self) -> clang::TypeAliasTemplateDecl * {
           return  self.getDescribedAliasTemplate();
        })
        .def("setDescribedAliasTemplate", []( clang::TypeAliasDecl& self, clang::TypeAliasTemplateDecl * TAT)  {
             self.setDescribedAliasTemplate(TAT);
        })
    ;

    py::class_<clang::TagDecl, decl_deleter<clang::TagDecl>::type>(m, "TagDecl" , py::base<clang::TypeDecl>())
        .def("getRBraceLoc", [](const clang::TagDecl& self) -> clang::SourceLocation {
           return  self.getRBraceLoc();
        })
        .def("setRBraceLoc", []( clang::TagDecl& self, clang::SourceLocation L)  {
             self.setRBraceLoc(L);
        })
        .def("getInnerLocStart", [](const clang::TagDecl& self) -> clang::SourceLocation {
           return  self.getInnerLocStart();
        })
        .def("getOuterLocStart", [](const clang::TagDecl& self) -> clang::SourceLocation {
           return  self.getOuterLocStart();
        })
        .def("getSourceRange", [](const clang::TagDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getCanonicalDecl", []( clang::TagDecl& self) -> clang::TagDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::TagDecl& self) -> const clang::TagDecl * {
           return  self.getCanonicalDecl();
        })
        .def("isThisDeclarationADefinition", [](const clang::TagDecl& self) -> bool {
           return  self.isThisDeclarationADefinition();
        })
        .def("isCompleteDefinition", [](const clang::TagDecl& self) -> bool {
           return  self.isCompleteDefinition();
        })
        .def("isCompleteDefinitionRequired", [](const clang::TagDecl& self) -> bool {
           return  self.isCompleteDefinitionRequired();
        })
        .def("isBeingDefined", [](const clang::TagDecl& self) -> bool {
           return  self.isBeingDefined();
        })
        .def("isEmbeddedInDeclarator", [](const clang::TagDecl& self) -> bool {
           return  self.isEmbeddedInDeclarator();
        })
        .def("setEmbeddedInDeclarator", []( clang::TagDecl& self, bool isInDeclarator)  {
             self.setEmbeddedInDeclarator(isInDeclarator);
        })
        .def("isFreeStanding", [](const clang::TagDecl& self) -> bool {
           return  self.isFreeStanding();
        })
        .def("setFreeStanding", []( clang::TagDecl& self, bool isFreeStanding)  {
             self.setFreeStanding(isFreeStanding);
        })
        .def("isDependentType", [](const clang::TagDecl& self) -> bool {
           return  self.isDependentType();
        })
        .def("startDefinition", []( clang::TagDecl& self)  {
             self.startDefinition();
        })
        .def("getDefinition", [](const clang::TagDecl& self) -> clang::TagDecl * {
           return  self.getDefinition();
        })
        .def("setCompleteDefinition", []( clang::TagDecl& self, bool V)  {
             self.setCompleteDefinition(V);
        })
        .def("setCompleteDefinitionRequired", []( clang::TagDecl& self, bool V)  {
             self.setCompleteDefinitionRequired(V);
        })
        .def("getKindName", [](const clang::TagDecl& self) -> llvm::StringRef {
           return  self.getKindName();
        })
        .def("getTagKind", [](const clang::TagDecl& self) -> clang::TagTypeKind {
           return  self.getTagKind();
        })
        .def("setTagKind", []( clang::TagDecl& self, clang::TagTypeKind TK)  {
             self.setTagKind(TK);
        })
        .def("isStruct", [](const clang::TagDecl& self) -> bool {
           return  self.isStruct();
        })
        .def("isInterface", [](const clang::TagDecl& self) -> bool {
           return  self.isInterface();
        })
        .def("isClass", [](const clang::TagDecl& self) -> bool {
           return  self.isClass();
        })
        .def("isUnion", [](const clang::TagDecl& self) -> bool {
           return  self.isUnion();
        })
        .def("isEnum", [](const clang::TagDecl& self) -> bool {
           return  self.isEnum();
        })
        .def("hasNameForLinkage", [](const clang::TagDecl& self) -> bool {
           return  self.hasNameForLinkage();
        })
        .def("getTypedefNameForAnonDecl", [](const clang::TagDecl& self) -> clang::TypedefNameDecl * {
           return  self.getTypedefNameForAnonDecl();
        })
        .def("setTypedefNameForAnonDecl", []( clang::TagDecl& self, clang::TypedefNameDecl * TDD)  {
             self.setTypedefNameForAnonDecl(TDD);
        })
        //.def("getQualifier", [](const clang::TagDecl& self) -> clang::NestedNameSpecifier * {
        //   return  self.getQualifier();
        //})
        //.def("getQualifierLoc", [](const clang::TagDecl& self) -> clang::NestedNameSpecifierLoc {
        //   return  self.getQualifierLoc();
        //})
        //.def("setQualifierInfo", []( clang::TagDecl& self, clang::NestedNameSpecifierLoc QualifierLoc)  {
        //     self.setQualifierInfo(QualifierLoc);
        //})
        .def("getNumTemplateParameterLists", [](const clang::TagDecl& self) -> unsigned int {
           return  self.getNumTemplateParameterLists();
        })
        //.def("getTemplateParameterList", [](const clang::TagDecl& self, unsigned int i) -> clang::TemplateParameterList * {
        //   return  self.getTemplateParameterList(i);
        //})
        //.def("setTemplateParameterListsInfo", []( clang::TagDecl& self, clang::ASTContext & Context , llvm::ArrayRef<clang::TemplateParameterList *> TPLists)  {
        //     self.setTemplateParameterListsInfo(Context, TPLists);
        //})
    ;

    py::class_<clang::EnumDecl, decl_deleter<clang::EnumDecl>::type>(m, "EnumDecl" , py::base<clang::TagDecl>())
        .def("getCanonicalDecl", []( clang::EnumDecl& self) -> clang::EnumDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::EnumDecl& self) -> const clang::EnumDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getPreviousDecl", []( clang::EnumDecl& self) -> clang::EnumDecl * {
           return  self.getPreviousDecl();
        })
        .def("getPreviousDecl", [](const clang::EnumDecl& self) -> const clang::EnumDecl * {
           return  self.getPreviousDecl();
        })
        .def("getMostRecentDecl", []( clang::EnumDecl& self) -> clang::EnumDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getMostRecentDecl", [](const clang::EnumDecl& self) -> const clang::EnumDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getDefinition", [](const clang::EnumDecl& self) -> clang::EnumDecl * {
           return  self.getDefinition();
        })
        .def("completeDefinition", []( clang::EnumDecl& self, clang::QualType NewType , clang::QualType PromotionType , unsigned int NumPositiveBits , unsigned int NumNegativeBits)  {
             self.completeDefinition(NewType, PromotionType, NumPositiveBits, NumNegativeBits);
        })
        //.def("enumerators", [](const clang::EnumDecl& self) -> llvm::iterator_range<clang::DeclContext::specific_decl_iterator<clang::EnumConstantDecl> > {
        //   return  self.enumerators();
        //})
        .def("getPromotionType", [](const clang::EnumDecl& self) -> clang::QualType {
           return  self.getPromotionType();
        })
        .def("setPromotionType", []( clang::EnumDecl& self, clang::QualType T)  {
             self.setPromotionType(T);
        })
        .def("getIntegerType", [](const clang::EnumDecl& self) -> clang::QualType {
           return  self.getIntegerType();
        })
        .def("setIntegerType", []( clang::EnumDecl& self, clang::QualType T)  {
             self.setIntegerType(T);
        })
        .def("setIntegerTypeSourceInfo", []( clang::EnumDecl& self, clang::TypeSourceInfo * TInfo)  {
             self.setIntegerTypeSourceInfo(TInfo);
        })
        .def("getIntegerTypeSourceInfo", [](const clang::EnumDecl& self) -> clang::TypeSourceInfo * {
           return  self.getIntegerTypeSourceInfo();
        })
        .def("getIntegerTypeRange", [](const clang::EnumDecl& self) -> clang::SourceRange {
           return  self.getIntegerTypeRange();
        })
        .def("getNumPositiveBits", [](const clang::EnumDecl& self) -> unsigned int {
           return  self.getNumPositiveBits();
        })
        .def("setNumPositiveBits", []( clang::EnumDecl& self, unsigned int Num)  {
             self.setNumPositiveBits(Num);
        })
        .def("getNumNegativeBits", [](const clang::EnumDecl& self) -> unsigned int {
           return  self.getNumNegativeBits();
        })
        .def("setNumNegativeBits", []( clang::EnumDecl& self, unsigned int Num)  {
             self.setNumNegativeBits(Num);
        })
        .def("isScoped", [](const clang::EnumDecl& self) -> bool {
           return  self.isScoped();
        })
        .def("isScopedUsingClassTag", [](const clang::EnumDecl& self) -> bool {
           return  self.isScopedUsingClassTag();
        })
        .def("isFixed", [](const clang::EnumDecl& self) -> bool {
           return  self.isFixed();
        })
        .def("isComplete", [](const clang::EnumDecl& self) -> bool {
           return  self.isComplete();
        })
        .def("getInstantiatedFromMemberEnum", [](const clang::EnumDecl& self) -> clang::EnumDecl * {
           return  self.getInstantiatedFromMemberEnum();
        })
        .def("getTemplateSpecializationKind", [](const clang::EnumDecl& self) -> clang::TemplateSpecializationKind {
           return  self.getTemplateSpecializationKind();
        })
        .def("setTemplateSpecializationKind", []( clang::EnumDecl& self, clang::TemplateSpecializationKind TSK , clang::SourceLocation PointOfInstantiation)  {
             self.setTemplateSpecializationKind(TSK, PointOfInstantiation);
        })
        //.def("getMemberSpecializationInfo", [](const clang::EnumDecl& self) -> clang::MemberSpecializationInfo * {
        //   return  self.getMemberSpecializationInfo();
        //})
        .def("setInstantiationOfMemberEnum", []( clang::EnumDecl& self, clang::EnumDecl * ED , clang::TemplateSpecializationKind TSK)  {
             self.setInstantiationOfMemberEnum(ED, TSK);
        })
    ;

    py::class_<clang::RecordDecl, decl_deleter<clang::RecordDecl>::type>(m, "RecordDecl" , py::base<clang::TagDecl>())
        .def("getPreviousDecl", []( clang::RecordDecl& self) -> clang::RecordDecl * {
           return  self.getPreviousDecl();
        })
        .def("getPreviousDecl", [](const clang::RecordDecl& self) -> const clang::RecordDecl * {
           return  self.getPreviousDecl();
        })
        .def("getMostRecentDecl", []( clang::RecordDecl& self) -> clang::RecordDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getMostRecentDecl", [](const clang::RecordDecl& self) -> const clang::RecordDecl * {
           return  self.getMostRecentDecl();
        })
        .def("hasFlexibleArrayMember", [](const clang::RecordDecl& self) -> bool {
           return  self.hasFlexibleArrayMember();
        })
        .def("setHasFlexibleArrayMember", []( clang::RecordDecl& self, bool V)  {
             self.setHasFlexibleArrayMember(V);
        })
        .def("isAnonymousStructOrUnion", [](const clang::RecordDecl& self) -> bool {
           return  self.isAnonymousStructOrUnion();
        })
        .def("setAnonymousStructOrUnion", []( clang::RecordDecl& self, bool Anon)  {
             self.setAnonymousStructOrUnion(Anon);
        })
        .def("hasObjectMember", [](const clang::RecordDecl& self) -> bool {
           return  self.hasObjectMember();
        })
        .def("setHasObjectMember", []( clang::RecordDecl& self, bool val)  {
             self.setHasObjectMember(val);
        })
        .def("hasVolatileMember", [](const clang::RecordDecl& self) -> bool {
           return  self.hasVolatileMember();
        })
        .def("setHasVolatileMember", []( clang::RecordDecl& self, bool val)  {
             self.setHasVolatileMember(val);
        })
        .def("hasLoadedFieldsFromExternalStorage", [](const clang::RecordDecl& self) -> bool {
           return  self.hasLoadedFieldsFromExternalStorage();
        })
        .def("setHasLoadedFieldsFromExternalStorage", []( clang::RecordDecl& self, bool val)  {
             self.setHasLoadedFieldsFromExternalStorage(val);
        })
        .def("isInjectedClassName", [](const clang::RecordDecl& self) -> bool {
           return  self.isInjectedClassName();
        })
        .def("isLambda", [](const clang::RecordDecl& self) -> bool {
           return  self.isLambda();
        })
        .def("isCapturedRecord", [](const clang::RecordDecl& self) -> bool {
           return  self.isCapturedRecord();
        })
        .def("setCapturedRecord", []( clang::RecordDecl& self)  {
             self.setCapturedRecord();
        })
        .def("getDefinition", [](const clang::RecordDecl& self) -> clang::RecordDecl * {
           return  self.getDefinition();
        })
        //.def("fields", [](const clang::RecordDecl& self) -> llvm::iterator_range<clang::DeclContext::specific_decl_iterator<clang::FieldDecl> > {
        //   return  self.fields();
        //})
        .def("field_empty", [](const clang::RecordDecl& self) -> bool {
           return  self.field_empty();
        })
        .def("completeDefinition", []( clang::RecordDecl& self)  {
             self.completeDefinition();
        })
        .def("isMsStruct", [](const clang::RecordDecl& self, const clang::ASTContext & C) -> bool {
           return  self.isMsStruct(C);
        })
        .def("mayInsertExtraPadding", [](const clang::RecordDecl& self, bool EmitRemark) -> bool {
           return  self.mayInsertExtraPadding(EmitRemark);
        })
        .def("findFirstNamedDataMember", [](const clang::RecordDecl& self) -> const clang::FieldDecl * {
           return  self.findFirstNamedDataMember();
        })
    ;

    py::class_<clang::FileScopeAsmDecl, decl_deleter<clang::FileScopeAsmDecl>::type>(m, "FileScopeAsmDecl" , py::base<clang::Decl>())
        .def("getAsmLoc", [](const clang::FileScopeAsmDecl& self) -> clang::SourceLocation {
           return  self.getAsmLoc();
        })
        .def("getRParenLoc", [](const clang::FileScopeAsmDecl& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("setRParenLoc", []( clang::FileScopeAsmDecl& self, clang::SourceLocation L)  {
             self.setRParenLoc(L);
        })
        .def("getSourceRange", [](const clang::FileScopeAsmDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getAsmString", [](const clang::FileScopeAsmDecl& self) -> const clang::StringLiteral * {
           return  self.getAsmString();
        })
        .def("getAsmString", []( clang::FileScopeAsmDecl& self) -> clang::StringLiteral * {
           return  self.getAsmString();
        })
        .def("setAsmString", []( clang::FileScopeAsmDecl& self, clang::StringLiteral * Asm)  {
             self.setAsmString(Asm);
        })
    ;

    py::class_<clang::BlockDecl, decl_deleter<clang::BlockDecl>::type>(m, "BlockDecl" , py::base<clang::Decl>())
        .def("getCaretLocation", [](const clang::BlockDecl& self) -> clang::SourceLocation {
           return  self.getCaretLocation();
        })
        .def("isVariadic", [](const clang::BlockDecl& self) -> bool {
           return  self.isVariadic();
        })
        .def("setIsVariadic", []( clang::BlockDecl& self, bool value)  {
             self.setIsVariadic(value);
        })
        .def("getCompoundBody", [](const clang::BlockDecl& self) -> clang::CompoundStmt * {
           return  self.getCompoundBody();
        })
        .def("getBody", [](const clang::BlockDecl& self) -> clang::Stmt * {
           return  self.getBody();
        })
        .def("setBody", []( clang::BlockDecl& self, clang::CompoundStmt * B)  {
             self.setBody(B);
        })
        .def("setSignatureAsWritten", []( clang::BlockDecl& self, clang::TypeSourceInfo * Sig)  {
             self.setSignatureAsWritten(Sig);
        })
        .def("getSignatureAsWritten", [](const clang::BlockDecl& self) -> clang::TypeSourceInfo * {
           return  self.getSignatureAsWritten();
        })
        .def("param_size", [](const clang::BlockDecl& self) -> unsigned int {
           return  self.param_size();
        })
        //.def("parameters", [](const clang::BlockDecl& self) -> llvm::ArrayRef<clang::ParmVarDecl *> {
        //   return  self.parameters();
        //})
        .def("param_empty", [](const clang::BlockDecl& self) -> bool {
           return  self.param_empty();
        })
        //.def("params", []( clang::BlockDecl& self) -> llvm::iterator_range<clang::ParmVarDecl **> {
        //   return  self.params();
        //})
        //.def("params", [](const clang::BlockDecl& self) -> llvm::iterator_range<clang::ParmVarDecl *const *> {
        //   return  self.params();
        //})
        .def("getNumParams", [](const clang::BlockDecl& self) -> unsigned int {
           return  self.getNumParams();
        })
        .def("getParamDecl", [](const clang::BlockDecl& self, unsigned int i) -> const clang::ParmVarDecl * {
           return  self.getParamDecl(i);
        })
        .def("getParamDecl", []( clang::BlockDecl& self, unsigned int i) -> clang::ParmVarDecl * {
           return  self.getParamDecl(i);
        })
        //.def("setParams", []( clang::BlockDecl& self, llvm::ArrayRef<clang::ParmVarDecl *> NewParamInfo)  {
        //     self.setParams(NewParamInfo);
        //})
        .def("hasCaptures", [](const clang::BlockDecl& self) -> bool {
           return  self.hasCaptures();
        })
        .def("getNumCaptures", [](const clang::BlockDecl& self) -> unsigned int {
           return  self.getNumCaptures();
        })
        //.def("captures", []( clang::BlockDecl& self) -> llvm::iterator_range<const clang::BlockDecl::Capture *> {
        //   return  self.captures();
        //})
        //.def("captures", [](const clang::BlockDecl& self) -> llvm::iterator_range<const clang::BlockDecl::Capture *> {
        //   return  self.captures();
        //})
        .def("capturesCXXThis", [](const clang::BlockDecl& self) -> bool {
           return  self.capturesCXXThis();
        })
        .def("blockMissingReturnType", [](const clang::BlockDecl& self) -> bool {
           return  self.blockMissingReturnType();
        })
        .def("setBlockMissingReturnType", []( clang::BlockDecl& self, bool val)  {
             self.setBlockMissingReturnType(val);
        })
        .def("isConversionFromLambda", [](const clang::BlockDecl& self) -> bool {
           return  self.isConversionFromLambda();
        })
        .def("setIsConversionFromLambda", []( clang::BlockDecl& self, bool val)  {
             self.setIsConversionFromLambda(val);
        })
        .def("capturesVariable", [](const clang::BlockDecl& self, const clang::VarDecl * var) -> bool {
           return  self.capturesVariable(var);
        })
        //.def("setCaptures", []( clang::BlockDecl& self, clang::ASTContext & Context , llvm::ArrayRef<clang::BlockDecl::Capture> Captures , bool CapturesCXXThis)  {
        //     self.setCaptures(Context, Captures, CapturesCXXThis);
        //})
        .def("getBlockManglingNumber", [](const clang::BlockDecl& self) -> unsigned int {
           return  self.getBlockManglingNumber();
        })
        .def("getBlockManglingContextDecl", [](const clang::BlockDecl& self) -> clang::Decl * {
           return  self.getBlockManglingContextDecl();
        })
        .def("setBlockMangling", []( clang::BlockDecl& self, unsigned int Number , clang::Decl * Ctx)  {
             self.setBlockMangling(Number, Ctx);
        })
        .def("getSourceRange", [](const clang::BlockDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
    ;

    py::class_<clang::CapturedDecl, decl_deleter<clang::CapturedDecl>::type>(m, "CapturedDecl" , py::base<clang::Decl>())
        .def("getBody", [](const clang::CapturedDecl& self) -> clang::Stmt * {
           return  self.getBody();
        })
        .def("setBody", []( clang::CapturedDecl& self, clang::Stmt * B)  {
             self.setBody(B);
        })
        .def("isNothrow", [](const clang::CapturedDecl& self) -> bool {
           return  self.isNothrow();
        })
        .def("setNothrow", []( clang::CapturedDecl& self, bool Nothrow)  {
             self.setNothrow(Nothrow);
        })
        .def("getNumParams", [](const clang::CapturedDecl& self) -> unsigned int {
           return  self.getNumParams();
        })
        .def("getParam", [](const clang::CapturedDecl& self, unsigned int i) -> clang::ImplicitParamDecl * {
           return  self.getParam(i);
        })
        .def("setParam", []( clang::CapturedDecl& self, unsigned int i , clang::ImplicitParamDecl * P)  {
             self.setParam(i, P);
        })
        .def("getContextParam", [](const clang::CapturedDecl& self) -> clang::ImplicitParamDecl * {
           return  self.getContextParam();
        })
        .def("setContextParam", []( clang::CapturedDecl& self, unsigned int i , clang::ImplicitParamDecl * P)  {
             self.setContextParam(i, P);
        })
        .def("getContextParamPosition", [](const clang::CapturedDecl& self) -> unsigned int {
           return  self.getContextParamPosition();
        })
        //.def("params", [](const clang::CapturedDecl& self) -> llvm::iterator_range<clang::ImplicitParamDecl *const *> {
        //   return  self.params();
        //})
    ;

    py::class_<clang::ImportDecl, decl_deleter<clang::ImportDecl>::type>(m, "ImportDecl" , py::base<clang::Decl>())
        //.def("getImportedModule", [](const clang::ImportDecl& self) -> clang::Module * {
        //   return  self.getImportedModule();
        //})
        //.def("getIdentifierLocs", [](const clang::ImportDecl& self) -> llvm::ArrayRef<clang::SourceLocation> {
        //   return  self.getIdentifierLocs();
        //})
        .def("getSourceRange", [](const clang::ImportDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
    ;

    py::class_<clang::EmptyDecl, decl_deleter<clang::EmptyDecl>::type>(m, "EmptyDecl" , py::base<clang::Decl>())
    ;

    py::class_<clang::Stmt, stmt_deleter<clang::Stmt>::type>(m, "Stmt" )
        .def("getStmtClass", [](const clang::Stmt& self) -> clang::Stmt::StmtClass {
           return  self.getStmtClass();
        })
        .def("getStmtClassName", [](const clang::Stmt& self) -> const char * {
           return  self.getStmtClassName();
        })
        .def("getSourceRange", [](const clang::Stmt& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getLocStart", [](const clang::Stmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::Stmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("dump", [](const clang::Stmt& self)  {
             self.dump();
        })
        .def("dump", [](const clang::Stmt& self, clang::SourceManager & SM)  {
             self.dump(SM);
        })
        //.def("dump", [](const clang::Stmt& self, llvm::raw_ostream & OS , clang::SourceManager & SM)  {
        //     self.dump(OS, SM);
        //})
        //.def("dump", [](const clang::Stmt& self, llvm::raw_ostream & OS)  {
        //     self.dump(OS);
        //})
        .def("dumpColor", [](const clang::Stmt& self)  {
             self.dumpColor();
        })
        .def("dumpPretty", [](const clang::Stmt& self, const clang::ASTContext & Context)  {
             self.dumpPretty(Context);
        })
        //.def("printPretty", [](const clang::Stmt& self, llvm::raw_ostream & OS , clang::PrinterHelper * Helper , const clang::PrintingPolicy & Policy , unsigned int Indentation)  {
        //     self.printPretty(OS, Helper, Policy, Indentation);
        //})
        .def("viewAST", [](const clang::Stmt& self)  {
             self.viewAST();
        })
        .def("IgnoreImplicit", []( clang::Stmt& self) -> clang::Stmt * {
           return  self.IgnoreImplicit();
        })
        .def("IgnoreContainers", []( clang::Stmt& self, bool IgnoreCaptured) -> clang::Stmt * {
           return  self.IgnoreContainers(IgnoreCaptured);
        })
        .def("stripLabelLikeStatements", [](const clang::Stmt& self) -> const clang::Stmt * {
           return  self.stripLabelLikeStatements();
        })
        .def("stripLabelLikeStatements", []( clang::Stmt& self) -> clang::Stmt * {
           return  self.stripLabelLikeStatements();
        })
        //.def("children", []( clang::Stmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
        //.def("children", [](const clang::Stmt& self) -> llvm::iterator_range<clang::ConstStmtIterator> {
        //   return  self.children();
        //})
        //.def("Profile", [](const clang::Stmt& self, llvm::FoldingSetNodeID & ID , const clang::ASTContext & Context , bool Canonical)  {
        //     self.Profile(ID, Context, Canonical);
        //})
    ;

    py::class_<clang::DeclStmt, stmt_deleter<clang::DeclStmt>::type>(m, "DeclStmt" , py::base<clang::Stmt>())
        .def("isSingleDecl", [](const clang::DeclStmt& self) -> bool {
           return  self.isSingleDecl();
        })
        .def("getSingleDecl", [](const clang::DeclStmt& self) -> const clang::Decl * {
           return  self.getSingleDecl();
        })
        .def("getSingleDecl", []( clang::DeclStmt& self) -> clang::Decl * {
           return  self.getSingleDecl();
        })
        //.def("getDeclGroup", [](const clang::DeclStmt& self) -> const clang::DeclGroupRef {
        //   return  self.getDeclGroup();
        //})
        //.def("getDeclGroup", []( clang::DeclStmt& self) -> clang::DeclGroupRef {
        //   return  self.getDeclGroup();
        //})
        //.def("setDeclGroup", []( clang::DeclStmt& self, clang::DeclGroupRef DGR)  {
        //     self.setDeclGroup(DGR);
        //})
        .def("getStartLoc", [](const clang::DeclStmt& self) -> clang::SourceLocation {
           return  self.getStartLoc();
        })
        .def("setStartLoc", []( clang::DeclStmt& self, clang::SourceLocation L)  {
             self.setStartLoc(L);
        })
        .def("getEndLoc", [](const clang::DeclStmt& self) -> clang::SourceLocation {
           return  self.getEndLoc();
        })
        .def("setEndLoc", []( clang::DeclStmt& self, clang::SourceLocation L)  {
             self.setEndLoc(L);
        })
        .def("getLocStart", [](const clang::DeclStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::DeclStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::DeclStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
        //.def("decls", []( clang::DeclStmt& self) -> llvm::iterator_range<clang::Decl **> {
        //   return  self.decls();
        //})
        //.def("decls", [](const clang::DeclStmt& self) -> llvm::iterator_range<clang::Decl *const *> {
        //   return  self.decls();
        //})
    ;

    py::class_<clang::NullStmt, stmt_deleter<clang::NullStmt>::type>(m, "NullStmt" , py::base<clang::Stmt>())
        .def("getSemiLoc", [](const clang::NullStmt& self) -> clang::SourceLocation {
           return  self.getSemiLoc();
        })
        .def("setSemiLoc", []( clang::NullStmt& self, clang::SourceLocation L)  {
             self.setSemiLoc(L);
        })
        .def("hasLeadingEmptyMacro", [](const clang::NullStmt& self) -> bool {
           return  self.hasLeadingEmptyMacro();
        })
        .def("getLocStart", [](const clang::NullStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::NullStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::NullStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CompoundStmt, stmt_deleter<clang::CompoundStmt>::type>(m, "CompoundStmt" , py::base<clang::Stmt>())
        //.def("setStmts", []( clang::CompoundStmt& self, const clang::ASTContext & C , llvm::ArrayRef<clang::Stmt *> Stmts)  {
        //     self.setStmts(C, Stmts);
        //})
        .def("body_empty", [](const clang::CompoundStmt& self) -> bool {
           return  self.body_empty();
        })
        .def("size", [](const clang::CompoundStmt& self) -> unsigned int {
           return  self.size();
        })
        //.def("body", []( clang::CompoundStmt& self) -> llvm::iterator_range<clang::Stmt **> {
        //   return  self.body();
        //})
        .def("body_front", []( clang::CompoundStmt& self) -> clang::Stmt * {
           return  self.body_front();
        })
        .def("body_back", []( clang::CompoundStmt& self) -> clang::Stmt * {
           return  self.body_back();
        })
        .def("setLastStmt", []( clang::CompoundStmt& self, clang::Stmt * S)  {
             self.setLastStmt(S);
        })
        //.def("body", [](const clang::CompoundStmt& self) -> llvm::iterator_range<clang::Stmt *const *> {
        //   return  self.body();
        //})
        .def("body_front", [](const clang::CompoundStmt& self) -> const clang::Stmt * {
           return  self.body_front();
        })
        .def("body_back", [](const clang::CompoundStmt& self) -> const clang::Stmt * {
           return  self.body_back();
        })
        .def("getLocStart", [](const clang::CompoundStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CompoundStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getLBracLoc", [](const clang::CompoundStmt& self) -> clang::SourceLocation {
           return  self.getLBracLoc();
        })
        .def("getRBracLoc", [](const clang::CompoundStmt& self) -> clang::SourceLocation {
           return  self.getRBracLoc();
        })
        //.def("children", []( clang::CompoundStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
        //.def("children", [](const clang::CompoundStmt& self) -> llvm::iterator_range<clang::ConstStmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::SwitchCase, stmt_deleter<clang::SwitchCase>::type>(m, "SwitchCase" , py::base<clang::Stmt>())
        .def("getNextSwitchCase", [](const clang::SwitchCase& self) -> const clang::SwitchCase * {
           return  self.getNextSwitchCase();
        })
        .def("getNextSwitchCase", []( clang::SwitchCase& self) -> clang::SwitchCase * {
           return  self.getNextSwitchCase();
        })
        .def("setNextSwitchCase", []( clang::SwitchCase& self, clang::SwitchCase * SC)  {
             self.setNextSwitchCase(SC);
        })
        .def("getKeywordLoc", [](const clang::SwitchCase& self) -> clang::SourceLocation {
           return  self.getKeywordLoc();
        })
        .def("setKeywordLoc", []( clang::SwitchCase& self, clang::SourceLocation L)  {
             self.setKeywordLoc(L);
        })
        .def("getColonLoc", [](const clang::SwitchCase& self) -> clang::SourceLocation {
           return  self.getColonLoc();
        })
        .def("setColonLoc", []( clang::SwitchCase& self, clang::SourceLocation L)  {
             self.setColonLoc(L);
        })
        .def("getSubStmt", []( clang::SwitchCase& self) -> clang::Stmt * {
           return  self.getSubStmt();
        })
        .def("getSubStmt", [](const clang::SwitchCase& self) -> const clang::Stmt * {
           return  self.getSubStmt();
        })
        .def("getLocStart", [](const clang::SwitchCase& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::SwitchCase& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
    ;

    py::class_<clang::CaseStmt, stmt_deleter<clang::CaseStmt>::type>(m, "CaseStmt" , py::base<clang::SwitchCase>())
        .def("getCaseLoc", [](const clang::CaseStmt& self) -> clang::SourceLocation {
           return  self.getCaseLoc();
        })
        .def("setCaseLoc", []( clang::CaseStmt& self, clang::SourceLocation L)  {
             self.setCaseLoc(L);
        })
        .def("getEllipsisLoc", [](const clang::CaseStmt& self) -> clang::SourceLocation {
           return  self.getEllipsisLoc();
        })
        .def("setEllipsisLoc", []( clang::CaseStmt& self, clang::SourceLocation L)  {
             self.setEllipsisLoc(L);
        })
        .def("getColonLoc", [](const clang::CaseStmt& self) -> clang::SourceLocation {
           return  self.getColonLoc();
        })
        .def("setColonLoc", []( clang::CaseStmt& self, clang::SourceLocation L)  {
             self.setColonLoc(L);
        })
        .def("getLHS", []( clang::CaseStmt& self) -> clang::Expr * {
           return  self.getLHS();
        })
        .def("getRHS", []( clang::CaseStmt& self) -> clang::Expr * {
           return  self.getRHS();
        })
        .def("getSubStmt", []( clang::CaseStmt& self) -> clang::Stmt * {
           return  self.getSubStmt();
        })
        .def("getLHS", [](const clang::CaseStmt& self) -> const clang::Expr * {
           return  self.getLHS();
        })
        .def("getRHS", [](const clang::CaseStmt& self) -> const clang::Expr * {
           return  self.getRHS();
        })
        .def("getSubStmt", [](const clang::CaseStmt& self) -> const clang::Stmt * {
           return  self.getSubStmt();
        })
        .def("setSubStmt", []( clang::CaseStmt& self, clang::Stmt * S)  {
             self.setSubStmt(S);
        })
        .def("setLHS", []( clang::CaseStmt& self, clang::Expr * Val)  {
             self.setLHS(Val);
        })
        .def("setRHS", []( clang::CaseStmt& self, clang::Expr * Val)  {
             self.setRHS(Val);
        })
        .def("getLocStart", [](const clang::CaseStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CaseStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CaseStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::DefaultStmt, stmt_deleter<clang::DefaultStmt>::type>(m, "DefaultStmt" , py::base<clang::SwitchCase>())
        .def("getSubStmt", []( clang::DefaultStmt& self) -> clang::Stmt * {
           return  self.getSubStmt();
        })
        .def("getSubStmt", [](const clang::DefaultStmt& self) -> const clang::Stmt * {
           return  self.getSubStmt();
        })
        .def("setSubStmt", []( clang::DefaultStmt& self, clang::Stmt * S)  {
             self.setSubStmt(S);
        })
        .def("getDefaultLoc", [](const clang::DefaultStmt& self) -> clang::SourceLocation {
           return  self.getDefaultLoc();
        })
        .def("setDefaultLoc", []( clang::DefaultStmt& self, clang::SourceLocation L)  {
             self.setDefaultLoc(L);
        })
        .def("getColonLoc", [](const clang::DefaultStmt& self) -> clang::SourceLocation {
           return  self.getColonLoc();
        })
        .def("setColonLoc", []( clang::DefaultStmt& self, clang::SourceLocation L)  {
             self.setColonLoc(L);
        })
        .def("getLocStart", [](const clang::DefaultStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::DefaultStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::DefaultStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::LabelStmt, stmt_deleter<clang::LabelStmt>::type>(m, "LabelStmt" , py::base<clang::Stmt>())
        .def("getIdentLoc", [](const clang::LabelStmt& self) -> clang::SourceLocation {
           return  self.getIdentLoc();
        })
        .def("getDecl", [](const clang::LabelStmt& self) -> clang::LabelDecl * {
           return  self.getDecl();
        })
        .def("setDecl", []( clang::LabelStmt& self, clang::LabelDecl * D)  {
             self.setDecl(D);
        })
        .def("getName", [](const clang::LabelStmt& self) -> const char * {
           return  self.getName();
        })
        .def("getSubStmt", []( clang::LabelStmt& self) -> clang::Stmt * {
           return  self.getSubStmt();
        })
        .def("getSubStmt", [](const clang::LabelStmt& self) -> const clang::Stmt * {
           return  self.getSubStmt();
        })
        .def("setIdentLoc", []( clang::LabelStmt& self, clang::SourceLocation L)  {
             self.setIdentLoc(L);
        })
        .def("setSubStmt", []( clang::LabelStmt& self, clang::Stmt * SS)  {
             self.setSubStmt(SS);
        })
        .def("getLocStart", [](const clang::LabelStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::LabelStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::LabelStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::AttributedStmt, stmt_deleter<clang::AttributedStmt>::type>(m, "AttributedStmt" , py::base<clang::Stmt>())
        .def("getAttrLoc", [](const clang::AttributedStmt& self) -> clang::SourceLocation {
           return  self.getAttrLoc();
        })
        //.def("getAttrs", [](const clang::AttributedStmt& self) -> llvm::ArrayRef<const clang::Attr *> {
        //   return  self.getAttrs();
        //})
        .def("getSubStmt", []( clang::AttributedStmt& self) -> clang::Stmt * {
           return  self.getSubStmt();
        })
        .def("getSubStmt", [](const clang::AttributedStmt& self) -> const clang::Stmt * {
           return  self.getSubStmt();
        })
        .def("getLocStart", [](const clang::AttributedStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::AttributedStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::AttributedStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::IfStmt, stmt_deleter<clang::IfStmt>::type>(m, "IfStmt" , py::base<clang::Stmt>())
        .def("getConditionVariable", [](const clang::IfStmt& self) -> clang::VarDecl * {
           return  self.getConditionVariable();
        })
        .def("setConditionVariable", []( clang::IfStmt& self, const clang::ASTContext & C , clang::VarDecl * V)  {
             self.setConditionVariable(C, V);
        })
        .def("getConditionVariableDeclStmt", [](const clang::IfStmt& self) -> const clang::DeclStmt * {
           return  self.getConditionVariableDeclStmt();
        })
        .def("getCond", [](const clang::IfStmt& self) -> const clang::Expr * {
           return  self.getCond();
        })
        .def("setCond", []( clang::IfStmt& self, clang::Expr * E)  {
             self.setCond(E);
        })
        .def("getThen", [](const clang::IfStmt& self) -> const clang::Stmt * {
           return  self.getThen();
        })
        .def("setThen", []( clang::IfStmt& self, clang::Stmt * S)  {
             self.setThen(S);
        })
        .def("getElse", [](const clang::IfStmt& self) -> const clang::Stmt * {
           return  self.getElse();
        })
        .def("setElse", []( clang::IfStmt& self, clang::Stmt * S)  {
             self.setElse(S);
        })
        .def("getCond", []( clang::IfStmt& self) -> clang::Expr * {
           return  self.getCond();
        })
        .def("getThen", []( clang::IfStmt& self) -> clang::Stmt * {
           return  self.getThen();
        })
        .def("getElse", []( clang::IfStmt& self) -> clang::Stmt * {
           return  self.getElse();
        })
        .def("getIfLoc", [](const clang::IfStmt& self) -> clang::SourceLocation {
           return  self.getIfLoc();
        })
        .def("setIfLoc", []( clang::IfStmt& self, clang::SourceLocation L)  {
             self.setIfLoc(L);
        })
        .def("getElseLoc", [](const clang::IfStmt& self) -> clang::SourceLocation {
           return  self.getElseLoc();
        })
        .def("setElseLoc", []( clang::IfStmt& self, clang::SourceLocation L)  {
             self.setElseLoc(L);
        })
        .def("getLocStart", [](const clang::IfStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::IfStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::IfStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::SwitchStmt, stmt_deleter<clang::SwitchStmt>::type>(m, "SwitchStmt" , py::base<clang::Stmt>())
        .def("getConditionVariable", [](const clang::SwitchStmt& self) -> clang::VarDecl * {
           return  self.getConditionVariable();
        })
        .def("setConditionVariable", []( clang::SwitchStmt& self, const clang::ASTContext & C , clang::VarDecl * V)  {
             self.setConditionVariable(C, V);
        })
        .def("getConditionVariableDeclStmt", [](const clang::SwitchStmt& self) -> const clang::DeclStmt * {
           return  self.getConditionVariableDeclStmt();
        })
        .def("getCond", [](const clang::SwitchStmt& self) -> const clang::Expr * {
           return  self.getCond();
        })
        .def("getBody", [](const clang::SwitchStmt& self) -> const clang::Stmt * {
           return  self.getBody();
        })
        .def("getSwitchCaseList", [](const clang::SwitchStmt& self) -> const clang::SwitchCase * {
           return  self.getSwitchCaseList();
        })
        .def("getCond", []( clang::SwitchStmt& self) -> clang::Expr * {
           return  self.getCond();
        })
        .def("setCond", []( clang::SwitchStmt& self, clang::Expr * E)  {
             self.setCond(E);
        })
        .def("getBody", []( clang::SwitchStmt& self) -> clang::Stmt * {
           return  self.getBody();
        })
        .def("setBody", []( clang::SwitchStmt& self, clang::Stmt * S)  {
             self.setBody(S);
        })
        .def("getSwitchCaseList", []( clang::SwitchStmt& self) -> clang::SwitchCase * {
           return  self.getSwitchCaseList();
        })
        .def("setSwitchCaseList", []( clang::SwitchStmt& self, clang::SwitchCase * SC)  {
             self.setSwitchCaseList(SC);
        })
        .def("getSwitchLoc", [](const clang::SwitchStmt& self) -> clang::SourceLocation {
           return  self.getSwitchLoc();
        })
        .def("setSwitchLoc", []( clang::SwitchStmt& self, clang::SourceLocation L)  {
             self.setSwitchLoc(L);
        })
        .def("setBody", []( clang::SwitchStmt& self, clang::Stmt * S , clang::SourceLocation SL)  {
             self.setBody(S, SL);
        })
        .def("addSwitchCase", []( clang::SwitchStmt& self, clang::SwitchCase * SC)  {
             self.addSwitchCase(SC);
        })
        .def("setAllEnumCasesCovered", []( clang::SwitchStmt& self)  {
             self.setAllEnumCasesCovered();
        })
        .def("isAllEnumCasesCovered", [](const clang::SwitchStmt& self) -> bool {
           return  self.isAllEnumCasesCovered();
        })
        .def("getLocStart", [](const clang::SwitchStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::SwitchStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::SwitchStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;
}
