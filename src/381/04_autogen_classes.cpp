
////////////////////////////////////////////////////////////////////////////////
// File autogenerated by clastgen
//
//  Changes made here will be overwritten.
////////////////////////////////////////////////////////////////////////////////
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include "internal.h"

#include <clang/AST/AST.h>
#include <clang/ASTMatchers/ASTMatchers.h>
#include <clang/ASTMatchers/ASTMatchFinder.h>


namespace py = pybind11;

void autogenerated_classes_3(pybind11::module& m)
{

    py::class_<clang::CXXConstCastExpr, stmt_deleter<clang::CXXConstCastExpr>::type>(m, "CXXConstCastExpr" , py::base<clang::CXXNamedCastExpr>())
    ;

    py::class_<clang::UserDefinedLiteral, stmt_deleter<clang::UserDefinedLiteral>::type>(m, "UserDefinedLiteral" , py::base<clang::CallExpr>())
        .def("getLiteralOperatorKind", [](const clang::UserDefinedLiteral& self) -> clang::UserDefinedLiteral::LiteralOperatorKind {
           return  self.getLiteralOperatorKind();
        })
        .def("getCookedLiteral", []( clang::UserDefinedLiteral& self) -> clang::Expr * {
           return  self.getCookedLiteral();
        })
        .def("getCookedLiteral", [](const clang::UserDefinedLiteral& self) -> const clang::Expr * {
           return  self.getCookedLiteral();
        })
        .def("getLocStart", [](const clang::UserDefinedLiteral& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::UserDefinedLiteral& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getUDSuffixLoc", [](const clang::UserDefinedLiteral& self) -> clang::SourceLocation {
           return  self.getUDSuffixLoc();
        })
        //.def("getUDSuffix", [](const clang::UserDefinedLiteral& self) -> const clang::IdentifierInfo * {
        //   return  self.getUDSuffix();
        //})
    ;

    py::class_<clang::CXXBoolLiteralExpr, stmt_deleter<clang::CXXBoolLiteralExpr>::type>(m, "CXXBoolLiteralExpr" , py::base<clang::Expr>())
        .def("getValue", [](const clang::CXXBoolLiteralExpr& self) -> bool {
           return  self.getValue();
        })
        .def("setValue", []( clang::CXXBoolLiteralExpr& self, bool V)  {
             self.setValue(V);
        })
        .def("getLocStart", [](const clang::CXXBoolLiteralExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXBoolLiteralExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getLocation", [](const clang::CXXBoolLiteralExpr& self) -> clang::SourceLocation {
           return  self.getLocation();
        })
        .def("setLocation", []( clang::CXXBoolLiteralExpr& self, clang::SourceLocation L)  {
             self.setLocation(L);
        })
        //.def("children", []( clang::CXXBoolLiteralExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXNullPtrLiteralExpr, stmt_deleter<clang::CXXNullPtrLiteralExpr>::type>(m, "CXXNullPtrLiteralExpr" , py::base<clang::Expr>())
        .def("getLocStart", [](const clang::CXXNullPtrLiteralExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXNullPtrLiteralExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getLocation", [](const clang::CXXNullPtrLiteralExpr& self) -> clang::SourceLocation {
           return  self.getLocation();
        })
        .def("setLocation", []( clang::CXXNullPtrLiteralExpr& self, clang::SourceLocation L)  {
             self.setLocation(L);
        })
        //.def("children", []( clang::CXXNullPtrLiteralExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXStdInitializerListExpr, stmt_deleter<clang::CXXStdInitializerListExpr>::type>(m, "CXXStdInitializerListExpr" , py::base<clang::Expr>())
        .def("getSubExpr", []( clang::CXXStdInitializerListExpr& self) -> clang::Expr * {
           return  self.getSubExpr();
        })
        .def("getSubExpr", [](const clang::CXXStdInitializerListExpr& self) -> const clang::Expr * {
           return  self.getSubExpr();
        })
        .def("getLocStart", [](const clang::CXXStdInitializerListExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXStdInitializerListExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getSourceRange", [](const clang::CXXStdInitializerListExpr& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        //.def("children", []( clang::CXXStdInitializerListExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXTypeidExpr, stmt_deleter<clang::CXXTypeidExpr>::type>(m, "CXXTypeidExpr" , py::base<clang::Expr>())
        .def("isPotentiallyEvaluated", [](const clang::CXXTypeidExpr& self) -> bool {
           return  self.isPotentiallyEvaluated();
        })
        .def("isTypeOperand", [](const clang::CXXTypeidExpr& self) -> bool {
           return  self.isTypeOperand();
        })
        .def("getTypeOperand", [](const clang::CXXTypeidExpr& self, clang::ASTContext & Context) -> clang::QualType {
           return  self.getTypeOperand(Context);
        })
        .def("getTypeOperandSourceInfo", [](const clang::CXXTypeidExpr& self) -> clang::TypeSourceInfo * {
           return  self.getTypeOperandSourceInfo();
        })
        .def("setTypeOperandSourceInfo", []( clang::CXXTypeidExpr& self, clang::TypeSourceInfo * TSI)  {
             self.setTypeOperandSourceInfo(TSI);
        })
        .def("getExprOperand", [](const clang::CXXTypeidExpr& self) -> clang::Expr * {
           return  self.getExprOperand();
        })
        .def("setExprOperand", []( clang::CXXTypeidExpr& self, clang::Expr * E)  {
             self.setExprOperand(E);
        })
        .def("getLocStart", [](const clang::CXXTypeidExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXTypeidExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getSourceRange", [](const clang::CXXTypeidExpr& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("setSourceRange", []( clang::CXXTypeidExpr& self, clang::SourceRange R)  {
             self.setSourceRange(R);
        })
        //.def("children", []( clang::CXXTypeidExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::MSPropertyRefExpr, stmt_deleter<clang::MSPropertyRefExpr>::type>(m, "MSPropertyRefExpr" , py::base<clang::Expr>())
        .def("getSourceRange", [](const clang::MSPropertyRefExpr& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("isImplicitAccess", [](const clang::MSPropertyRefExpr& self) -> bool {
           return  self.isImplicitAccess();
        })
        .def("getLocStart", [](const clang::MSPropertyRefExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::MSPropertyRefExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::MSPropertyRefExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
        .def("getBaseExpr", [](const clang::MSPropertyRefExpr& self) -> clang::Expr * {
           return  self.getBaseExpr();
        })
        .def("getPropertyDecl", [](const clang::MSPropertyRefExpr& self) -> clang::MSPropertyDecl * {
           return  self.getPropertyDecl();
        })
        .def("isArrow", [](const clang::MSPropertyRefExpr& self) -> bool {
           return  self.isArrow();
        })
        .def("getMemberLoc", [](const clang::MSPropertyRefExpr& self) -> clang::SourceLocation {
           return  self.getMemberLoc();
        })
        //.def("getQualifierLoc", [](const clang::MSPropertyRefExpr& self) -> clang::NestedNameSpecifierLoc {
        //   return  self.getQualifierLoc();
        //})
    ;

    py::class_<clang::MSPropertySubscriptExpr, stmt_deleter<clang::MSPropertySubscriptExpr>::type>(m, "MSPropertySubscriptExpr" , py::base<clang::Expr>())
        .def("getBase", []( clang::MSPropertySubscriptExpr& self) -> clang::Expr * {
           return  self.getBase();
        })
        .def("getBase", [](const clang::MSPropertySubscriptExpr& self) -> const clang::Expr * {
           return  self.getBase();
        })
        .def("getIdx", []( clang::MSPropertySubscriptExpr& self) -> clang::Expr * {
           return  self.getIdx();
        })
        .def("getIdx", [](const clang::MSPropertySubscriptExpr& self) -> const clang::Expr * {
           return  self.getIdx();
        })
        .def("getLocStart", [](const clang::MSPropertySubscriptExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::MSPropertySubscriptExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getRBracketLoc", [](const clang::MSPropertySubscriptExpr& self) -> clang::SourceLocation {
           return  self.getRBracketLoc();
        })
        .def("setRBracketLoc", []( clang::MSPropertySubscriptExpr& self, clang::SourceLocation L)  {
             self.setRBracketLoc(L);
        })
        .def("getExprLoc", [](const clang::MSPropertySubscriptExpr& self) -> clang::SourceLocation {
           return  self.getExprLoc();
        })
        //.def("children", []( clang::MSPropertySubscriptExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXUuidofExpr, stmt_deleter<clang::CXXUuidofExpr>::type>(m, "CXXUuidofExpr" , py::base<clang::Expr>())
        .def("isTypeOperand", [](const clang::CXXUuidofExpr& self) -> bool {
           return  self.isTypeOperand();
        })
        .def("getTypeOperand", [](const clang::CXXUuidofExpr& self, clang::ASTContext & Context) -> clang::QualType {
           return  self.getTypeOperand(Context);
        })
        .def("getTypeOperandSourceInfo", [](const clang::CXXUuidofExpr& self) -> clang::TypeSourceInfo * {
           return  self.getTypeOperandSourceInfo();
        })
        .def("setTypeOperandSourceInfo", []( clang::CXXUuidofExpr& self, clang::TypeSourceInfo * TSI)  {
             self.setTypeOperandSourceInfo(TSI);
        })
        .def("getExprOperand", [](const clang::CXXUuidofExpr& self) -> clang::Expr * {
           return  self.getExprOperand();
        })
        .def("setExprOperand", []( clang::CXXUuidofExpr& self, clang::Expr * E)  {
             self.setExprOperand(E);
        })
        .def("getUuidAsStringRef", [](const clang::CXXUuidofExpr& self, clang::ASTContext & Context) -> llvm::StringRef {
           return  self.getUuidAsStringRef(Context);
        })
        .def("getLocStart", [](const clang::CXXUuidofExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXUuidofExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getSourceRange", [](const clang::CXXUuidofExpr& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("setSourceRange", []( clang::CXXUuidofExpr& self, clang::SourceRange R)  {
             self.setSourceRange(R);
        })
        //.def("children", []( clang::CXXUuidofExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXThisExpr, stmt_deleter<clang::CXXThisExpr>::type>(m, "CXXThisExpr" , py::base<clang::Expr>())
        .def("getLocation", [](const clang::CXXThisExpr& self) -> clang::SourceLocation {
           return  self.getLocation();
        })
        .def("setLocation", []( clang::CXXThisExpr& self, clang::SourceLocation L)  {
             self.setLocation(L);
        })
        .def("getLocStart", [](const clang::CXXThisExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXThisExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("isImplicit", [](const clang::CXXThisExpr& self) -> bool {
           return  self.isImplicit();
        })
        .def("setImplicit", []( clang::CXXThisExpr& self, bool I)  {
             self.setImplicit(I);
        })
        //.def("children", []( clang::CXXThisExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXThrowExpr, stmt_deleter<clang::CXXThrowExpr>::type>(m, "CXXThrowExpr" , py::base<clang::Expr>())
        .def("getSubExpr", [](const clang::CXXThrowExpr& self) -> const clang::Expr * {
           return  self.getSubExpr();
        })
        .def("getSubExpr", []( clang::CXXThrowExpr& self) -> clang::Expr * {
           return  self.getSubExpr();
        })
        .def("getThrowLoc", [](const clang::CXXThrowExpr& self) -> clang::SourceLocation {
           return  self.getThrowLoc();
        })
        .def("isThrownVariableInScope", [](const clang::CXXThrowExpr& self) -> bool {
           return  self.isThrownVariableInScope();
        })
        .def("getLocStart", [](const clang::CXXThrowExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXThrowExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CXXThrowExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXDefaultArgExpr, stmt_deleter<clang::CXXDefaultArgExpr>::type>(m, "CXXDefaultArgExpr" , py::base<clang::Expr>())
        .def("getParam", [](const clang::CXXDefaultArgExpr& self) -> const clang::ParmVarDecl * {
           return  self.getParam();
        })
        .def("getParam", []( clang::CXXDefaultArgExpr& self) -> clang::ParmVarDecl * {
           return  self.getParam();
        })
        .def("getExpr", [](const clang::CXXDefaultArgExpr& self) -> const clang::Expr * {
           return  self.getExpr();
        })
        .def("getExpr", []( clang::CXXDefaultArgExpr& self) -> clang::Expr * {
           return  self.getExpr();
        })
        .def("getUsedLocation", [](const clang::CXXDefaultArgExpr& self) -> clang::SourceLocation {
           return  self.getUsedLocation();
        })
        .def("getLocStart", [](const clang::CXXDefaultArgExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXDefaultArgExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getExprLoc", [](const clang::CXXDefaultArgExpr& self) -> clang::SourceLocation {
           return  self.getExprLoc();
        })
        //.def("children", []( clang::CXXDefaultArgExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXDefaultInitExpr, stmt_deleter<clang::CXXDefaultInitExpr>::type>(m, "CXXDefaultInitExpr" , py::base<clang::Expr>())
        .def("getField", []( clang::CXXDefaultInitExpr& self) -> clang::FieldDecl * {
           return  self.getField();
        })
        .def("getField", [](const clang::CXXDefaultInitExpr& self) -> const clang::FieldDecl * {
           return  self.getField();
        })
        .def("getExpr", [](const clang::CXXDefaultInitExpr& self) -> const clang::Expr * {
           return  self.getExpr();
        })
        .def("getExpr", []( clang::CXXDefaultInitExpr& self) -> clang::Expr * {
           return  self.getExpr();
        })
        .def("getLocStart", [](const clang::CXXDefaultInitExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXDefaultInitExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CXXDefaultInitExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXBindTemporaryExpr, stmt_deleter<clang::CXXBindTemporaryExpr>::type>(m, "CXXBindTemporaryExpr" , py::base<clang::Expr>())
        //.def("getTemporary", []( clang::CXXBindTemporaryExpr& self) -> clang::CXXTemporary * {
        //   return  self.getTemporary();
        //})
        //.def("getTemporary", [](const clang::CXXBindTemporaryExpr& self) -> const clang::CXXTemporary * {
        //   return  self.getTemporary();
        //})
        //.def("setTemporary", []( clang::CXXBindTemporaryExpr& self, clang::CXXTemporary * T)  {
        //     self.setTemporary(T);
        //})
        .def("getSubExpr", [](const clang::CXXBindTemporaryExpr& self) -> const clang::Expr * {
           return  self.getSubExpr();
        })
        .def("getSubExpr", []( clang::CXXBindTemporaryExpr& self) -> clang::Expr * {
           return  self.getSubExpr();
        })
        .def("setSubExpr", []( clang::CXXBindTemporaryExpr& self, clang::Expr * E)  {
             self.setSubExpr(E);
        })
        .def("getLocStart", [](const clang::CXXBindTemporaryExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXBindTemporaryExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CXXBindTemporaryExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXConstructExpr, stmt_deleter<clang::CXXConstructExpr>::type>(m, "CXXConstructExpr" , py::base<clang::Expr>())
        .def("getConstructor", [](const clang::CXXConstructExpr& self) -> clang::CXXConstructorDecl * {
           return  self.getConstructor();
        })
        .def("setConstructor", []( clang::CXXConstructExpr& self, clang::CXXConstructorDecl * C)  {
             self.setConstructor(C);
        })
        .def("getLocation", [](const clang::CXXConstructExpr& self) -> clang::SourceLocation {
           return  self.getLocation();
        })
        .def("setLocation", []( clang::CXXConstructExpr& self, clang::SourceLocation Loc)  {
             self.setLocation(Loc);
        })
        .def("isElidable", [](const clang::CXXConstructExpr& self) -> bool {
           return  self.isElidable();
        })
        .def("setElidable", []( clang::CXXConstructExpr& self, bool E)  {
             self.setElidable(E);
        })
        .def("hadMultipleCandidates", [](const clang::CXXConstructExpr& self) -> bool {
           return  self.hadMultipleCandidates();
        })
        .def("setHadMultipleCandidates", []( clang::CXXConstructExpr& self, bool V)  {
             self.setHadMultipleCandidates(V);
        })
        .def("isListInitialization", [](const clang::CXXConstructExpr& self) -> bool {
           return  self.isListInitialization();
        })
        .def("setListInitialization", []( clang::CXXConstructExpr& self, bool V)  {
             self.setListInitialization(V);
        })
        .def("isStdInitListInitialization", [](const clang::CXXConstructExpr& self) -> bool {
           return  self.isStdInitListInitialization();
        })
        .def("setStdInitListInitialization", []( clang::CXXConstructExpr& self, bool V)  {
             self.setStdInitListInitialization(V);
        })
        .def("requiresZeroInitialization", [](const clang::CXXConstructExpr& self) -> bool {
           return  self.requiresZeroInitialization();
        })
        .def("setRequiresZeroInitialization", []( clang::CXXConstructExpr& self, bool ZeroInit)  {
             self.setRequiresZeroInitialization(ZeroInit);
        })
        .def("getConstructionKind", [](const clang::CXXConstructExpr& self) -> clang::CXXConstructExpr::ConstructionKind {
           return  self.getConstructionKind();
        })
        .def("setConstructionKind", []( clang::CXXConstructExpr& self, clang::CXXConstructExpr::ConstructionKind CK)  {
             self.setConstructionKind(CK);
        })
        //.def("arguments", []( clang::CXXConstructExpr& self) -> llvm::iterator_range<clang::Stmt::ExprIterator> {
        //   return  self.arguments();
        //})
        //.def("arguments", [](const clang::CXXConstructExpr& self) -> llvm::iterator_range<clang::Stmt::ConstExprIterator> {
        //   return  self.arguments();
        //})
        .def("getNumArgs", [](const clang::CXXConstructExpr& self) -> unsigned int {
           return  self.getNumArgs();
        })
        .def("getArg", []( clang::CXXConstructExpr& self, unsigned int Arg) -> clang::Expr * {
           return  self.getArg(Arg);
        })
        .def("getArg", [](const clang::CXXConstructExpr& self, unsigned int Arg) -> const clang::Expr * {
           return  self.getArg(Arg);
        })
        .def("setArg", []( clang::CXXConstructExpr& self, unsigned int Arg , clang::Expr * ArgExpr)  {
             self.setArg(Arg, ArgExpr);
        })
        .def("getLocStart", [](const clang::CXXConstructExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXConstructExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getParenOrBraceRange", [](const clang::CXXConstructExpr& self) -> clang::SourceRange {
           return  self.getParenOrBraceRange();
        })
        .def("setParenOrBraceRange", []( clang::CXXConstructExpr& self, clang::SourceRange Range)  {
             self.setParenOrBraceRange(Range);
        })
        //.def("children", []( clang::CXXConstructExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXFunctionalCastExpr, stmt_deleter<clang::CXXFunctionalCastExpr>::type>(m, "CXXFunctionalCastExpr" , py::base<clang::ExplicitCastExpr>())
        .def("getLParenLoc", [](const clang::CXXFunctionalCastExpr& self) -> clang::SourceLocation {
           return  self.getLParenLoc();
        })
        .def("setLParenLoc", []( clang::CXXFunctionalCastExpr& self, clang::SourceLocation L)  {
             self.setLParenLoc(L);
        })
        .def("getRParenLoc", [](const clang::CXXFunctionalCastExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("setRParenLoc", []( clang::CXXFunctionalCastExpr& self, clang::SourceLocation L)  {
             self.setRParenLoc(L);
        })
        .def("getLocStart", [](const clang::CXXFunctionalCastExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXFunctionalCastExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
    ;

    py::class_<clang::CXXTemporaryObjectExpr, stmt_deleter<clang::CXXTemporaryObjectExpr>::type>(m, "CXXTemporaryObjectExpr" , py::base<clang::CXXConstructExpr>())
        .def("getTypeSourceInfo", [](const clang::CXXTemporaryObjectExpr& self) -> clang::TypeSourceInfo * {
           return  self.getTypeSourceInfo();
        })
        .def("getLocStart", [](const clang::CXXTemporaryObjectExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXTemporaryObjectExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
    ;

    py::class_<clang::LambdaExpr, stmt_deleter<clang::LambdaExpr>::type>(m, "LambdaExpr" , py::base<clang::Expr>())
        .def("getCaptureDefault", [](const clang::LambdaExpr& self) -> clang::LambdaCaptureDefault {
           return  self.getCaptureDefault();
        })
        .def("getCaptureDefaultLoc", [](const clang::LambdaExpr& self) -> clang::SourceLocation {
           return  self.getCaptureDefaultLoc();
        })
        //.def("isInitCapture", [](const clang::LambdaExpr& self, const clang::LambdaCapture * Capture) -> bool {
        //   return  self.isInitCapture(Capture);
        //})
        //.def("captures", [](const clang::LambdaExpr& self) -> llvm::iterator_range<const clang::LambdaCapture *> {
        //   return  self.captures();
        //})
        .def("capture_size", [](const clang::LambdaExpr& self) -> unsigned int {
           return  self.capture_size();
        })
        //.def("explicit_captures", [](const clang::LambdaExpr& self) -> llvm::iterator_range<const clang::LambdaCapture *> {
        //   return  self.explicit_captures();
        //})
        //.def("implicit_captures", [](const clang::LambdaExpr& self) -> llvm::iterator_range<const clang::LambdaCapture *> {
        //   return  self.implicit_captures();
        //})
        //.def("capture_inits", []( clang::LambdaExpr& self) -> llvm::iterator_range<clang::Expr **> {
        //   return  self.capture_inits();
        //})
        //.def("capture_inits", [](const clang::LambdaExpr& self) -> llvm::iterator_range<clang::Expr *const *> {
        //   return  self.capture_inits();
        //})
        //.def("getCaptureInitIndexVars", [](const clang::LambdaExpr& self, clang::Expr *const * Iter) -> llvm::ArrayRef<clang::VarDecl *> {
        //   return  self.getCaptureInitIndexVars(Iter);
        //})
        .def("getIntroducerRange", [](const clang::LambdaExpr& self) -> clang::SourceRange {
           return  self.getIntroducerRange();
        })
        .def("getLambdaClass", [](const clang::LambdaExpr& self) -> clang::CXXRecordDecl * {
           return  self.getLambdaClass();
        })
        .def("getCallOperator", [](const clang::LambdaExpr& self) -> clang::CXXMethodDecl * {
           return  self.getCallOperator();
        })
        //.def("getTemplateParameterList", [](const clang::LambdaExpr& self) -> clang::TemplateParameterList * {
        //   return  self.getTemplateParameterList();
        //})
        .def("isGenericLambda", [](const clang::LambdaExpr& self) -> bool {
           return  self.isGenericLambda();
        })
        .def("getBody", [](const clang::LambdaExpr& self) -> clang::CompoundStmt * {
           return  self.getBody();
        })
        .def("isMutable", [](const clang::LambdaExpr& self) -> bool {
           return  self.isMutable();
        })
        .def("hasExplicitParameters", [](const clang::LambdaExpr& self) -> bool {
           return  self.hasExplicitParameters();
        })
        .def("hasExplicitResultType", [](const clang::LambdaExpr& self) -> bool {
           return  self.hasExplicitResultType();
        })
        .def("getLocStart", [](const clang::LambdaExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::LambdaExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::LambdaExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXScalarValueInitExpr, stmt_deleter<clang::CXXScalarValueInitExpr>::type>(m, "CXXScalarValueInitExpr" , py::base<clang::Expr>())
        .def("getTypeSourceInfo", [](const clang::CXXScalarValueInitExpr& self) -> clang::TypeSourceInfo * {
           return  self.getTypeSourceInfo();
        })
        .def("getRParenLoc", [](const clang::CXXScalarValueInitExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("getLocStart", [](const clang::CXXScalarValueInitExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXScalarValueInitExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CXXScalarValueInitExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXNewExpr, stmt_deleter<clang::CXXNewExpr>::type>(m, "CXXNewExpr" , py::base<clang::Expr>())
        .def("AllocateArgsArray", []( clang::CXXNewExpr& self, const clang::ASTContext & C , bool isArray , unsigned int numPlaceArgs , bool hasInitializer)  {
             self.AllocateArgsArray(C, isArray, numPlaceArgs, hasInitializer);
        })
        .def("getAllocatedType", [](const clang::CXXNewExpr& self) -> clang::QualType {
           return  self.getAllocatedType();
        })
        .def("getAllocatedTypeSourceInfo", [](const clang::CXXNewExpr& self) -> clang::TypeSourceInfo * {
           return  self.getAllocatedTypeSourceInfo();
        })
        .def("shouldNullCheckAllocation", [](const clang::CXXNewExpr& self, const clang::ASTContext & Ctx) -> bool {
           return  self.shouldNullCheckAllocation(Ctx);
        })
        .def("getOperatorNew", [](const clang::CXXNewExpr& self) -> clang::FunctionDecl * {
           return  self.getOperatorNew();
        })
        .def("setOperatorNew", []( clang::CXXNewExpr& self, clang::FunctionDecl * D)  {
             self.setOperatorNew(D);
        })
        .def("getOperatorDelete", [](const clang::CXXNewExpr& self) -> clang::FunctionDecl * {
           return  self.getOperatorDelete();
        })
        .def("setOperatorDelete", []( clang::CXXNewExpr& self, clang::FunctionDecl * D)  {
             self.setOperatorDelete(D);
        })
        .def("isArray", [](const clang::CXXNewExpr& self) -> bool {
           return  self.isArray();
        })
        .def("getArraySize", []( clang::CXXNewExpr& self) -> clang::Expr * {
           return  self.getArraySize();
        })
        .def("getArraySize", [](const clang::CXXNewExpr& self) -> const clang::Expr * {
           return  self.getArraySize();
        })
        .def("getNumPlacementArgs", [](const clang::CXXNewExpr& self) -> unsigned int {
           return  self.getNumPlacementArgs();
        })
        .def("getPlacementArg", []( clang::CXXNewExpr& self, unsigned int i) -> clang::Expr * {
           return  self.getPlacementArg(i);
        })
        .def("getPlacementArg", [](const clang::CXXNewExpr& self, unsigned int i) -> const clang::Expr * {
           return  self.getPlacementArg(i);
        })
        .def("isParenTypeId", [](const clang::CXXNewExpr& self) -> bool {
           return  self.isParenTypeId();
        })
        .def("getTypeIdParens", [](const clang::CXXNewExpr& self) -> clang::SourceRange {
           return  self.getTypeIdParens();
        })
        .def("isGlobalNew", [](const clang::CXXNewExpr& self) -> bool {
           return  self.isGlobalNew();
        })
        .def("hasInitializer", [](const clang::CXXNewExpr& self) -> bool {
           return  self.hasInitializer();
        })
        .def("getInitializationStyle", [](const clang::CXXNewExpr& self) -> clang::CXXNewExpr::InitializationStyle {
           return  self.getInitializationStyle();
        })
        .def("getInitializer", []( clang::CXXNewExpr& self) -> clang::Expr * {
           return  self.getInitializer();
        })
        .def("getInitializer", [](const clang::CXXNewExpr& self) -> const clang::Expr * {
           return  self.getInitializer();
        })
        .def("getConstructExpr", [](const clang::CXXNewExpr& self) -> const clang::CXXConstructExpr * {
           return  self.getConstructExpr();
        })
        .def("doesUsualArrayDeleteWantSize", [](const clang::CXXNewExpr& self) -> bool {
           return  self.doesUsualArrayDeleteWantSize();
        })
        //.def("placement_arguments", []( clang::CXXNewExpr& self) -> llvm::iterator_range<clang::Stmt::ExprIterator> {
        //   return  self.placement_arguments();
        //})
        //.def("placement_arguments", [](const clang::CXXNewExpr& self) -> llvm::iterator_range<clang::Stmt::ConstExprIterator> {
        //   return  self.placement_arguments();
        //})
        .def("getStartLoc", [](const clang::CXXNewExpr& self) -> clang::SourceLocation {
           return  self.getStartLoc();
        })
        .def("getEndLoc", [](const clang::CXXNewExpr& self) -> clang::SourceLocation {
           return  self.getEndLoc();
        })
        .def("getDirectInitRange", [](const clang::CXXNewExpr& self) -> clang::SourceRange {
           return  self.getDirectInitRange();
        })
        .def("getSourceRange", [](const clang::CXXNewExpr& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getLocStart", [](const clang::CXXNewExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXNewExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CXXNewExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXDeleteExpr, stmt_deleter<clang::CXXDeleteExpr>::type>(m, "CXXDeleteExpr" , py::base<clang::Expr>())
        .def("isGlobalDelete", [](const clang::CXXDeleteExpr& self) -> bool {
           return  self.isGlobalDelete();
        })
        .def("isArrayForm", [](const clang::CXXDeleteExpr& self) -> bool {
           return  self.isArrayForm();
        })
        .def("isArrayFormAsWritten", [](const clang::CXXDeleteExpr& self) -> bool {
           return  self.isArrayFormAsWritten();
        })
        .def("doesUsualArrayDeleteWantSize", [](const clang::CXXDeleteExpr& self) -> bool {
           return  self.doesUsualArrayDeleteWantSize();
        })
        .def("getOperatorDelete", [](const clang::CXXDeleteExpr& self) -> clang::FunctionDecl * {
           return  self.getOperatorDelete();
        })
        .def("getArgument", []( clang::CXXDeleteExpr& self) -> clang::Expr * {
           return  self.getArgument();
        })
        .def("getArgument", [](const clang::CXXDeleteExpr& self) -> const clang::Expr * {
           return  self.getArgument();
        })
        .def("getDestroyedType", [](const clang::CXXDeleteExpr& self) -> clang::QualType {
           return  self.getDestroyedType();
        })
        .def("getLocStart", [](const clang::CXXDeleteExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXDeleteExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CXXDeleteExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXPseudoDestructorExpr, stmt_deleter<clang::CXXPseudoDestructorExpr>::type>(m, "CXXPseudoDestructorExpr" , py::base<clang::Expr>())
        .def("getBase", [](const clang::CXXPseudoDestructorExpr& self) -> clang::Expr * {
           return  self.getBase();
        })
        .def("hasQualifier", [](const clang::CXXPseudoDestructorExpr& self) -> bool {
           return  self.hasQualifier();
        })
        //.def("getQualifierLoc", [](const clang::CXXPseudoDestructorExpr& self) -> clang::NestedNameSpecifierLoc {
        //   return  self.getQualifierLoc();
        //})
        //.def("getQualifier", [](const clang::CXXPseudoDestructorExpr& self) -> clang::NestedNameSpecifier * {
        //   return  self.getQualifier();
        //})
        .def("isArrow", [](const clang::CXXPseudoDestructorExpr& self) -> bool {
           return  self.isArrow();
        })
        .def("getOperatorLoc", [](const clang::CXXPseudoDestructorExpr& self) -> clang::SourceLocation {
           return  self.getOperatorLoc();
        })
        .def("getScopeTypeInfo", [](const clang::CXXPseudoDestructorExpr& self) -> clang::TypeSourceInfo * {
           return  self.getScopeTypeInfo();
        })
        .def("getColonColonLoc", [](const clang::CXXPseudoDestructorExpr& self) -> clang::SourceLocation {
           return  self.getColonColonLoc();
        })
        .def("getTildeLoc", [](const clang::CXXPseudoDestructorExpr& self) -> clang::SourceLocation {
           return  self.getTildeLoc();
        })
        .def("getDestroyedTypeInfo", [](const clang::CXXPseudoDestructorExpr& self) -> clang::TypeSourceInfo * {
           return  self.getDestroyedTypeInfo();
        })
        //.def("getDestroyedTypeIdentifier", [](const clang::CXXPseudoDestructorExpr& self) -> clang::IdentifierInfo * {
        //   return  self.getDestroyedTypeIdentifier();
        //})
        .def("getDestroyedType", [](const clang::CXXPseudoDestructorExpr& self) -> clang::QualType {
           return  self.getDestroyedType();
        })
        .def("getDestroyedTypeLoc", [](const clang::CXXPseudoDestructorExpr& self) -> clang::SourceLocation {
           return  self.getDestroyedTypeLoc();
        })
        //.def("setDestroyedType", []( clang::CXXPseudoDestructorExpr& self, clang::IdentifierInfo * II , clang::SourceLocation Loc)  {
        //     self.setDestroyedType(II, Loc);
        //})
        .def("setDestroyedType", []( clang::CXXPseudoDestructorExpr& self, clang::TypeSourceInfo * Info)  {
             self.setDestroyedType(Info);
        })
        .def("getLocStart", [](const clang::CXXPseudoDestructorExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXPseudoDestructorExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CXXPseudoDestructorExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::TypeTraitExpr, stmt_deleter<clang::TypeTraitExpr>::type>(m, "TypeTraitExpr" , py::base<clang::Expr>())
        .def("getTrait", [](const clang::TypeTraitExpr& self) -> clang::TypeTrait {
           return  self.getTrait();
        })
        .def("getValue", [](const clang::TypeTraitExpr& self) -> bool {
           return  self.getValue();
        })
        .def("getNumArgs", [](const clang::TypeTraitExpr& self) -> unsigned int {
           return  self.getNumArgs();
        })
        .def("getArg", [](const clang::TypeTraitExpr& self, unsigned int I) -> clang::TypeSourceInfo * {
           return  self.getArg(I);
        })
        //.def("getArgs", [](const clang::TypeTraitExpr& self) -> llvm::ArrayRef<clang::TypeSourceInfo *> {
        //   return  self.getArgs();
        //})
        .def("getLocStart", [](const clang::TypeTraitExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::TypeTraitExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::TypeTraitExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ArrayTypeTraitExpr, stmt_deleter<clang::ArrayTypeTraitExpr>::type>(m, "ArrayTypeTraitExpr" , py::base<clang::Expr>())
        .def("getLocStart", [](const clang::ArrayTypeTraitExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ArrayTypeTraitExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getTrait", [](const clang::ArrayTypeTraitExpr& self) -> clang::ArrayTypeTrait {
           return  self.getTrait();
        })
        .def("getQueriedType", [](const clang::ArrayTypeTraitExpr& self) -> clang::QualType {
           return  self.getQueriedType();
        })
        .def("getQueriedTypeSourceInfo", [](const clang::ArrayTypeTraitExpr& self) -> clang::TypeSourceInfo * {
           return  self.getQueriedTypeSourceInfo();
        })
        .def("getValue", [](const clang::ArrayTypeTraitExpr& self) -> unsigned long {
           return  self.getValue();
        })
        .def("getDimensionExpression", [](const clang::ArrayTypeTraitExpr& self) -> clang::Expr * {
           return  self.getDimensionExpression();
        })
        //.def("children", []( clang::ArrayTypeTraitExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ExpressionTraitExpr, stmt_deleter<clang::ExpressionTraitExpr>::type>(m, "ExpressionTraitExpr" , py::base<clang::Expr>())
        .def("getLocStart", [](const clang::ExpressionTraitExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ExpressionTraitExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getTrait", [](const clang::ExpressionTraitExpr& self) -> clang::ExpressionTrait {
           return  self.getTrait();
        })
        .def("getQueriedExpression", [](const clang::ExpressionTraitExpr& self) -> clang::Expr * {
           return  self.getQueriedExpression();
        })
        .def("getValue", [](const clang::ExpressionTraitExpr& self) -> bool {
           return  self.getValue();
        })
        //.def("children", []( clang::ExpressionTraitExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::OverloadExpr, stmt_deleter<clang::OverloadExpr>::type>(m, "OverloadExpr" , py::base<clang::Expr>())
        .def("getNamingClass", [](const clang::OverloadExpr& self) -> clang::CXXRecordDecl * {
           return  self.getNamingClass();
        })
        //.def("decls", [](const clang::OverloadExpr& self) -> llvm::iterator_range<clang::UnresolvedSetIterator> {
        //   return  self.decls();
        //})
        .def("getNumDecls", [](const clang::OverloadExpr& self) -> unsigned int {
           return  self.getNumDecls();
        })
        .def("getNameInfo", [](const clang::OverloadExpr& self) -> const clang::DeclarationNameInfo & {
           return  self.getNameInfo();
        })
        .def("getName", [](const clang::OverloadExpr& self) -> clang::DeclarationName {
           return  self.getName();
        })
        .def("getNameLoc", [](const clang::OverloadExpr& self) -> clang::SourceLocation {
           return  self.getNameLoc();
        })
        //.def("getQualifier", [](const clang::OverloadExpr& self) -> clang::NestedNameSpecifier * {
        //   return  self.getQualifier();
        //})
        //.def("getQualifierLoc", [](const clang::OverloadExpr& self) -> clang::NestedNameSpecifierLoc {
        //   return  self.getQualifierLoc();
        //})
        .def("getTemplateKeywordLoc", [](const clang::OverloadExpr& self) -> clang::SourceLocation {
           return  self.getTemplateKeywordLoc();
        })
        .def("getLAngleLoc", [](const clang::OverloadExpr& self) -> clang::SourceLocation {
           return  self.getLAngleLoc();
        })
        .def("getRAngleLoc", [](const clang::OverloadExpr& self) -> clang::SourceLocation {
           return  self.getRAngleLoc();
        })
        .def("hasTemplateKeyword", [](const clang::OverloadExpr& self) -> bool {
           return  self.hasTemplateKeyword();
        })
        .def("hasExplicitTemplateArgs", [](const clang::OverloadExpr& self) -> bool {
           return  self.hasExplicitTemplateArgs();
        })
        //.def("getTemplateArgs", [](const clang::OverloadExpr& self) -> const clang::TemplateArgumentLoc * {
        //   return  self.getTemplateArgs();
        //})
        .def("getNumTemplateArgs", [](const clang::OverloadExpr& self) -> unsigned int {
           return  self.getNumTemplateArgs();
        })
        //.def("copyTemplateArgumentsInto", [](const clang::OverloadExpr& self, clang::TemplateArgumentListInfo & List)  {
        //     self.copyTemplateArgumentsInto(List);
        //})
    ;

    py::class_<clang::UnresolvedLookupExpr, stmt_deleter<clang::UnresolvedLookupExpr>::type>(m, "UnresolvedLookupExpr" , py::base<clang::OverloadExpr>())
        .def("requiresADL", [](const clang::UnresolvedLookupExpr& self) -> bool {
           return  self.requiresADL();
        })
        .def("isOverloaded", [](const clang::UnresolvedLookupExpr& self) -> bool {
           return  self.isOverloaded();
        })
        .def("getNamingClass", [](const clang::UnresolvedLookupExpr& self) -> clang::CXXRecordDecl * {
           return  self.getNamingClass();
        })
        .def("getLocStart", [](const clang::UnresolvedLookupExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::UnresolvedLookupExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::UnresolvedLookupExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::DependentScopeDeclRefExpr, stmt_deleter<clang::DependentScopeDeclRefExpr>::type>(m, "DependentScopeDeclRefExpr" , py::base<clang::Expr>())
        .def("getNameInfo", [](const clang::DependentScopeDeclRefExpr& self) -> const clang::DeclarationNameInfo & {
           return  self.getNameInfo();
        })
        .def("getDeclName", [](const clang::DependentScopeDeclRefExpr& self) -> clang::DeclarationName {
           return  self.getDeclName();
        })
        .def("getLocation", [](const clang::DependentScopeDeclRefExpr& self) -> clang::SourceLocation {
           return  self.getLocation();
        })
        //.def("getQualifierLoc", [](const clang::DependentScopeDeclRefExpr& self) -> clang::NestedNameSpecifierLoc {
        //   return  self.getQualifierLoc();
        //})
        //.def("getQualifier", [](const clang::DependentScopeDeclRefExpr& self) -> clang::NestedNameSpecifier * {
        //   return  self.getQualifier();
        //})
        .def("getTemplateKeywordLoc", [](const clang::DependentScopeDeclRefExpr& self) -> clang::SourceLocation {
           return  self.getTemplateKeywordLoc();
        })
        .def("getLAngleLoc", [](const clang::DependentScopeDeclRefExpr& self) -> clang::SourceLocation {
           return  self.getLAngleLoc();
        })
        .def("getRAngleLoc", [](const clang::DependentScopeDeclRefExpr& self) -> clang::SourceLocation {
           return  self.getRAngleLoc();
        })
        .def("hasTemplateKeyword", [](const clang::DependentScopeDeclRefExpr& self) -> bool {
           return  self.hasTemplateKeyword();
        })
        .def("hasExplicitTemplateArgs", [](const clang::DependentScopeDeclRefExpr& self) -> bool {
           return  self.hasExplicitTemplateArgs();
        })
        //.def("copyTemplateArgumentsInto", [](const clang::DependentScopeDeclRefExpr& self, clang::TemplateArgumentListInfo & List)  {
        //     self.copyTemplateArgumentsInto(List);
        //})
        //.def("getTemplateArgs", [](const clang::DependentScopeDeclRefExpr& self) -> const clang::TemplateArgumentLoc * {
        //   return  self.getTemplateArgs();
        //})
        .def("getNumTemplateArgs", [](const clang::DependentScopeDeclRefExpr& self) -> unsigned int {
           return  self.getNumTemplateArgs();
        })
        .def("getLocStart", [](const clang::DependentScopeDeclRefExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::DependentScopeDeclRefExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::DependentScopeDeclRefExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ExprWithCleanups, stmt_deleter<clang::ExprWithCleanups>::type>(m, "ExprWithCleanups" , py::base<clang::Expr>())
        //.def("getObjects", [](const clang::ExprWithCleanups& self) -> llvm::ArrayRef<clang::BlockDecl *> {
        //   return  self.getObjects();
        //})
        .def("getNumObjects", [](const clang::ExprWithCleanups& self) -> unsigned int {
           return  self.getNumObjects();
        })
        .def("getObject", [](const clang::ExprWithCleanups& self, unsigned int i) -> clang::BlockDecl * {
           return  self.getObject(i);
        })
        .def("getSubExpr", []( clang::ExprWithCleanups& self) -> clang::Expr * {
           return  self.getSubExpr();
        })
        .def("getSubExpr", [](const clang::ExprWithCleanups& self) -> const clang::Expr * {
           return  self.getSubExpr();
        })
        .def("setSubExpr", []( clang::ExprWithCleanups& self, clang::Expr * E)  {
             self.setSubExpr(E);
        })
        .def("getLocStart", [](const clang::ExprWithCleanups& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ExprWithCleanups& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::ExprWithCleanups& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXUnresolvedConstructExpr, stmt_deleter<clang::CXXUnresolvedConstructExpr>::type>(m, "CXXUnresolvedConstructExpr" , py::base<clang::Expr>())
        .def("getTypeAsWritten", [](const clang::CXXUnresolvedConstructExpr& self) -> clang::QualType {
           return  self.getTypeAsWritten();
        })
        .def("getTypeSourceInfo", [](const clang::CXXUnresolvedConstructExpr& self) -> clang::TypeSourceInfo * {
           return  self.getTypeSourceInfo();
        })
        .def("getLParenLoc", [](const clang::CXXUnresolvedConstructExpr& self) -> clang::SourceLocation {
           return  self.getLParenLoc();
        })
        .def("setLParenLoc", []( clang::CXXUnresolvedConstructExpr& self, clang::SourceLocation L)  {
             self.setLParenLoc(L);
        })
        .def("getRParenLoc", [](const clang::CXXUnresolvedConstructExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("setRParenLoc", []( clang::CXXUnresolvedConstructExpr& self, clang::SourceLocation L)  {
             self.setRParenLoc(L);
        })
        .def("arg_size", [](const clang::CXXUnresolvedConstructExpr& self) -> unsigned int {
           return  self.arg_size();
        })
        .def("getArg", []( clang::CXXUnresolvedConstructExpr& self, unsigned int I) -> clang::Expr * {
           return  self.getArg(I);
        })
        .def("getArg", [](const clang::CXXUnresolvedConstructExpr& self, unsigned int I) -> const clang::Expr * {
           return  self.getArg(I);
        })
        .def("setArg", []( clang::CXXUnresolvedConstructExpr& self, unsigned int I , clang::Expr * E)  {
             self.setArg(I, E);
        })
        .def("getLocStart", [](const clang::CXXUnresolvedConstructExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXUnresolvedConstructExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CXXUnresolvedConstructExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXDependentScopeMemberExpr, stmt_deleter<clang::CXXDependentScopeMemberExpr>::type>(m, "CXXDependentScopeMemberExpr" , py::base<clang::Expr>())
        .def("isImplicitAccess", [](const clang::CXXDependentScopeMemberExpr& self) -> bool {
           return  self.isImplicitAccess();
        })
        .def("getBase", [](const clang::CXXDependentScopeMemberExpr& self) -> clang::Expr * {
           return  self.getBase();
        })
        .def("getBaseType", [](const clang::CXXDependentScopeMemberExpr& self) -> clang::QualType {
           return  self.getBaseType();
        })
        .def("isArrow", [](const clang::CXXDependentScopeMemberExpr& self) -> bool {
           return  self.isArrow();
        })
        .def("getOperatorLoc", [](const clang::CXXDependentScopeMemberExpr& self) -> clang::SourceLocation {
           return  self.getOperatorLoc();
        })
        //.def("getQualifier", [](const clang::CXXDependentScopeMemberExpr& self) -> clang::NestedNameSpecifier * {
        //   return  self.getQualifier();
        //})
        //.def("getQualifierLoc", [](const clang::CXXDependentScopeMemberExpr& self) -> clang::NestedNameSpecifierLoc {
        //   return  self.getQualifierLoc();
        //})
        .def("getFirstQualifierFoundInScope", [](const clang::CXXDependentScopeMemberExpr& self) -> clang::NamedDecl * {
           return  self.getFirstQualifierFoundInScope();
        })
        .def("getMemberNameInfo", [](const clang::CXXDependentScopeMemberExpr& self) -> const clang::DeclarationNameInfo & {
           return  self.getMemberNameInfo();
        })
        .def("getMember", [](const clang::CXXDependentScopeMemberExpr& self) -> clang::DeclarationName {
           return  self.getMember();
        })
        .def("getMemberLoc", [](const clang::CXXDependentScopeMemberExpr& self) -> clang::SourceLocation {
           return  self.getMemberLoc();
        })
        .def("getTemplateKeywordLoc", [](const clang::CXXDependentScopeMemberExpr& self) -> clang::SourceLocation {
           return  self.getTemplateKeywordLoc();
        })
        .def("getLAngleLoc", [](const clang::CXXDependentScopeMemberExpr& self) -> clang::SourceLocation {
           return  self.getLAngleLoc();
        })
        .def("getRAngleLoc", [](const clang::CXXDependentScopeMemberExpr& self) -> clang::SourceLocation {
           return  self.getRAngleLoc();
        })
        .def("hasTemplateKeyword", [](const clang::CXXDependentScopeMemberExpr& self) -> bool {
           return  self.hasTemplateKeyword();
        })
        .def("hasExplicitTemplateArgs", [](const clang::CXXDependentScopeMemberExpr& self) -> bool {
           return  self.hasExplicitTemplateArgs();
        })
        //.def("copyTemplateArgumentsInto", [](const clang::CXXDependentScopeMemberExpr& self, clang::TemplateArgumentListInfo & List)  {
        //     self.copyTemplateArgumentsInto(List);
        //})
        //.def("getTemplateArgs", [](const clang::CXXDependentScopeMemberExpr& self) -> const clang::TemplateArgumentLoc * {
        //   return  self.getTemplateArgs();
        //})
        .def("getNumTemplateArgs", [](const clang::CXXDependentScopeMemberExpr& self) -> unsigned int {
           return  self.getNumTemplateArgs();
        })
        .def("getLocStart", [](const clang::CXXDependentScopeMemberExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXDependentScopeMemberExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CXXDependentScopeMemberExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::UnresolvedMemberExpr, stmt_deleter<clang::UnresolvedMemberExpr>::type>(m, "UnresolvedMemberExpr" , py::base<clang::OverloadExpr>())
        .def("isImplicitAccess", [](const clang::UnresolvedMemberExpr& self) -> bool {
           return  self.isImplicitAccess();
        })
        .def("getBase", []( clang::UnresolvedMemberExpr& self) -> clang::Expr * {
           return  self.getBase();
        })
        .def("getBase", [](const clang::UnresolvedMemberExpr& self) -> const clang::Expr * {
           return  self.getBase();
        })
        .def("getBaseType", [](const clang::UnresolvedMemberExpr& self) -> clang::QualType {
           return  self.getBaseType();
        })
        .def("hasUnresolvedUsing", [](const clang::UnresolvedMemberExpr& self) -> bool {
           return  self.hasUnresolvedUsing();
        })
        .def("isArrow", [](const clang::UnresolvedMemberExpr& self) -> bool {
           return  self.isArrow();
        })
        .def("getOperatorLoc", [](const clang::UnresolvedMemberExpr& self) -> clang::SourceLocation {
           return  self.getOperatorLoc();
        })
        .def("getNamingClass", [](const clang::UnresolvedMemberExpr& self) -> clang::CXXRecordDecl * {
           return  self.getNamingClass();
        })
        .def("getMemberNameInfo", [](const clang::UnresolvedMemberExpr& self) -> const clang::DeclarationNameInfo & {
           return  self.getMemberNameInfo();
        })
        .def("getMemberName", [](const clang::UnresolvedMemberExpr& self) -> clang::DeclarationName {
           return  self.getMemberName();
        })
        .def("getMemberLoc", [](const clang::UnresolvedMemberExpr& self) -> clang::SourceLocation {
           return  self.getMemberLoc();
        })
        .def("getExprLoc", [](const clang::UnresolvedMemberExpr& self) -> clang::SourceLocation {
           return  self.getExprLoc();
        })
        .def("getLocStart", [](const clang::UnresolvedMemberExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::UnresolvedMemberExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::UnresolvedMemberExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXNoexceptExpr, stmt_deleter<clang::CXXNoexceptExpr>::type>(m, "CXXNoexceptExpr" , py::base<clang::Expr>())
        .def("getOperand", [](const clang::CXXNoexceptExpr& self) -> clang::Expr * {
           return  self.getOperand();
        })
        .def("getLocStart", [](const clang::CXXNoexceptExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXNoexceptExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getSourceRange", [](const clang::CXXNoexceptExpr& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getValue", [](const clang::CXXNoexceptExpr& self) -> bool {
           return  self.getValue();
        })
        //.def("children", []( clang::CXXNoexceptExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::PackExpansionExpr, stmt_deleter<clang::PackExpansionExpr>::type>(m, "PackExpansionExpr" , py::base<clang::Expr>())
        .def("getPattern", []( clang::PackExpansionExpr& self) -> clang::Expr * {
           return  self.getPattern();
        })
        .def("getPattern", [](const clang::PackExpansionExpr& self) -> const clang::Expr * {
           return  self.getPattern();
        })
        .def("getEllipsisLoc", [](const clang::PackExpansionExpr& self) -> clang::SourceLocation {
           return  self.getEllipsisLoc();
        })
        //.def("getNumExpansions", [](const clang::PackExpansionExpr& self) -> llvm::Optional<unsigned int> {
        //   return  self.getNumExpansions();
        //})
        .def("getLocStart", [](const clang::PackExpansionExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::PackExpansionExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::PackExpansionExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::SizeOfPackExpr, stmt_deleter<clang::SizeOfPackExpr>::type>(m, "SizeOfPackExpr" , py::base<clang::Expr>())
        .def("getOperatorLoc", [](const clang::SizeOfPackExpr& self) -> clang::SourceLocation {
           return  self.getOperatorLoc();
        })
        .def("getPackLoc", [](const clang::SizeOfPackExpr& self) -> clang::SourceLocation {
           return  self.getPackLoc();
        })
        .def("getRParenLoc", [](const clang::SizeOfPackExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("getPack", [](const clang::SizeOfPackExpr& self) -> clang::NamedDecl * {
           return  self.getPack();
        })
        .def("getPackLength", [](const clang::SizeOfPackExpr& self) -> unsigned int {
           return  self.getPackLength();
        })
        .def("isPartiallySubstituted", [](const clang::SizeOfPackExpr& self) -> bool {
           return  self.isPartiallySubstituted();
        })
        //.def("getPartialArguments", [](const clang::SizeOfPackExpr& self) -> llvm::ArrayRef<clang::TemplateArgument> {
        //   return  self.getPartialArguments();
        //})
        .def("getLocStart", [](const clang::SizeOfPackExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::SizeOfPackExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::SizeOfPackExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::SubstNonTypeTemplateParmExpr, stmt_deleter<clang::SubstNonTypeTemplateParmExpr>::type>(m, "SubstNonTypeTemplateParmExpr" , py::base<clang::Expr>())
        .def("getNameLoc", [](const clang::SubstNonTypeTemplateParmExpr& self) -> clang::SourceLocation {
           return  self.getNameLoc();
        })
        .def("getLocStart", [](const clang::SubstNonTypeTemplateParmExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::SubstNonTypeTemplateParmExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getReplacement", [](const clang::SubstNonTypeTemplateParmExpr& self) -> clang::Expr * {
           return  self.getReplacement();
        })
        .def("getParameter", [](const clang::SubstNonTypeTemplateParmExpr& self) -> clang::NonTypeTemplateParmDecl * {
           return  self.getParameter();
        })
        //.def("children", []( clang::SubstNonTypeTemplateParmExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::SubstNonTypeTemplateParmPackExpr, stmt_deleter<clang::SubstNonTypeTemplateParmPackExpr>::type>(m, "SubstNonTypeTemplateParmPackExpr" , py::base<clang::Expr>())
        .def("getParameterPack", [](const clang::SubstNonTypeTemplateParmPackExpr& self) -> clang::NonTypeTemplateParmDecl * {
           return  self.getParameterPack();
        })
        .def("getParameterPackLocation", [](const clang::SubstNonTypeTemplateParmPackExpr& self) -> clang::SourceLocation {
           return  self.getParameterPackLocation();
        })
        //.def("getArgumentPack", [](const clang::SubstNonTypeTemplateParmPackExpr& self) -> clang::TemplateArgument {
        //   return  self.getArgumentPack();
        //})
        .def("getLocStart", [](const clang::SubstNonTypeTemplateParmPackExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::SubstNonTypeTemplateParmPackExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::SubstNonTypeTemplateParmPackExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::FunctionParmPackExpr, stmt_deleter<clang::FunctionParmPackExpr>::type>(m, "FunctionParmPackExpr" , py::base<clang::Expr>())
        .def("getParameterPack", [](const clang::FunctionParmPackExpr& self) -> clang::ParmVarDecl * {
           return  self.getParameterPack();
        })
        .def("getParameterPackLocation", [](const clang::FunctionParmPackExpr& self) -> clang::SourceLocation {
           return  self.getParameterPackLocation();
        })
        .def("getNumExpansions", [](const clang::FunctionParmPackExpr& self) -> unsigned int {
           return  self.getNumExpansions();
        })
        .def("getExpansion", [](const clang::FunctionParmPackExpr& self, unsigned int I) -> clang::ParmVarDecl * {
           return  self.getExpansion(I);
        })
        .def("getLocStart", [](const clang::FunctionParmPackExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::FunctionParmPackExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::FunctionParmPackExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::MaterializeTemporaryExpr, stmt_deleter<clang::MaterializeTemporaryExpr>::type>(m, "MaterializeTemporaryExpr" , py::base<clang::Expr>())
        .def("getTemporary", [](const clang::MaterializeTemporaryExpr& self) -> clang::Stmt * {
           return  self.getTemporary();
        })
        .def("GetTemporaryExpr", [](const clang::MaterializeTemporaryExpr& self) -> clang::Expr * {
           return  self.GetTemporaryExpr();
        })
        .def("getStorageDuration", [](const clang::MaterializeTemporaryExpr& self) -> clang::StorageDuration {
           return  self.getStorageDuration();
        })
        .def("getExtendingDecl", [](const clang::MaterializeTemporaryExpr& self) -> const clang::ValueDecl * {
           return  self.getExtendingDecl();
        })
        .def("setExtendingDecl", []( clang::MaterializeTemporaryExpr& self, const clang::ValueDecl * ExtendedBy , unsigned int ManglingNumber)  {
             self.setExtendingDecl(ExtendedBy, ManglingNumber);
        })
        .def("getManglingNumber", [](const clang::MaterializeTemporaryExpr& self) -> unsigned int {
           return  self.getManglingNumber();
        })
        .def("isBoundToLvalueReference", [](const clang::MaterializeTemporaryExpr& self) -> bool {
           return  self.isBoundToLvalueReference();
        })
        .def("getLocStart", [](const clang::MaterializeTemporaryExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::MaterializeTemporaryExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::MaterializeTemporaryExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXFoldExpr, stmt_deleter<clang::CXXFoldExpr>::type>(m, "CXXFoldExpr" , py::base<clang::Expr>())
        .def("getLHS", [](const clang::CXXFoldExpr& self) -> clang::Expr * {
           return  self.getLHS();
        })
        .def("getRHS", [](const clang::CXXFoldExpr& self) -> clang::Expr * {
           return  self.getRHS();
        })
        .def("isRightFold", [](const clang::CXXFoldExpr& self) -> bool {
           return  self.isRightFold();
        })
        .def("isLeftFold", [](const clang::CXXFoldExpr& self) -> bool {
           return  self.isLeftFold();
        })
        .def("getPattern", [](const clang::CXXFoldExpr& self) -> clang::Expr * {
           return  self.getPattern();
        })
        .def("getInit", [](const clang::CXXFoldExpr& self) -> clang::Expr * {
           return  self.getInit();
        })
        .def("getEllipsisLoc", [](const clang::CXXFoldExpr& self) -> clang::SourceLocation {
           return  self.getEllipsisLoc();
        })
        .def("getOperator", [](const clang::CXXFoldExpr& self) -> clang::BinaryOperatorKind {
           return  self.getOperator();
        })
        .def("getLocStart", [](const clang::CXXFoldExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXFoldExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CXXFoldExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CoroutineSuspendExpr, stmt_deleter<clang::CoroutineSuspendExpr>::type>(m, "CoroutineSuspendExpr" , py::base<clang::Expr>())
        .def("getKeywordLoc", [](const clang::CoroutineSuspendExpr& self) -> clang::SourceLocation {
           return  self.getKeywordLoc();
        })
        .def("getCommonExpr", [](const clang::CoroutineSuspendExpr& self) -> clang::Expr * {
           return  self.getCommonExpr();
        })
        .def("getReadyExpr", [](const clang::CoroutineSuspendExpr& self) -> clang::Expr * {
           return  self.getReadyExpr();
        })
        .def("getSuspendExpr", [](const clang::CoroutineSuspendExpr& self) -> clang::Expr * {
           return  self.getSuspendExpr();
        })
        .def("getResumeExpr", [](const clang::CoroutineSuspendExpr& self) -> clang::Expr * {
           return  self.getResumeExpr();
        })
        .def("getLocStart", [](const clang::CoroutineSuspendExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CoroutineSuspendExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CoroutineSuspendExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CoawaitExpr, stmt_deleter<clang::CoawaitExpr>::type>(m, "CoawaitExpr" , py::base<clang::CoroutineSuspendExpr>())
        .def("getOperand", [](const clang::CoawaitExpr& self) -> clang::Expr * {
           return  self.getOperand();
        })
    ;

    py::class_<clang::CoyieldExpr, stmt_deleter<clang::CoyieldExpr>::type>(m, "CoyieldExpr" , py::base<clang::CoroutineSuspendExpr>())
        .def("getOperand", [](const clang::CoyieldExpr& self) -> clang::Expr * {
           return  self.getOperand();
        })
    ;

    py::class_<clang::CXXCatchStmt, stmt_deleter<clang::CXXCatchStmt>::type>(m, "CXXCatchStmt" , py::base<clang::Stmt>())
        .def("getLocStart", [](const clang::CXXCatchStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXCatchStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getCatchLoc", [](const clang::CXXCatchStmt& self) -> clang::SourceLocation {
           return  self.getCatchLoc();
        })
        .def("getExceptionDecl", [](const clang::CXXCatchStmt& self) -> clang::VarDecl * {
           return  self.getExceptionDecl();
        })
        .def("getCaughtType", [](const clang::CXXCatchStmt& self) -> clang::QualType {
           return  self.getCaughtType();
        })
        .def("getHandlerBlock", [](const clang::CXXCatchStmt& self) -> clang::Stmt * {
           return  self.getHandlerBlock();
        })
        //.def("children", []( clang::CXXCatchStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXTryStmt, stmt_deleter<clang::CXXTryStmt>::type>(m, "CXXTryStmt" , py::base<clang::Stmt>())
        .def("getLocStart", [](const clang::CXXTryStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXTryStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getTryLoc", [](const clang::CXXTryStmt& self) -> clang::SourceLocation {
           return  self.getTryLoc();
        })
        .def("getEndLoc", [](const clang::CXXTryStmt& self) -> clang::SourceLocation {
           return  self.getEndLoc();
        })
        .def("getTryBlock", []( clang::CXXTryStmt& self) -> clang::CompoundStmt * {
           return  self.getTryBlock();
        })
        .def("getTryBlock", [](const clang::CXXTryStmt& self) -> const clang::CompoundStmt * {
           return  self.getTryBlock();
        })
        .def("getNumHandlers", [](const clang::CXXTryStmt& self) -> unsigned int {
           return  self.getNumHandlers();
        })
        .def("getHandler", []( clang::CXXTryStmt& self, unsigned int i) -> clang::CXXCatchStmt * {
           return  self.getHandler(i);
        })
        .def("getHandler", [](const clang::CXXTryStmt& self, unsigned int i) -> const clang::CXXCatchStmt * {
           return  self.getHandler(i);
        })
        //.def("children", []( clang::CXXTryStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CXXForRangeStmt, stmt_deleter<clang::CXXForRangeStmt>::type>(m, "CXXForRangeStmt" , py::base<clang::Stmt>())
        .def("getLoopVariable", []( clang::CXXForRangeStmt& self) -> clang::VarDecl * {
           return  self.getLoopVariable();
        })
        .def("getRangeInit", []( clang::CXXForRangeStmt& self) -> clang::Expr * {
           return  self.getRangeInit();
        })
        .def("getLoopVariable", [](const clang::CXXForRangeStmt& self) -> const clang::VarDecl * {
           return  self.getLoopVariable();
        })
        .def("getRangeInit", [](const clang::CXXForRangeStmt& self) -> const clang::Expr * {
           return  self.getRangeInit();
        })
        .def("getRangeStmt", []( clang::CXXForRangeStmt& self) -> clang::DeclStmt * {
           return  self.getRangeStmt();
        })
        .def("getBeginEndStmt", []( clang::CXXForRangeStmt& self) -> clang::DeclStmt * {
           return  self.getBeginEndStmt();
        })
        .def("getCond", []( clang::CXXForRangeStmt& self) -> clang::Expr * {
           return  self.getCond();
        })
        .def("getInc", []( clang::CXXForRangeStmt& self) -> clang::Expr * {
           return  self.getInc();
        })
        .def("getLoopVarStmt", []( clang::CXXForRangeStmt& self) -> clang::DeclStmt * {
           return  self.getLoopVarStmt();
        })
        .def("getBody", []( clang::CXXForRangeStmt& self) -> clang::Stmt * {
           return  self.getBody();
        })
        .def("getRangeStmt", [](const clang::CXXForRangeStmt& self) -> const clang::DeclStmt * {
           return  self.getRangeStmt();
        })
        .def("getBeginEndStmt", [](const clang::CXXForRangeStmt& self) -> const clang::DeclStmt * {
           return  self.getBeginEndStmt();
        })
        .def("getCond", [](const clang::CXXForRangeStmt& self) -> const clang::Expr * {
           return  self.getCond();
        })
        .def("getInc", [](const clang::CXXForRangeStmt& self) -> const clang::Expr * {
           return  self.getInc();
        })
        .def("getLoopVarStmt", [](const clang::CXXForRangeStmt& self) -> const clang::DeclStmt * {
           return  self.getLoopVarStmt();
        })
        .def("getBody", [](const clang::CXXForRangeStmt& self) -> const clang::Stmt * {
           return  self.getBody();
        })
        .def("setRangeInit", []( clang::CXXForRangeStmt& self, clang::Expr * E)  {
             self.setRangeInit(E);
        })
        .def("setRangeStmt", []( clang::CXXForRangeStmt& self, clang::Stmt * S)  {
             self.setRangeStmt(S);
        })
        .def("setBeginEndStmt", []( clang::CXXForRangeStmt& self, clang::Stmt * S)  {
             self.setBeginEndStmt(S);
        })
        .def("setCond", []( clang::CXXForRangeStmt& self, clang::Expr * E)  {
             self.setCond(E);
        })
        .def("setInc", []( clang::CXXForRangeStmt& self, clang::Expr * E)  {
             self.setInc(E);
        })
        .def("setLoopVarStmt", []( clang::CXXForRangeStmt& self, clang::Stmt * S)  {
             self.setLoopVarStmt(S);
        })
        .def("setBody", []( clang::CXXForRangeStmt& self, clang::Stmt * S)  {
             self.setBody(S);
        })
        .def("getForLoc", [](const clang::CXXForRangeStmt& self) -> clang::SourceLocation {
           return  self.getForLoc();
        })
        .def("getCoawaitLoc", [](const clang::CXXForRangeStmt& self) -> clang::SourceLocation {
           return  self.getCoawaitLoc();
        })
        .def("getColonLoc", [](const clang::CXXForRangeStmt& self) -> clang::SourceLocation {
           return  self.getColonLoc();
        })
        .def("getRParenLoc", [](const clang::CXXForRangeStmt& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("getLocStart", [](const clang::CXXForRangeStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXForRangeStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CXXForRangeStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::MSDependentExistsStmt, stmt_deleter<clang::MSDependentExistsStmt>::type>(m, "MSDependentExistsStmt" , py::base<clang::Stmt>())
        .def("getKeywordLoc", [](const clang::MSDependentExistsStmt& self) -> clang::SourceLocation {
           return  self.getKeywordLoc();
        })
        .def("isIfExists", [](const clang::MSDependentExistsStmt& self) -> bool {
           return  self.isIfExists();
        })
        .def("isIfNotExists", [](const clang::MSDependentExistsStmt& self) -> bool {
           return  self.isIfNotExists();
        })
        //.def("getQualifierLoc", [](const clang::MSDependentExistsStmt& self) -> clang::NestedNameSpecifierLoc {
        //   return  self.getQualifierLoc();
        //})
        .def("getNameInfo", [](const clang::MSDependentExistsStmt& self) -> clang::DeclarationNameInfo {
           return  self.getNameInfo();
        })
        .def("getSubStmt", [](const clang::MSDependentExistsStmt& self) -> clang::CompoundStmt * {
           return  self.getSubStmt();
        })
        .def("getLocStart", [](const clang::MSDependentExistsStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::MSDependentExistsStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::MSDependentExistsStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CoroutineBodyStmt, stmt_deleter<clang::CoroutineBodyStmt>::type>(m, "CoroutineBodyStmt" , py::base<clang::Stmt>())
        .def("getBody", [](const clang::CoroutineBodyStmt& self) -> clang::Stmt * {
           return  self.getBody();
        })
        .def("getPromiseDeclStmt", [](const clang::CoroutineBodyStmt& self) -> clang::Stmt * {
           return  self.getPromiseDeclStmt();
        })
        .def("getPromiseDecl", [](const clang::CoroutineBodyStmt& self) -> clang::VarDecl * {
           return  self.getPromiseDecl();
        })
        .def("getInitSuspendStmt", [](const clang::CoroutineBodyStmt& self) -> clang::Stmt * {
           return  self.getInitSuspendStmt();
        })
        .def("getFinalSuspendStmt", [](const clang::CoroutineBodyStmt& self) -> clang::Stmt * {
           return  self.getFinalSuspendStmt();
        })
        .def("getExceptionHandler", [](const clang::CoroutineBodyStmt& self) -> clang::Stmt * {
           return  self.getExceptionHandler();
        })
        .def("getFallthroughHandler", [](const clang::CoroutineBodyStmt& self) -> clang::Stmt * {
           return  self.getFallthroughHandler();
        })
        .def("getReturnValueInit", [](const clang::CoroutineBodyStmt& self) -> clang::Expr * {
           return  self.getReturnValueInit();
        })
        .def("getLocStart", [](const clang::CoroutineBodyStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CoroutineBodyStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CoroutineBodyStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CoreturnStmt, stmt_deleter<clang::CoreturnStmt>::type>(m, "CoreturnStmt" , py::base<clang::Stmt>())
        .def("getKeywordLoc", [](const clang::CoreturnStmt& self) -> clang::SourceLocation {
           return  self.getKeywordLoc();
        })
        .def("getOperand", [](const clang::CoreturnStmt& self) -> clang::Expr * {
           return  self.getOperand();
        })
        .def("getPromiseCall", [](const clang::CoreturnStmt& self) -> clang::Expr * {
           return  self.getPromiseCall();
        })
        .def("getLocStart", [](const clang::CoreturnStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CoreturnStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CoreturnStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::FriendDecl, decl_deleter<clang::FriendDecl>::type>(m, "FriendDecl" , py::base<clang::Decl>())
        .def("getFriendType", [](const clang::FriendDecl& self) -> clang::TypeSourceInfo * {
           return  self.getFriendType();
        })
        .def("getFriendTypeNumTemplateParameterLists", [](const clang::FriendDecl& self) -> unsigned int {
           return  self.getFriendTypeNumTemplateParameterLists();
        })
        //.def("getFriendTypeTemplateParameterList", [](const clang::FriendDecl& self, unsigned int N) -> clang::TemplateParameterList * {
        //   return  self.getFriendTypeTemplateParameterList(N);
        //})
        .def("getFriendDecl", [](const clang::FriendDecl& self) -> clang::NamedDecl * {
           return  self.getFriendDecl();
        })
        .def("getFriendLoc", [](const clang::FriendDecl& self) -> clang::SourceLocation {
           return  self.getFriendLoc();
        })
        .def("getSourceRange", [](const clang::FriendDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
    ;
}
