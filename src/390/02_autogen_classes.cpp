
////////////////////////////////////////////////////////////////////////////////
// File autogenerated by clastgen
//  Clang - clang version 3.9.0-svn274595-1~exp1 (trunk)
//
// Warning. Changes made here will be overwritten.
////////////////////////////////////////////////////////////////////////////////
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include "internal.h"

#include <clang/AST/AST.h>
#include <clang/ASTMatchers/ASTMatchers.h>
#include <clang/ASTMatchers/ASTMatchFinder.h>


namespace py = pybind11;

void autogenerated_classes_1(pybind11::module& m)
{

    py::class_<clang::WhileStmt, stmt_deleter<clang::WhileStmt>::type>(m, "WhileStmt" , py::base<clang::Stmt>())
        .def("getConditionVariable", [](const clang::WhileStmt& self) -> clang::VarDecl * {
           return  self.getConditionVariable();
        })
        .def("setConditionVariable", []( clang::WhileStmt& self, const clang::ASTContext & C , clang::VarDecl * V)  {
             self.setConditionVariable(C, V);
        })
        .def("getConditionVariableDeclStmt", [](const clang::WhileStmt& self) -> const clang::DeclStmt * {
           return  self.getConditionVariableDeclStmt();
        })
        .def("getCond", []( clang::WhileStmt& self) -> clang::Expr * {
           return  self.getCond();
        })
        .def("getCond", [](const clang::WhileStmt& self) -> const clang::Expr * {
           return  self.getCond();
        })
        .def("setCond", []( clang::WhileStmt& self, clang::Expr * E)  {
             self.setCond(E);
        })
        .def("getBody", []( clang::WhileStmt& self) -> clang::Stmt * {
           return  self.getBody();
        })
        .def("getBody", [](const clang::WhileStmt& self) -> const clang::Stmt * {
           return  self.getBody();
        })
        .def("setBody", []( clang::WhileStmt& self, clang::Stmt * S)  {
             self.setBody(S);
        })
        .def("getWhileLoc", [](const clang::WhileStmt& self) -> clang::SourceLocation {
           return  self.getWhileLoc();
        })
        .def("setWhileLoc", []( clang::WhileStmt& self, clang::SourceLocation L)  {
             self.setWhileLoc(L);
        })
        .def("getLocStart", [](const clang::WhileStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::WhileStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::WhileStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::DoStmt, stmt_deleter<clang::DoStmt>::type>(m, "DoStmt" , py::base<clang::Stmt>())
        .def("getCond", []( clang::DoStmt& self) -> clang::Expr * {
           return  self.getCond();
        })
        .def("getCond", [](const clang::DoStmt& self) -> const clang::Expr * {
           return  self.getCond();
        })
        .def("setCond", []( clang::DoStmt& self, clang::Expr * E)  {
             self.setCond(E);
        })
        .def("getBody", []( clang::DoStmt& self) -> clang::Stmt * {
           return  self.getBody();
        })
        .def("getBody", [](const clang::DoStmt& self) -> const clang::Stmt * {
           return  self.getBody();
        })
        .def("setBody", []( clang::DoStmt& self, clang::Stmt * S)  {
             self.setBody(S);
        })
        .def("getDoLoc", [](const clang::DoStmt& self) -> clang::SourceLocation {
           return  self.getDoLoc();
        })
        .def("setDoLoc", []( clang::DoStmt& self, clang::SourceLocation L)  {
             self.setDoLoc(L);
        })
        .def("getWhileLoc", [](const clang::DoStmt& self) -> clang::SourceLocation {
           return  self.getWhileLoc();
        })
        .def("setWhileLoc", []( clang::DoStmt& self, clang::SourceLocation L)  {
             self.setWhileLoc(L);
        })
        .def("getRParenLoc", [](const clang::DoStmt& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("setRParenLoc", []( clang::DoStmt& self, clang::SourceLocation L)  {
             self.setRParenLoc(L);
        })
        .def("getLocStart", [](const clang::DoStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::DoStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::DoStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ForStmt, stmt_deleter<clang::ForStmt>::type>(m, "ForStmt" , py::base<clang::Stmt>())
        .def("getInit", []( clang::ForStmt& self) -> clang::Stmt * {
           return  self.getInit();
        })
        .def("getConditionVariable", [](const clang::ForStmt& self) -> clang::VarDecl * {
           return  self.getConditionVariable();
        })
        .def("setConditionVariable", []( clang::ForStmt& self, const clang::ASTContext & C , clang::VarDecl * V)  {
             self.setConditionVariable(C, V);
        })
        .def("getConditionVariableDeclStmt", [](const clang::ForStmt& self) -> const clang::DeclStmt * {
           return  self.getConditionVariableDeclStmt();
        })
        .def("getCond", []( clang::ForStmt& self) -> clang::Expr * {
           return  self.getCond();
        })
        .def("getInc", []( clang::ForStmt& self) -> clang::Expr * {
           return  self.getInc();
        })
        .def("getBody", []( clang::ForStmt& self) -> clang::Stmt * {
           return  self.getBody();
        })
        .def("getInit", [](const clang::ForStmt& self) -> const clang::Stmt * {
           return  self.getInit();
        })
        .def("getCond", [](const clang::ForStmt& self) -> const clang::Expr * {
           return  self.getCond();
        })
        .def("getInc", [](const clang::ForStmt& self) -> const clang::Expr * {
           return  self.getInc();
        })
        .def("getBody", [](const clang::ForStmt& self) -> const clang::Stmt * {
           return  self.getBody();
        })
        .def("setInit", []( clang::ForStmt& self, clang::Stmt * S)  {
             self.setInit(S);
        })
        .def("setCond", []( clang::ForStmt& self, clang::Expr * E)  {
             self.setCond(E);
        })
        .def("setInc", []( clang::ForStmt& self, clang::Expr * E)  {
             self.setInc(E);
        })
        .def("setBody", []( clang::ForStmt& self, clang::Stmt * S)  {
             self.setBody(S);
        })
        .def("getForLoc", [](const clang::ForStmt& self) -> clang::SourceLocation {
           return  self.getForLoc();
        })
        .def("setForLoc", []( clang::ForStmt& self, clang::SourceLocation L)  {
             self.setForLoc(L);
        })
        .def("getLParenLoc", [](const clang::ForStmt& self) -> clang::SourceLocation {
           return  self.getLParenLoc();
        })
        .def("setLParenLoc", []( clang::ForStmt& self, clang::SourceLocation L)  {
             self.setLParenLoc(L);
        })
        .def("getRParenLoc", [](const clang::ForStmt& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("setRParenLoc", []( clang::ForStmt& self, clang::SourceLocation L)  {
             self.setRParenLoc(L);
        })
        .def("getLocStart", [](const clang::ForStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ForStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::ForStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::GotoStmt, stmt_deleter<clang::GotoStmt>::type>(m, "GotoStmt" , py::base<clang::Stmt>())
        .def("getLabel", [](const clang::GotoStmt& self) -> clang::LabelDecl * {
           return  self.getLabel();
        })
        .def("setLabel", []( clang::GotoStmt& self, clang::LabelDecl * D)  {
             self.setLabel(D);
        })
        .def("getGotoLoc", [](const clang::GotoStmt& self) -> clang::SourceLocation {
           return  self.getGotoLoc();
        })
        .def("setGotoLoc", []( clang::GotoStmt& self, clang::SourceLocation L)  {
             self.setGotoLoc(L);
        })
        .def("getLabelLoc", [](const clang::GotoStmt& self) -> clang::SourceLocation {
           return  self.getLabelLoc();
        })
        .def("setLabelLoc", []( clang::GotoStmt& self, clang::SourceLocation L)  {
             self.setLabelLoc(L);
        })
        .def("getLocStart", [](const clang::GotoStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::GotoStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::GotoStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::IndirectGotoStmt, stmt_deleter<clang::IndirectGotoStmt>::type>(m, "IndirectGotoStmt" , py::base<clang::Stmt>())
        .def("setGotoLoc", []( clang::IndirectGotoStmt& self, clang::SourceLocation L)  {
             self.setGotoLoc(L);
        })
        .def("getGotoLoc", [](const clang::IndirectGotoStmt& self) -> clang::SourceLocation {
           return  self.getGotoLoc();
        })
        .def("setStarLoc", []( clang::IndirectGotoStmt& self, clang::SourceLocation L)  {
             self.setStarLoc(L);
        })
        .def("getStarLoc", [](const clang::IndirectGotoStmt& self) -> clang::SourceLocation {
           return  self.getStarLoc();
        })
        .def("getTarget", []( clang::IndirectGotoStmt& self) -> clang::Expr * {
           return  self.getTarget();
        })
        .def("getTarget", [](const clang::IndirectGotoStmt& self) -> const clang::Expr * {
           return  self.getTarget();
        })
        .def("setTarget", []( clang::IndirectGotoStmt& self, clang::Expr * E)  {
             self.setTarget(E);
        })
        .def("getConstantTarget", []( clang::IndirectGotoStmt& self) -> clang::LabelDecl * {
           return  self.getConstantTarget();
        })
        .def("getConstantTarget", [](const clang::IndirectGotoStmt& self) -> const clang::LabelDecl * {
           return  self.getConstantTarget();
        })
        .def("getLocStart", [](const clang::IndirectGotoStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::IndirectGotoStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::IndirectGotoStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ContinueStmt, stmt_deleter<clang::ContinueStmt>::type>(m, "ContinueStmt" , py::base<clang::Stmt>())
        .def("getContinueLoc", [](const clang::ContinueStmt& self) -> clang::SourceLocation {
           return  self.getContinueLoc();
        })
        .def("setContinueLoc", []( clang::ContinueStmt& self, clang::SourceLocation L)  {
             self.setContinueLoc(L);
        })
        .def("getLocStart", [](const clang::ContinueStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ContinueStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::ContinueStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::BreakStmt, stmt_deleter<clang::BreakStmt>::type>(m, "BreakStmt" , py::base<clang::Stmt>())
        .def("getBreakLoc", [](const clang::BreakStmt& self) -> clang::SourceLocation {
           return  self.getBreakLoc();
        })
        .def("setBreakLoc", []( clang::BreakStmt& self, clang::SourceLocation L)  {
             self.setBreakLoc(L);
        })
        .def("getLocStart", [](const clang::BreakStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::BreakStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::BreakStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ReturnStmt, stmt_deleter<clang::ReturnStmt>::type>(m, "ReturnStmt" , py::base<clang::Stmt>())
        .def("getRetValue", [](const clang::ReturnStmt& self) -> const clang::Expr * {
           return  self.getRetValue();
        })
        .def("getRetValue", []( clang::ReturnStmt& self) -> clang::Expr * {
           return  self.getRetValue();
        })
        .def("setRetValue", []( clang::ReturnStmt& self, clang::Expr * E)  {
             self.setRetValue(E);
        })
        .def("getReturnLoc", [](const clang::ReturnStmt& self) -> clang::SourceLocation {
           return  self.getReturnLoc();
        })
        .def("setReturnLoc", []( clang::ReturnStmt& self, clang::SourceLocation L)  {
             self.setReturnLoc(L);
        })
        .def("getNRVOCandidate", [](const clang::ReturnStmt& self) -> const clang::VarDecl * {
           return  self.getNRVOCandidate();
        })
        .def("setNRVOCandidate", []( clang::ReturnStmt& self, const clang::VarDecl * Var)  {
             self.setNRVOCandidate(Var);
        })
        .def("getLocStart", [](const clang::ReturnStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ReturnStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::ReturnStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::AsmStmt, stmt_deleter<clang::AsmStmt>::type>(m, "AsmStmt" , py::base<clang::Stmt>())
        .def("getAsmLoc", [](const clang::AsmStmt& self) -> clang::SourceLocation {
           return  self.getAsmLoc();
        })
        .def("setAsmLoc", []( clang::AsmStmt& self, clang::SourceLocation L)  {
             self.setAsmLoc(L);
        })
        .def("isSimple", [](const clang::AsmStmt& self) -> bool {
           return  self.isSimple();
        })
        .def("setSimple", []( clang::AsmStmt& self, bool V)  {
             self.setSimple(V);
        })
        .def("isVolatile", [](const clang::AsmStmt& self) -> bool {
           return  self.isVolatile();
        })
        .def("setVolatile", []( clang::AsmStmt& self, bool V)  {
             self.setVolatile(V);
        })
        .def("getLocStart", [](const clang::AsmStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::AsmStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("generateAsmString", [](const clang::AsmStmt& self, const clang::ASTContext & C) -> std::basic_string<char> {
        //   return  self.generateAsmString(C);
        //})
        .def("getNumOutputs", [](const clang::AsmStmt& self) -> unsigned int {
           return  self.getNumOutputs();
        })
        .def("getOutputConstraint", [](const clang::AsmStmt& self, unsigned int i) -> llvm::StringRef {
           return  self.getOutputConstraint(i);
        })
        .def("isOutputPlusConstraint", [](const clang::AsmStmt& self, unsigned int i) -> bool {
           return  self.isOutputPlusConstraint(i);
        })
        .def("getOutputExpr", [](const clang::AsmStmt& self, unsigned int i) -> const clang::Expr * {
           return  self.getOutputExpr(i);
        })
        .def("getNumPlusOperands", [](const clang::AsmStmt& self) -> unsigned int {
           return  self.getNumPlusOperands();
        })
        .def("getNumInputs", [](const clang::AsmStmt& self) -> unsigned int {
           return  self.getNumInputs();
        })
        .def("getInputConstraint", [](const clang::AsmStmt& self, unsigned int i) -> llvm::StringRef {
           return  self.getInputConstraint(i);
        })
        .def("getInputExpr", [](const clang::AsmStmt& self, unsigned int i) -> const clang::Expr * {
           return  self.getInputExpr(i);
        })
        .def("getNumClobbers", [](const clang::AsmStmt& self) -> unsigned int {
           return  self.getNumClobbers();
        })
        .def("getClobber", [](const clang::AsmStmt& self, unsigned int i) -> llvm::StringRef {
           return  self.getClobber(i);
        })
        //.def("inputs", []( clang::AsmStmt& self) -> llvm::iterator_range<clang::Stmt::ExprIterator> {
        //   return  self.inputs();
        //})
        //.def("inputs", [](const clang::AsmStmt& self) -> llvm::iterator_range<clang::Stmt::ConstExprIterator> {
        //   return  self.inputs();
        //})
        //.def("outputs", []( clang::AsmStmt& self) -> llvm::iterator_range<clang::Stmt::ExprIterator> {
        //   return  self.outputs();
        //})
        //.def("outputs", [](const clang::AsmStmt& self) -> llvm::iterator_range<clang::Stmt::ConstExprIterator> {
        //   return  self.outputs();
        //})
        //.def("children", []( clang::AsmStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::GCCAsmStmt, stmt_deleter<clang::GCCAsmStmt>::type>(m, "GCCAsmStmt" , py::base<clang::AsmStmt>())
        .def("getRParenLoc", [](const clang::GCCAsmStmt& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("setRParenLoc", []( clang::GCCAsmStmt& self, clang::SourceLocation L)  {
             self.setRParenLoc(L);
        })
        .def("getAsmString", [](const clang::GCCAsmStmt& self) -> const clang::StringLiteral * {
           return  self.getAsmString();
        })
        .def("getAsmString", []( clang::GCCAsmStmt& self) -> clang::StringLiteral * {
           return  self.getAsmString();
        })
        .def("setAsmString", []( clang::GCCAsmStmt& self, clang::StringLiteral * E)  {
             self.setAsmString(E);
        })
        //.def("AnalyzeAsmString", [](const clang::GCCAsmStmt& self, llvm::SmallVectorImpl<clang::GCCAsmStmt::AsmStringPiece> & Pieces , const clang::ASTContext & C , unsigned int & DiagOffs) -> unsigned int {
        //   return  self.AnalyzeAsmString(Pieces, C, DiagOffs);
        //})
        //.def("generateAsmString", [](const clang::GCCAsmStmt& self, const clang::ASTContext & C) -> std::basic_string<char> {
        //   return  self.generateAsmString(C);
        //})
        //.def("getOutputIdentifier", [](const clang::GCCAsmStmt& self, unsigned int i) -> clang::IdentifierInfo * {
        //   return  self.getOutputIdentifier(i);
        //})
        .def("getOutputName", [](const clang::GCCAsmStmt& self, unsigned int i) -> llvm::StringRef {
           return  self.getOutputName(i);
        })
        .def("getOutputConstraint", [](const clang::GCCAsmStmt& self, unsigned int i) -> llvm::StringRef {
           return  self.getOutputConstraint(i);
        })
        .def("getOutputConstraintLiteral", [](const clang::GCCAsmStmt& self, unsigned int i) -> const clang::StringLiteral * {
           return  self.getOutputConstraintLiteral(i);
        })
        .def("getOutputConstraintLiteral", []( clang::GCCAsmStmt& self, unsigned int i) -> clang::StringLiteral * {
           return  self.getOutputConstraintLiteral(i);
        })
        .def("getOutputExpr", []( clang::GCCAsmStmt& self, unsigned int i) -> clang::Expr * {
           return  self.getOutputExpr(i);
        })
        .def("getOutputExpr", [](const clang::GCCAsmStmt& self, unsigned int i) -> const clang::Expr * {
           return  self.getOutputExpr(i);
        })
        //.def("getInputIdentifier", [](const clang::GCCAsmStmt& self, unsigned int i) -> clang::IdentifierInfo * {
        //   return  self.getInputIdentifier(i);
        //})
        .def("getInputName", [](const clang::GCCAsmStmt& self, unsigned int i) -> llvm::StringRef {
           return  self.getInputName(i);
        })
        .def("getInputConstraint", [](const clang::GCCAsmStmt& self, unsigned int i) -> llvm::StringRef {
           return  self.getInputConstraint(i);
        })
        .def("getInputConstraintLiteral", [](const clang::GCCAsmStmt& self, unsigned int i) -> const clang::StringLiteral * {
           return  self.getInputConstraintLiteral(i);
        })
        .def("getInputConstraintLiteral", []( clang::GCCAsmStmt& self, unsigned int i) -> clang::StringLiteral * {
           return  self.getInputConstraintLiteral(i);
        })
        .def("getInputExpr", []( clang::GCCAsmStmt& self, unsigned int i) -> clang::Expr * {
           return  self.getInputExpr(i);
        })
        .def("setInputExpr", []( clang::GCCAsmStmt& self, unsigned int i , clang::Expr * E)  {
             self.setInputExpr(i, E);
        })
        .def("getInputExpr", [](const clang::GCCAsmStmt& self, unsigned int i) -> const clang::Expr * {
           return  self.getInputExpr(i);
        })
        .def("getNamedOperand", [](const clang::GCCAsmStmt& self, llvm::StringRef SymbolicName) -> int {
           return  self.getNamedOperand(SymbolicName);
        })
        .def("getClobber", [](const clang::GCCAsmStmt& self, unsigned int i) -> llvm::StringRef {
           return  self.getClobber(i);
        })
        .def("getClobberStringLiteral", []( clang::GCCAsmStmt& self, unsigned int i) -> clang::StringLiteral * {
           return  self.getClobberStringLiteral(i);
        })
        .def("getClobberStringLiteral", [](const clang::GCCAsmStmt& self, unsigned int i) -> const clang::StringLiteral * {
           return  self.getClobberStringLiteral(i);
        })
        .def("getLocStart", [](const clang::GCCAsmStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::GCCAsmStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
    ;

    py::class_<clang::MSAsmStmt, stmt_deleter<clang::MSAsmStmt>::type>(m, "MSAsmStmt" , py::base<clang::AsmStmt>())
        .def("getLBraceLoc", [](const clang::MSAsmStmt& self) -> clang::SourceLocation {
           return  self.getLBraceLoc();
        })
        .def("setLBraceLoc", []( clang::MSAsmStmt& self, clang::SourceLocation L)  {
             self.setLBraceLoc(L);
        })
        .def("getEndLoc", [](const clang::MSAsmStmt& self) -> clang::SourceLocation {
           return  self.getEndLoc();
        })
        .def("setEndLoc", []( clang::MSAsmStmt& self, clang::SourceLocation L)  {
             self.setEndLoc(L);
        })
        .def("hasBraces", [](const clang::MSAsmStmt& self) -> bool {
           return  self.hasBraces();
        })
        .def("getNumAsmToks", []( clang::MSAsmStmt& self) -> unsigned int {
           return  self.getNumAsmToks();
        })
        //.def("getAsmToks", []( clang::MSAsmStmt& self) -> clang::Token * {
        //   return  self.getAsmToks();
        //})
        .def("getAsmString", [](const clang::MSAsmStmt& self) -> llvm::StringRef {
           return  self.getAsmString();
        })
        //.def("generateAsmString", [](const clang::MSAsmStmt& self, const clang::ASTContext & C) -> std::basic_string<char> {
        //   return  self.generateAsmString(C);
        //})
        .def("getOutputConstraint", [](const clang::MSAsmStmt& self, unsigned int i) -> llvm::StringRef {
           return  self.getOutputConstraint(i);
        })
        .def("getOutputExpr", []( clang::MSAsmStmt& self, unsigned int i) -> clang::Expr * {
           return  self.getOutputExpr(i);
        })
        .def("getOutputExpr", [](const clang::MSAsmStmt& self, unsigned int i) -> const clang::Expr * {
           return  self.getOutputExpr(i);
        })
        .def("getInputConstraint", [](const clang::MSAsmStmt& self, unsigned int i) -> llvm::StringRef {
           return  self.getInputConstraint(i);
        })
        .def("getInputExpr", []( clang::MSAsmStmt& self, unsigned int i) -> clang::Expr * {
           return  self.getInputExpr(i);
        })
        .def("setInputExpr", []( clang::MSAsmStmt& self, unsigned int i , clang::Expr * E)  {
             self.setInputExpr(i, E);
        })
        .def("getInputExpr", [](const clang::MSAsmStmt& self, unsigned int i) -> const clang::Expr * {
           return  self.getInputExpr(i);
        })
        //.def("getAllConstraints", [](const clang::MSAsmStmt& self) -> llvm::ArrayRef<llvm::StringRef> {
        //   return  self.getAllConstraints();
        //})
        //.def("getClobbers", [](const clang::MSAsmStmt& self) -> llvm::ArrayRef<llvm::StringRef> {
        //   return  self.getClobbers();
        //})
        //.def("getAllExprs", [](const clang::MSAsmStmt& self) -> llvm::ArrayRef<clang::Expr *> {
        //   return  self.getAllExprs();
        //})
        .def("getClobber", [](const clang::MSAsmStmt& self, unsigned int i) -> llvm::StringRef {
           return  self.getClobber(i);
        })
        .def("getLocStart", [](const clang::MSAsmStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::MSAsmStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::MSAsmStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::SEHExceptStmt, stmt_deleter<clang::SEHExceptStmt>::type>(m, "SEHExceptStmt" , py::base<clang::Stmt>())
        .def("getLocStart", [](const clang::SEHExceptStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::SEHExceptStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getExceptLoc", [](const clang::SEHExceptStmt& self) -> clang::SourceLocation {
           return  self.getExceptLoc();
        })
        .def("getEndLoc", [](const clang::SEHExceptStmt& self) -> clang::SourceLocation {
           return  self.getEndLoc();
        })
        .def("getFilterExpr", [](const clang::SEHExceptStmt& self) -> clang::Expr * {
           return  self.getFilterExpr();
        })
        .def("getBlock", [](const clang::SEHExceptStmt& self) -> clang::CompoundStmt * {
           return  self.getBlock();
        })
        //.def("children", []( clang::SEHExceptStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::SEHFinallyStmt, stmt_deleter<clang::SEHFinallyStmt>::type>(m, "SEHFinallyStmt" , py::base<clang::Stmt>())
        .def("getLocStart", [](const clang::SEHFinallyStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::SEHFinallyStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getFinallyLoc", [](const clang::SEHFinallyStmt& self) -> clang::SourceLocation {
           return  self.getFinallyLoc();
        })
        .def("getEndLoc", [](const clang::SEHFinallyStmt& self) -> clang::SourceLocation {
           return  self.getEndLoc();
        })
        .def("getBlock", [](const clang::SEHFinallyStmt& self) -> clang::CompoundStmt * {
           return  self.getBlock();
        })
        //.def("children", []( clang::SEHFinallyStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::SEHTryStmt, stmt_deleter<clang::SEHTryStmt>::type>(m, "SEHTryStmt" , py::base<clang::Stmt>())
        .def("getLocStart", [](const clang::SEHTryStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::SEHTryStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getTryLoc", [](const clang::SEHTryStmt& self) -> clang::SourceLocation {
           return  self.getTryLoc();
        })
        .def("getEndLoc", [](const clang::SEHTryStmt& self) -> clang::SourceLocation {
           return  self.getEndLoc();
        })
        .def("getIsCXXTry", [](const clang::SEHTryStmt& self) -> bool {
           return  self.getIsCXXTry();
        })
        .def("getTryBlock", [](const clang::SEHTryStmt& self) -> clang::CompoundStmt * {
           return  self.getTryBlock();
        })
        .def("getHandler", [](const clang::SEHTryStmt& self) -> clang::Stmt * {
           return  self.getHandler();
        })
        .def("getExceptHandler", [](const clang::SEHTryStmt& self) -> clang::SEHExceptStmt * {
           return  self.getExceptHandler();
        })
        .def("getFinallyHandler", [](const clang::SEHTryStmt& self) -> clang::SEHFinallyStmt * {
           return  self.getFinallyHandler();
        })
        //.def("children", []( clang::SEHTryStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::SEHLeaveStmt, stmt_deleter<clang::SEHLeaveStmt>::type>(m, "SEHLeaveStmt" , py::base<clang::Stmt>())
        .def("getLeaveLoc", [](const clang::SEHLeaveStmt& self) -> clang::SourceLocation {
           return  self.getLeaveLoc();
        })
        .def("setLeaveLoc", []( clang::SEHLeaveStmt& self, clang::SourceLocation L)  {
             self.setLeaveLoc(L);
        })
        .def("getLocStart", [](const clang::SEHLeaveStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::SEHLeaveStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::SEHLeaveStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CapturedStmt, stmt_deleter<clang::CapturedStmt>::type>(m, "CapturedStmt" , py::base<clang::Stmt>())
        .def("getCapturedStmt", []( clang::CapturedStmt& self) -> clang::Stmt * {
           return  self.getCapturedStmt();
        })
        .def("getCapturedStmt", [](const clang::CapturedStmt& self) -> const clang::Stmt * {
           return  self.getCapturedStmt();
        })
        .def("getCapturedDecl", []( clang::CapturedStmt& self) -> clang::CapturedDecl * {
           return  self.getCapturedDecl();
        })
        .def("getCapturedDecl", [](const clang::CapturedStmt& self) -> const clang::CapturedDecl * {
           return  self.getCapturedDecl();
        })
        .def("setCapturedDecl", []( clang::CapturedStmt& self, clang::CapturedDecl * D)  {
             self.setCapturedDecl(D);
        })
        .def("getCapturedRegionKind", [](const clang::CapturedStmt& self) -> clang::CapturedRegionKind {
           return  self.getCapturedRegionKind();
        })
        .def("setCapturedRegionKind", []( clang::CapturedStmt& self, clang::CapturedRegionKind Kind)  {
             self.setCapturedRegionKind(Kind);
        })
        .def("getCapturedRecordDecl", [](const clang::CapturedStmt& self) -> const clang::RecordDecl * {
           return  self.getCapturedRecordDecl();
        })
        .def("setCapturedRecordDecl", []( clang::CapturedStmt& self, clang::RecordDecl * D)  {
             self.setCapturedRecordDecl(D);
        })
        .def("capturesVariable", [](const clang::CapturedStmt& self, const clang::VarDecl * Var) -> bool {
           return  self.capturesVariable(Var);
        })
        //.def("captures", []( clang::CapturedStmt& self) -> llvm::iterator_range<clang::CapturedStmt::Capture *> {
        //   return  self.captures();
        //})
        //.def("captures", [](const clang::CapturedStmt& self) -> llvm::iterator_range<const clang::CapturedStmt::Capture *> {
        //   return  self.captures();
        //})
        .def("capture_size", [](const clang::CapturedStmt& self) -> unsigned int {
           return  self.capture_size();
        })
        //.def("capture_inits", []( clang::CapturedStmt& self) -> llvm::iterator_range<clang::Expr **> {
        //   return  self.capture_inits();
        //})
        //.def("capture_inits", [](const clang::CapturedStmt& self) -> llvm::iterator_range<clang::Expr *const *> {
        //   return  self.capture_inits();
        //})
        .def("getLocStart", [](const clang::CapturedStmt& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CapturedStmt& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getSourceRange", [](const clang::CapturedStmt& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        //.def("children", []( clang::CapturedStmt& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::SourceManager>(m, "SourceManager" )
        .def("clearIDTables", []( clang::SourceManager& self)  {
             self.clearIDTables();
        })
        //.def("getDiagnostics", [](const clang::SourceManager& self) -> clang::DiagnosticsEngine & {
        //   return  self.getDiagnostics();
        //})
        //.def("getFileManager", [](const clang::SourceManager& self) -> clang::FileManager & {
        //   return  self.getFileManager();
        //})
        .def("setOverridenFilesKeepOriginalName", []( clang::SourceManager& self, bool value)  {
             self.setOverridenFilesKeepOriginalName(value);
        })
        .def("userFilesAreVolatile", [](const clang::SourceManager& self) -> bool {
           return  self.userFilesAreVolatile();
        })
        //.def("getModuleBuildStack", [](const clang::SourceManager& self) -> llvm::ArrayRef<std::pair<std::basic_string<char>, clang::FullSourceLoc> > {
        //   return  self.getModuleBuildStack();
        //})
        //.def("setModuleBuildStack", []( clang::SourceManager& self, llvm::ArrayRef<std::pair<std::basic_string<char>, clang::FullSourceLoc> > stack)  {
        //     self.setModuleBuildStack(stack);
        //})
        //.def("pushModuleBuildStack", []( clang::SourceManager& self, llvm::StringRef moduleName , clang::FullSourceLoc importLoc)  {
        //     self.pushModuleBuildStack(moduleName, importLoc);
        //})
        //.def("getMainFileID", [](const clang::SourceManager& self) -> clang::FileID {
        //   return  self.getMainFileID();
        //})
        //.def("setMainFileID", []( clang::SourceManager& self, clang::FileID FID)  {
        //     self.setMainFileID(FID);
        //})
        //.def("setPreambleFileID", []( clang::SourceManager& self, clang::FileID Preamble)  {
        //     self.setPreambleFileID(Preamble);
        //})
        //.def("getPreambleFileID", [](const clang::SourceManager& self) -> clang::FileID {
        //   return  self.getPreambleFileID();
        //})
        //.def("createFileID", []( clang::SourceManager& self, const clang::FileEntry * SourceFile , clang::SourceLocation IncludePos , clang::SrcMgr::CharacteristicKind FileCharacter , int LoadedID , unsigned int LoadedOffset) -> clang::FileID {
        //   return  self.createFileID(SourceFile, IncludePos, FileCharacter, LoadedID, LoadedOffset);
        //})
        //.def("createFileID", []( clang::SourceManager& self, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> > Buffer , clang::SrcMgr::CharacteristicKind FileCharacter , int LoadedID , unsigned int LoadedOffset , clang::SourceLocation IncludeLoc) -> clang::FileID {
        //   return  self.createFileID(Buffer, FileCharacter, LoadedID, LoadedOffset, IncludeLoc);
        //})
        //.def("getOrCreateFileID", []( clang::SourceManager& self, const clang::FileEntry * SourceFile , clang::SrcMgr::CharacteristicKind FileCharacter) -> clang::FileID {
        //   return  self.getOrCreateFileID(SourceFile, FileCharacter);
        //})
        .def("createMacroArgExpansionLoc", []( clang::SourceManager& self, clang::SourceLocation Loc , clang::SourceLocation ExpansionLoc , unsigned int TokLength) -> clang::SourceLocation {
           return  self.createMacroArgExpansionLoc(Loc, ExpansionLoc, TokLength);
        })
        .def("createExpansionLoc", []( clang::SourceManager& self, clang::SourceLocation Loc , clang::SourceLocation ExpansionLocStart , clang::SourceLocation ExpansionLocEnd , unsigned int TokLength , int LoadedID , unsigned int LoadedOffset) -> clang::SourceLocation {
           return  self.createExpansionLoc(Loc, ExpansionLocStart, ExpansionLocEnd, TokLength, LoadedID, LoadedOffset);
        })
        //.def("getMemoryBufferForFile", []( clang::SourceManager& self, const clang::FileEntry * File , bool * Invalid) -> llvm::MemoryBuffer * {
        //   return  self.getMemoryBufferForFile(File, Invalid);
        //})
        //.def("overrideFileContents", []( clang::SourceManager& self, const clang::FileEntry * SourceFile , llvm::MemoryBuffer * Buffer , bool DoNotFree)  {
        //     self.overrideFileContents(SourceFile, Buffer, DoNotFree);
        //})
        //.def("overrideFileContents", []( clang::SourceManager& self, const clang::FileEntry * SourceFile , std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> > Buffer)  {
        //     self.overrideFileContents(SourceFile, Buffer);
        //})
        //.def("overrideFileContents", []( clang::SourceManager& self, const clang::FileEntry * SourceFile , const clang::FileEntry * NewFile)  {
        //     self.overrideFileContents(SourceFile, NewFile);
        //})
        //.def("isFileOverridden", []( clang::SourceManager& self, const clang::FileEntry * File) -> bool {
        //   return  self.isFileOverridden(File);
        //})
        //.def("disableFileContentsOverride", []( clang::SourceManager& self, const clang::FileEntry * File)  {
        //     self.disableFileContentsOverride(File);
        //})
        //.def("setFileIsTransient", []( clang::SourceManager& self, const clang::FileEntry * SourceFile)  {
        //     self.setFileIsTransient(SourceFile);
        //})
        .def("setAllFilesAreTransient", []( clang::SourceManager& self, bool Transient)  {
             self.setAllFilesAreTransient(Transient);
        })
        //.def("getBuffer", [](const clang::SourceManager& self, clang::FileID FID , clang::SourceLocation Loc , bool * Invalid) -> llvm::MemoryBuffer * {
        //   return  self.getBuffer(FID, Loc, Invalid);
        //})
        //.def("getBuffer", [](const clang::SourceManager& self, clang::FileID FID , bool * Invalid) -> llvm::MemoryBuffer * {
        //   return  self.getBuffer(FID, Invalid);
        //})
        //.def("getFileEntryForID", [](const clang::SourceManager& self, clang::FileID FID) -> const clang::FileEntry * {
        //   return  self.getFileEntryForID(FID);
        //})
        //.def("getFileEntryForSLocEntry", [](const clang::SourceManager& self, const clang::SrcMgr::SLocEntry & sloc) -> const clang::FileEntry * {
        //   return  self.getFileEntryForSLocEntry(sloc);
        //})
        //.def("getBufferData", [](const clang::SourceManager& self, clang::FileID FID , bool * Invalid) -> llvm::StringRef {
        //   return  self.getBufferData(FID, Invalid);
        //})
        //.def("getNumCreatedFIDsForFileID", [](const clang::SourceManager& self, clang::FileID FID) -> unsigned int {
        //   return  self.getNumCreatedFIDsForFileID(FID);
        //})
        //.def("setNumCreatedFIDsForFileID", [](const clang::SourceManager& self, clang::FileID FID , unsigned int NumFIDs)  {
        //     self.setNumCreatedFIDsForFileID(FID, NumFIDs);
        //})
        //.def("getFileID", [](const clang::SourceManager& self, clang::SourceLocation SpellingLoc) -> clang::FileID {
        //   return  self.getFileID(SpellingLoc);
        //})
        .def("getFilename", [](const clang::SourceManager& self, clang::SourceLocation SpellingLoc) -> llvm::StringRef {
           return  self.getFilename(SpellingLoc);
        })
        //.def("getLocForStartOfFile", [](const clang::SourceManager& self, clang::FileID FID) -> clang::SourceLocation {
        //   return  self.getLocForStartOfFile(FID);
        //})
        //.def("getLocForEndOfFile", [](const clang::SourceManager& self, clang::FileID FID) -> clang::SourceLocation {
        //   return  self.getLocForEndOfFile(FID);
        //})
        //.def("getIncludeLoc", [](const clang::SourceManager& self, clang::FileID FID) -> clang::SourceLocation {
        //   return  self.getIncludeLoc(FID);
        //})
        //.def("getModuleImportLoc", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> std::pair<clang::SourceLocation, llvm::StringRef> {
        //   return  self.getModuleImportLoc(Loc);
        //})
        .def("getExpansionLoc", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> clang::SourceLocation {
           return  self.getExpansionLoc(Loc);
        })
        .def("getFileLoc", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> clang::SourceLocation {
           return  self.getFileLoc(Loc);
        })
        //.def("getImmediateExpansionRange", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> std::pair<clang::SourceLocation, clang::SourceLocation> {
        //   return  self.getImmediateExpansionRange(Loc);
        //})
        //.def("getExpansionRange", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> std::pair<clang::SourceLocation, clang::SourceLocation> {
        //   return  self.getExpansionRange(Loc);
        //})
        .def("getExpansionRange", [](const clang::SourceManager& self, clang::SourceRange Range) -> clang::SourceRange {
           return  self.getExpansionRange(Range);
        })
        .def("getSpellingLoc", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> clang::SourceLocation {
           return  self.getSpellingLoc(Loc);
        })
        .def("getImmediateSpellingLoc", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> clang::SourceLocation {
           return  self.getImmediateSpellingLoc(Loc);
        })
        //.def("getDecomposedLoc", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> std::pair<clang::FileID, unsigned int> {
        //   return  self.getDecomposedLoc(Loc);
        //})
        //.def("getDecomposedExpansionLoc", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> std::pair<clang::FileID, unsigned int> {
        //   return  self.getDecomposedExpansionLoc(Loc);
        //})
        //.def("getDecomposedSpellingLoc", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> std::pair<clang::FileID, unsigned int> {
        //   return  self.getDecomposedSpellingLoc(Loc);
        //})
        //.def("getDecomposedIncludedLoc", [](const clang::SourceManager& self, clang::FileID FID) -> std::pair<clang::FileID, unsigned int> {
        //   return  self.getDecomposedIncludedLoc(FID);
        //})
        .def("getFileOffset", [](const clang::SourceManager& self, clang::SourceLocation SpellingLoc) -> unsigned int {
           return  self.getFileOffset(SpellingLoc);
        })
        .def("isMacroArgExpansion", [](const clang::SourceManager& self, clang::SourceLocation Loc , clang::SourceLocation * StartLoc) -> bool {
           return  self.isMacroArgExpansion(Loc, StartLoc);
        })
        .def("isMacroBodyExpansion", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> bool {
           return  self.isMacroBodyExpansion(Loc);
        })
        .def("isAtStartOfImmediateMacroExpansion", [](const clang::SourceManager& self, clang::SourceLocation Loc , clang::SourceLocation * MacroBegin) -> bool {
           return  self.isAtStartOfImmediateMacroExpansion(Loc, MacroBegin);
        })
        .def("isAtEndOfImmediateMacroExpansion", [](const clang::SourceManager& self, clang::SourceLocation Loc , clang::SourceLocation * MacroEnd) -> bool {
           return  self.isAtEndOfImmediateMacroExpansion(Loc, MacroEnd);
        })
        .def("isInSLocAddrSpace", [](const clang::SourceManager& self, clang::SourceLocation Loc , clang::SourceLocation Start , unsigned int Length , unsigned int * RelativeOffset) -> bool {
           return  self.isInSLocAddrSpace(Loc, Start, Length, RelativeOffset);
        })
        .def("isInSameSLocAddrSpace", [](const clang::SourceManager& self, clang::SourceLocation LHS , clang::SourceLocation RHS , int * RelativeOffset) -> bool {
           return  self.isInSameSLocAddrSpace(LHS, RHS, RelativeOffset);
        })
        .def("getCharacterData", [](const clang::SourceManager& self, clang::SourceLocation SL , bool * Invalid) -> const char * {
           return  self.getCharacterData(SL, Invalid);
        })
        //.def("getColumnNumber", [](const clang::SourceManager& self, clang::FileID FID , unsigned int FilePos , bool * Invalid) -> unsigned int {
        //   return  self.getColumnNumber(FID, FilePos, Invalid);
        //})
        .def("getSpellingColumnNumber", [](const clang::SourceManager& self, clang::SourceLocation Loc , bool * Invalid) -> unsigned int {
           return  self.getSpellingColumnNumber(Loc, Invalid);
        })
        .def("getExpansionColumnNumber", [](const clang::SourceManager& self, clang::SourceLocation Loc , bool * Invalid) -> unsigned int {
           return  self.getExpansionColumnNumber(Loc, Invalid);
        })
        .def("getPresumedColumnNumber", [](const clang::SourceManager& self, clang::SourceLocation Loc , bool * Invalid) -> unsigned int {
           return  self.getPresumedColumnNumber(Loc, Invalid);
        })
        //.def("getLineNumber", [](const clang::SourceManager& self, clang::FileID FID , unsigned int FilePos , bool * Invalid) -> unsigned int {
        //   return  self.getLineNumber(FID, FilePos, Invalid);
        //})
        .def("getSpellingLineNumber", [](const clang::SourceManager& self, clang::SourceLocation Loc , bool * Invalid) -> unsigned int {
           return  self.getSpellingLineNumber(Loc, Invalid);
        })
        .def("getExpansionLineNumber", [](const clang::SourceManager& self, clang::SourceLocation Loc , bool * Invalid) -> unsigned int {
           return  self.getExpansionLineNumber(Loc, Invalid);
        })
        .def("getPresumedLineNumber", [](const clang::SourceManager& self, clang::SourceLocation Loc , bool * Invalid) -> unsigned int {
           return  self.getPresumedLineNumber(Loc, Invalid);
        })
        .def("getBufferName", [](const clang::SourceManager& self, clang::SourceLocation Loc , bool * Invalid) -> const char * {
           return  self.getBufferName(Loc, Invalid);
        })
        //.def("getFileCharacteristic", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> clang::SrcMgr::CharacteristicKind {
        //   return  self.getFileCharacteristic(Loc);
        //})
        //.def("getPresumedLoc", [](const clang::SourceManager& self, clang::SourceLocation Loc , bool UseLineDirectives) -> clang::PresumedLoc {
        //   return  self.getPresumedLoc(Loc, UseLineDirectives);
        //})
        .def("isInMainFile", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> bool {
           return  self.isInMainFile(Loc);
        })
        .def("isWrittenInSameFile", [](const clang::SourceManager& self, clang::SourceLocation Loc1 , clang::SourceLocation Loc2) -> bool {
           return  self.isWrittenInSameFile(Loc1, Loc2);
        })
        .def("isWrittenInMainFile", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> bool {
           return  self.isWrittenInMainFile(Loc);
        })
        .def("isInSystemHeader", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> bool {
           return  self.isInSystemHeader(Loc);
        })
        .def("isInExternCSystemHeader", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> bool {
           return  self.isInExternCSystemHeader(Loc);
        })
        .def("isInSystemMacro", []( clang::SourceManager& self, clang::SourceLocation loc) -> bool {
           return  self.isInSystemMacro(loc);
        })
        //.def("getFileIDSize", [](const clang::SourceManager& self, clang::FileID FID) -> unsigned int {
        //   return  self.getFileIDSize(FID);
        //})
        //.def("isInFileID", [](const clang::SourceManager& self, clang::SourceLocation Loc , clang::FileID FID , unsigned int * RelativeOffset) -> bool {
        //   return  self.isInFileID(Loc, FID, RelativeOffset);
        //})
        .def("getLineTableFilenameID", []( clang::SourceManager& self, llvm::StringRef Str) -> unsigned int {
           return  self.getLineTableFilenameID(Str);
        })
        .def("AddLineNote", []( clang::SourceManager& self, clang::SourceLocation Loc , unsigned int LineNo , int FilenameID)  {
             self.AddLineNote(Loc, LineNo, FilenameID);
        })
        .def("AddLineNote", []( clang::SourceManager& self, clang::SourceLocation Loc , unsigned int LineNo , int FilenameID , bool IsFileEntry , bool IsFileExit , bool IsSystemHeader , bool IsExternCHeader)  {
             self.AddLineNote(Loc, LineNo, FilenameID, IsFileEntry, IsFileExit, IsSystemHeader, IsExternCHeader);
        })
        .def("hasLineTable", [](const clang::SourceManager& self) -> bool {
           return  self.hasLineTable();
        })
        //.def("getLineTable", []( clang::SourceManager& self) -> clang::LineTableInfo & {
        //   return  self.getLineTable();
        //})
        .def("getContentCacheSize", [](const clang::SourceManager& self) -> unsigned long {
           return  self.getContentCacheSize();
        })
        //.def("getMemoryBufferSizes", [](const clang::SourceManager& self) -> clang::SourceManager::MemoryBufferSizes {
        //   return  self.getMemoryBufferSizes();
        //})
        .def("getDataStructureSizes", [](const clang::SourceManager& self) -> unsigned long {
           return  self.getDataStructureSizes();
        })
        //.def("translateFileLineCol", [](const clang::SourceManager& self, const clang::FileEntry * SourceFile , unsigned int Line , unsigned int Col) -> clang::SourceLocation {
        //   return  self.translateFileLineCol(SourceFile, Line, Col);
        //})
        //.def("translateFile", [](const clang::SourceManager& self, const clang::FileEntry * SourceFile) -> clang::FileID {
        //   return  self.translateFile(SourceFile);
        //})
        //.def("translateLineCol", [](const clang::SourceManager& self, clang::FileID FID , unsigned int Line , unsigned int Col) -> clang::SourceLocation {
        //   return  self.translateLineCol(FID, Line, Col);
        //})
        .def("getMacroArgExpandedLocation", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> clang::SourceLocation {
           return  self.getMacroArgExpandedLocation(Loc);
        })
        .def("isBeforeInTranslationUnit", [](const clang::SourceManager& self, clang::SourceLocation LHS , clang::SourceLocation RHS) -> bool {
           return  self.isBeforeInTranslationUnit(LHS, RHS);
        })
        .def("isBeforeInSLocAddrSpace", [](const clang::SourceManager& self, clang::SourceLocation LHS , clang::SourceLocation RHS) -> bool {
           return  self.isBeforeInSLocAddrSpace(LHS, RHS);
        })
        .def("isBeforeInSLocAddrSpace", [](const clang::SourceManager& self, clang::SourceLocation LHS , unsigned int RHS) -> bool {
           return  self.isBeforeInSLocAddrSpace(LHS, RHS);
        })
        //.def("hasFileInfo", [](const clang::SourceManager& self, const clang::FileEntry * File) -> bool {
        //   return  self.hasFileInfo(File);
        //})
        .def("PrintStats", [](const clang::SourceManager& self)  {
             self.PrintStats();
        })
        .def("dump", [](const clang::SourceManager& self)  {
             self.dump();
        })
        .def("local_sloc_entry_size", [](const clang::SourceManager& self) -> unsigned int {
           return  self.local_sloc_entry_size();
        })
        //.def("getLocalSLocEntry", [](const clang::SourceManager& self, unsigned int Index , bool * Invalid) -> const clang::SrcMgr::SLocEntry & {
        //   return  self.getLocalSLocEntry(Index, Invalid);
        //})
        .def("loaded_sloc_entry_size", [](const clang::SourceManager& self) -> unsigned int {
           return  self.loaded_sloc_entry_size();
        })
        //.def("getLoadedSLocEntry", [](const clang::SourceManager& self, unsigned int Index , bool * Invalid) -> const clang::SrcMgr::SLocEntry & {
        //   return  self.getLoadedSLocEntry(Index, Invalid);
        //})
        //.def("getSLocEntry", [](const clang::SourceManager& self, clang::FileID FID , bool * Invalid) -> const clang::SrcMgr::SLocEntry & {
        //   return  self.getSLocEntry(FID, Invalid);
        //})
        .def("getNextLocalOffset", [](const clang::SourceManager& self) -> unsigned int {
           return  self.getNextLocalOffset();
        })
        //.def("setExternalSLocEntrySource", []( clang::SourceManager& self, clang::ExternalSLocEntrySource * Source)  {
        //     self.setExternalSLocEntrySource(Source);
        //})
        //.def("AllocateLoadedSLocEntries", []( clang::SourceManager& self, unsigned int NumSLocEntries , unsigned int TotalSize) -> std::pair<int, unsigned int> {
        //   return  self.AllocateLoadedSLocEntries(NumSLocEntries, TotalSize);
        //})
        .def("isLoadedSourceLocation", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> bool {
           return  self.isLoadedSourceLocation(Loc);
        })
        .def("isLocalSourceLocation", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> bool {
           return  self.isLocalSourceLocation(Loc);
        })
        //.def("isLoadedFileID", [](const clang::SourceManager& self, clang::FileID FID) -> bool {
        //   return  self.isLoadedFileID(FID);
        //})
        //.def("isLocalFileID", [](const clang::SourceManager& self, clang::FileID FID) -> bool {
        //   return  self.isLocalFileID(FID);
        //})
        .def("getImmediateMacroCallerLoc", [](const clang::SourceManager& self, clang::SourceLocation Loc) -> clang::SourceLocation {
           return  self.getImmediateMacroCallerLoc(Loc);
        })
    ;

    py::class_<clang::ASTContext>(m, "ASTContext" )
        //.def("getParents", []( clang::ASTContext& self, const clang::ast_type_traits::DynTypedNode & Node) -> clang::ASTContext::DynTypedNodeList {
        //   return  self.getParents(Node);
        //})
        //.def("getPrintingPolicy", [](const clang::ASTContext& self) -> const clang::PrintingPolicy & {
        //   return  self.getPrintingPolicy();
        //})
        //.def("setPrintingPolicy", []( clang::ASTContext& self, const clang::PrintingPolicy & Policy)  {
        //     self.setPrintingPolicy(Policy);
        //})
        .def("getSourceManager", []( clang::ASTContext& self) -> clang::SourceManager & {
           return  self.getSourceManager();
        })
        .def("getSourceManager", [](const clang::ASTContext& self) -> const clang::SourceManager & {
           return  self.getSourceManager();
        })
        //.def("getAllocator", [](const clang::ASTContext& self) -> llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096, 4096> & {
        //   return  self.getAllocator();
        //})
        .def("Deallocate", [](const clang::ASTContext& self, void * Ptr)  {
             self.Deallocate(Ptr);
        })
        .def("getASTAllocatedMemory", [](const clang::ASTContext& self) -> unsigned long {
           return  self.getASTAllocatedMemory();
        })
        .def("getSideTableAllocatedMemory", [](const clang::ASTContext& self) -> unsigned long {
           return  self.getSideTableAllocatedMemory();
        })
        //.def("getDiagAllocator", []( clang::ASTContext& self) -> clang::PartialDiagnostic::StorageAllocator & {
        //   return  self.getDiagAllocator();
        //})
        //.def("getTargetInfo", [](const clang::ASTContext& self) -> const clang::TargetInfo & {
        //   return  self.getTargetInfo();
        //})
        //.def("getAuxTargetInfo", [](const clang::ASTContext& self) -> const clang::TargetInfo * {
        //   return  self.getAuxTargetInfo();
        //})
        .def("getIntTypeForBitwidth", [](const clang::ASTContext& self, unsigned int DestWidth , unsigned int Signed) -> clang::QualType {
           return  self.getIntTypeForBitwidth(DestWidth, Signed);
        })
        .def("getRealTypeForBitwidth", [](const clang::ASTContext& self, unsigned int DestWidth) -> clang::QualType {
           return  self.getRealTypeForBitwidth(DestWidth);
        })
        .def("AtomicUsesUnsupportedLibcall", [](const clang::ASTContext& self, const clang::AtomicExpr * E) -> bool {
           return  self.AtomicUsesUnsupportedLibcall(E);
        })
        //.def("getLangOpts", [](const clang::ASTContext& self) -> const clang::LangOptions & {
        //   return  self.getLangOpts();
        //})
        //.def("getSanitizerBlacklist", [](const clang::ASTContext& self) -> const clang::SanitizerBlacklist & {
        //   return  self.getSanitizerBlacklist();
        //})
        //.def("getDiagnostics", [](const clang::ASTContext& self) -> clang::DiagnosticsEngine & {
        //   return  self.getDiagnostics();
        //})
        //.def("getFullLoc", [](const clang::ASTContext& self, clang::SourceLocation Loc) -> clang::FullSourceLoc {
        //   return  self.getFullLoc(Loc);
        //})
        //.def("getRawCommentForDeclNoCache", [](const clang::ASTContext& self, const clang::Decl * D) -> clang::RawComment * {
        //   return  self.getRawCommentForDeclNoCache(D);
        //})
        //.def("getRawCommentList", []( clang::ASTContext& self) -> clang::RawCommentList & {
        //   return  self.getRawCommentList();
        //})
        //.def("addComment", []( clang::ASTContext& self, const clang::RawComment & RC)  {
        //     self.addComment(RC);
        //})
        //.def("getCommentForDecl", [](const clang::ASTContext& self, const clang::Decl * D , const clang::Preprocessor * PP) -> clang::comments::FullComment * {
        //   return  self.getCommentForDecl(D, PP);
        //})
        //.def("getLocalCommentForDeclUncached", [](const clang::ASTContext& self, const clang::Decl * D) -> clang::comments::FullComment * {
        //   return  self.getLocalCommentForDeclUncached(D);
        //})
        //.def("cloneFullComment", [](const clang::ASTContext& self, clang::comments::FullComment * FC , const clang::Decl * D) -> clang::comments::FullComment * {
        //   return  self.cloneFullComment(FC, D);
        //})
        //.def("getCommentCommandTraits", [](const clang::ASTContext& self) -> clang::comments::CommandTraits & {
        //   return  self.getCommentCommandTraits();
        //})
        //.def("getDeclAttrs", []( clang::ASTContext& self, const clang::Decl * D) -> llvm::SmallVector<clang::Attr *, 2> & {
        //   return  self.getDeclAttrs(D);
        //})
        .def("eraseDeclAttrs", []( clang::ASTContext& self, const clang::Decl * D)  {
             self.eraseDeclAttrs(D);
        })
        //.def("getInstantiatedFromStaticDataMember", []( clang::ASTContext& self, const clang::VarDecl * Var) -> clang::MemberSpecializationInfo * {
        //   return  self.getInstantiatedFromStaticDataMember(Var);
        //})
        //.def("getTemplateOrSpecializationInfo", []( clang::ASTContext& self, const clang::VarDecl * Var) -> llvm::PointerUnion<clang::VarTemplateDecl *, clang::MemberSpecializationInfo *> {
        //   return  self.getTemplateOrSpecializationInfo(Var);
        //})
        .def("getClassScopeSpecializationPattern", []( clang::ASTContext& self, const clang::FunctionDecl * FD) -> clang::FunctionDecl * {
           return  self.getClassScopeSpecializationPattern(FD);
        })
        .def("setClassScopeSpecializationPattern", []( clang::ASTContext& self, clang::FunctionDecl * FD , clang::FunctionDecl * Pattern)  {
             self.setClassScopeSpecializationPattern(FD, Pattern);
        })
        .def("setInstantiatedFromStaticDataMember", []( clang::ASTContext& self, clang::VarDecl * Inst , clang::VarDecl * Tmpl , clang::TemplateSpecializationKind TSK , clang::SourceLocation PointOfInstantiation)  {
             self.setInstantiatedFromStaticDataMember(Inst, Tmpl, TSK, PointOfInstantiation);
        })
        //.def("setTemplateOrSpecializationInfo", []( clang::ASTContext& self, clang::VarDecl * Inst , llvm::PointerUnion<clang::VarTemplateDecl *, clang::MemberSpecializationInfo *> TSI)  {
        //     self.setTemplateOrSpecializationInfo(Inst, TSI);
        //})
        .def("getInstantiatedFromUsingDecl", []( clang::ASTContext& self, clang::UsingDecl * Inst) -> clang::NamedDecl * {
           return  self.getInstantiatedFromUsingDecl(Inst);
        })
        .def("setInstantiatedFromUsingDecl", []( clang::ASTContext& self, clang::UsingDecl * Inst , clang::NamedDecl * Pattern)  {
             self.setInstantiatedFromUsingDecl(Inst, Pattern);
        })
        .def("setInstantiatedFromUsingShadowDecl", []( clang::ASTContext& self, clang::UsingShadowDecl * Inst , clang::UsingShadowDecl * Pattern)  {
             self.setInstantiatedFromUsingShadowDecl(Inst, Pattern);
        })
        .def("getInstantiatedFromUsingShadowDecl", []( clang::ASTContext& self, clang::UsingShadowDecl * Inst) -> clang::UsingShadowDecl * {
           return  self.getInstantiatedFromUsingShadowDecl(Inst);
        })
        .def("getInstantiatedFromUnnamedFieldDecl", []( clang::ASTContext& self, clang::FieldDecl * Field) -> clang::FieldDecl * {
           return  self.getInstantiatedFromUnnamedFieldDecl(Field);
        })
        .def("setInstantiatedFromUnnamedFieldDecl", []( clang::ASTContext& self, clang::FieldDecl * Inst , clang::FieldDecl * Tmpl)  {
             self.setInstantiatedFromUnnamedFieldDecl(Inst, Tmpl);
        })
        .def("overridden_methods_size", [](const clang::ASTContext& self, const clang::CXXMethodDecl * Method) -> unsigned int {
           return  self.overridden_methods_size(Method);
        })
        //.def("overridden_methods", [](const clang::ASTContext& self, const clang::CXXMethodDecl * Method) -> llvm::iterator_range<const clang::CXXMethodDecl *const *> {
        //   return  self.overridden_methods(Method);
        //})
        .def("addOverriddenMethod", []( clang::ASTContext& self, const clang::CXXMethodDecl * Method , const clang::CXXMethodDecl * Overridden)  {
             self.addOverriddenMethod(Method, Overridden);
        })
        //.def("getOverriddenMethods", [](const clang::ASTContext& self, const clang::NamedDecl * Method , llvm::SmallVectorImpl<const clang::NamedDecl *> & Overridden)  {
        //     self.getOverriddenMethods(Method, Overridden);
        //})
        .def("addedLocalImportDecl", []( clang::ASTContext& self, clang::ImportDecl * Import)  {
             self.addedLocalImportDecl(Import);
        })
        //.def("local_imports", [](const clang::ASTContext& self) -> llvm::iterator_range<clang::ASTContext::import_iterator> {
        //   return  self.local_imports();
        //})
        .def("getPrimaryMergedDecl", []( clang::ASTContext& self, clang::Decl * D) -> clang::Decl * {
           return  self.getPrimaryMergedDecl(D);
        })
        .def("setPrimaryMergedDecl", []( clang::ASTContext& self, clang::Decl * D , clang::Decl * Primary)  {
             self.setPrimaryMergedDecl(D, Primary);
        })
        //.def("mergeDefinitionIntoModule", []( clang::ASTContext& self, clang::NamedDecl * ND , clang::Module * M , bool NotifyListeners)  {
        //     self.mergeDefinitionIntoModule(ND, M, NotifyListeners);
        //})
        .def("deduplicateMergedDefinitonsFor", []( clang::ASTContext& self, clang::NamedDecl * ND)  {
             self.deduplicateMergedDefinitonsFor(ND);
        })
        //.def("getModulesWithMergedDefinition", []( clang::ASTContext& self, clang::NamedDecl * Def) -> llvm::ArrayRef<clang::Module *> {
        //   return  self.getModulesWithMergedDefinition(Def);
        //})
        .def("getTranslationUnitDecl", [](const clang::ASTContext& self) -> clang::TranslationUnitDecl * {
           return  self.getTranslationUnitDecl();
        })
        .def("getExternCContextDecl", [](const clang::ASTContext& self) -> clang::ExternCContextDecl * {
           return  self.getExternCContextDecl();
        })
        .def("getMakeIntegerSeqDecl", [](const clang::ASTContext& self) -> clang::BuiltinTemplateDecl * {
           return  self.getMakeIntegerSeqDecl();
        })
        .def("getTypePackElementDecl", [](const clang::ASTContext& self) -> clang::BuiltinTemplateDecl * {
           return  self.getTypePackElementDecl();
        })
        //.def("setExternalSource", []( clang::ASTContext& self, llvm::IntrusiveRefCntPtr<clang::ExternalASTSource> Source)  {
        //     self.setExternalSource(Source);
        //})
        //.def("getExternalSource", [](const clang::ASTContext& self) -> clang::ExternalASTSource * {
        //   return  self.getExternalSource();
        //})
        //.def("setASTMutationListener", []( clang::ASTContext& self, clang::ASTMutationListener * Listener)  {
        //     self.setASTMutationListener(Listener);
        //})
        //.def("getASTMutationListener", [](const clang::ASTContext& self) -> clang::ASTMutationListener * {
        //   return  self.getASTMutationListener();
        //})
        .def("PrintStats", [](const clang::ASTContext& self)  {
             self.PrintStats();
        })
        //.def("getTypes", [](const clang::ASTContext& self) -> const llvm::SmallVectorImpl<clang::Type *> & {
        //   return  self.getTypes();
        //})
        //.def("buildBuiltinTemplateDecl", [](const clang::ASTContext& self, clang::BuiltinTemplateKind BTK , const clang::IdentifierInfo * II) -> clang::BuiltinTemplateDecl * {
        //   return  self.buildBuiltinTemplateDecl(BTK, II);
        //})
        //.def("buildImplicitRecord", [](const clang::ASTContext& self, llvm::StringRef Name , clang::TagTypeKind TK) -> clang::RecordDecl * {
        //   return  self.buildImplicitRecord(Name, TK);
        //})
        .def("buildImplicitTypedef", [](const clang::ASTContext& self, clang::QualType T , llvm::StringRef Name) -> clang::TypedefDecl * {
           return  self.buildImplicitTypedef(T, Name);
        })
        .def("getInt128Decl", [](const clang::ASTContext& self) -> clang::TypedefDecl * {
           return  self.getInt128Decl();
        })
        .def("getUInt128Decl", [](const clang::ASTContext& self) -> clang::TypedefDecl * {
           return  self.getUInt128Decl();
        })
        .def("getAddrSpaceQualType", [](const clang::ASTContext& self, clang::QualType T , unsigned int AddressSpace) -> clang::QualType {
           return  self.getAddrSpaceQualType(T, AddressSpace);
        })
        .def("getObjCGCQualType", [](const clang::ASTContext& self, clang::QualType T , clang::Qualifiers::GC gcAttr) -> clang::QualType {
           return  self.getObjCGCQualType(T, gcAttr);
        })
        .def("getRestrictType", [](const clang::ASTContext& self, clang::QualType T) -> clang::QualType {
           return  self.getRestrictType(T);
        })
        .def("getVolatileType", [](const clang::ASTContext& self, clang::QualType T) -> clang::QualType {
           return  self.getVolatileType(T);
        })
        .def("getConstType", [](const clang::ASTContext& self, clang::QualType T) -> clang::QualType {
           return  self.getConstType(T);
        })
        //.def("adjustFunctionType", []( clang::ASTContext& self, const clang::FunctionType * Fn , clang::FunctionType::ExtInfo EInfo) -> const clang::FunctionType * {
        //   return  self.adjustFunctionType(Fn, EInfo);
        //})
        //.def("getCanonicalFunctionResultType", [](const clang::ASTContext& self, clang::QualType ResultType) -> clang::CanQual<clang::Type> {
        //   return  self.getCanonicalFunctionResultType(ResultType);
        //})
        .def("adjustDeducedFunctionResultType", []( clang::ASTContext& self, clang::FunctionDecl * FD , clang::QualType ResultType)  {
             self.adjustDeducedFunctionResultType(FD, ResultType);
        })
        //.def("adjustExceptionSpec", []( clang::ASTContext& self, clang::FunctionDecl * FD , const clang::FunctionProtoType::ExceptionSpecInfo & ESI , bool AsWritten)  {
        //     self.adjustExceptionSpec(FD, ESI, AsWritten);
        //})
        .def("getComplexType", [](const clang::ASTContext& self, clang::QualType T) -> clang::QualType {
           return  self.getComplexType(T);
        })
        //.def("getComplexType", [](const clang::ASTContext& self, clang::CanQual<clang::Type> T) -> clang::CanQual<clang::Type> {
        //   return  self.getComplexType(T);
        //})
        .def("getPointerType", [](const clang::ASTContext& self, clang::QualType T) -> clang::QualType {
           return  self.getPointerType(T);
        })
        //.def("getPointerType", [](const clang::ASTContext& self, clang::CanQual<clang::Type> T) -> clang::CanQual<clang::Type> {
        //   return  self.getPointerType(T);
        //})
        .def("getAdjustedType", [](const clang::ASTContext& self, clang::QualType Orig , clang::QualType New) -> clang::QualType {
           return  self.getAdjustedType(Orig, New);
        })
        //.def("getAdjustedType", [](const clang::ASTContext& self, clang::CanQual<clang::Type> Orig , clang::CanQual<clang::Type> New) -> clang::CanQual<clang::Type> {
        //   return  self.getAdjustedType(Orig, New);
        //})
        .def("getDecayedType", [](const clang::ASTContext& self, clang::QualType T) -> clang::QualType {
           return  self.getDecayedType(T);
        })
        //.def("getDecayedType", [](const clang::ASTContext& self, clang::CanQual<clang::Type> T) -> clang::CanQual<clang::Type> {
        //   return  self.getDecayedType(T);
        //})
        .def("getAtomicType", [](const clang::ASTContext& self, clang::QualType T) -> clang::QualType {
           return  self.getAtomicType(T);
        })
        .def("getBlockPointerType", [](const clang::ASTContext& self, clang::QualType T) -> clang::QualType {
           return  self.getBlockPointerType(T);
        })
        .def("getBlockDescriptorType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getBlockDescriptorType();
        })
        .def("getPipeType", [](const clang::ASTContext& self, clang::QualType T) -> clang::QualType {
           return  self.getPipeType(T);
        })
        .def("getBlockDescriptorExtendedType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getBlockDescriptorExtendedType();
        })
        .def("setcudaConfigureCallDecl", []( clang::ASTContext& self, clang::FunctionDecl * FD)  {
             self.setcudaConfigureCallDecl(FD);
        })
        .def("getcudaConfigureCallDecl", []( clang::ASTContext& self) -> clang::FunctionDecl * {
           return  self.getcudaConfigureCallDecl();
        })
        .def("BlockRequiresCopying", []( clang::ASTContext& self, clang::QualType Ty , const clang::VarDecl * D) -> bool {
           return  self.BlockRequiresCopying(Ty, D);
        })
        .def("getByrefLifetime", [](const clang::ASTContext& self, clang::QualType Ty , clang::Qualifiers::ObjCLifetime & Lifetime , bool & HasByrefExtendedLayout) -> bool {
           return  self.getByrefLifetime(Ty, Lifetime, HasByrefExtendedLayout);
        })
        .def("getLValueReferenceType", [](const clang::ASTContext& self, clang::QualType T , bool SpelledAsLValue) -> clang::QualType {
           return  self.getLValueReferenceType(T, SpelledAsLValue);
        })
        .def("getRValueReferenceType", [](const clang::ASTContext& self, clang::QualType T) -> clang::QualType {
           return  self.getRValueReferenceType(T);
        })
        .def("getMemberPointerType", [](const clang::ASTContext& self, clang::QualType T , const clang::Type * Cls) -> clang::QualType {
           return  self.getMemberPointerType(T, Cls);
        })
        //.def("getVariableArrayType", [](const clang::ASTContext& self, clang::QualType EltTy , clang::Expr * NumElts , clang::ArrayType::ArraySizeModifier ASM , unsigned int IndexTypeQuals , clang::SourceRange Brackets) -> clang::QualType {
        //   return  self.getVariableArrayType(EltTy, NumElts, ASM, IndexTypeQuals, Brackets);
        //})
        //.def("getDependentSizedArrayType", [](const clang::ASTContext& self, clang::QualType EltTy , clang::Expr * NumElts , clang::ArrayType::ArraySizeModifier ASM , unsigned int IndexTypeQuals , clang::SourceRange Brackets) -> clang::QualType {
        //   return  self.getDependentSizedArrayType(EltTy, NumElts, ASM, IndexTypeQuals, Brackets);
        //})
        //.def("getIncompleteArrayType", [](const clang::ASTContext& self, clang::QualType EltTy , clang::ArrayType::ArraySizeModifier ASM , unsigned int IndexTypeQuals) -> clang::QualType {
        //   return  self.getIncompleteArrayType(EltTy, ASM, IndexTypeQuals);
        //})
        //.def("getConstantArrayType", [](const clang::ASTContext& self, clang::QualType EltTy , const llvm::APInt & ArySize , clang::ArrayType::ArraySizeModifier ASM , unsigned int IndexTypeQuals) -> clang::QualType {
        //   return  self.getConstantArrayType(EltTy, ArySize, ASM, IndexTypeQuals);
        //})
        .def("getVariableArrayDecayedType", [](const clang::ASTContext& self, clang::QualType Ty) -> clang::QualType {
           return  self.getVariableArrayDecayedType(Ty);
        })
        //.def("getVectorType", [](const clang::ASTContext& self, clang::QualType VectorType , unsigned int NumElts , clang::VectorType::VectorKind VecKind) -> clang::QualType {
        //   return  self.getVectorType(VectorType, NumElts, VecKind);
        //})
        .def("getExtVectorType", [](const clang::ASTContext& self, clang::QualType VectorType , unsigned int NumElts) -> clang::QualType {
           return  self.getExtVectorType(VectorType, NumElts);
        })
        .def("getDependentSizedExtVectorType", [](const clang::ASTContext& self, clang::QualType VectorType , clang::Expr * SizeExpr , clang::SourceLocation AttrLoc) -> clang::QualType {
           return  self.getDependentSizedExtVectorType(VectorType, SizeExpr, AttrLoc);
        })
        //.def("getFunctionNoProtoType", [](const clang::ASTContext& self, clang::QualType ResultTy , const clang::FunctionType::ExtInfo & Info) -> clang::QualType {
        //   return  self.getFunctionNoProtoType(ResultTy, Info);
        //})
        .def("getFunctionNoProtoType", [](const clang::ASTContext& self, clang::QualType ResultTy) -> clang::QualType {
           return  self.getFunctionNoProtoType(ResultTy);
        })
        //.def("getFunctionType", [](const clang::ASTContext& self, clang::QualType ResultTy , llvm::ArrayRef<clang::QualType> Args , const clang::FunctionProtoType::ExtProtoInfo & EPI) -> clang::QualType {
        //   return  self.getFunctionType(ResultTy, Args, EPI);
        //})
        .def("getTypeDeclType", [](const clang::ASTContext& self, const clang::TypeDecl * Decl , const clang::TypeDecl * PrevDecl) -> clang::QualType {
           return  self.getTypeDeclType(Decl, PrevDecl);
        })
        .def("getTypedefType", [](const clang::ASTContext& self, const clang::TypedefNameDecl * Decl , clang::QualType Canon) -> clang::QualType {
           return  self.getTypedefType(Decl, Canon);
        })
        .def("getRecordType", [](const clang::ASTContext& self, const clang::RecordDecl * Decl) -> clang::QualType {
           return  self.getRecordType(Decl);
        })
        .def("getEnumType", [](const clang::ASTContext& self, const clang::EnumDecl * Decl) -> clang::QualType {
           return  self.getEnumType(Decl);
        })
        .def("getInjectedClassNameType", [](const clang::ASTContext& self, clang::CXXRecordDecl * Decl , clang::QualType TST) -> clang::QualType {
           return  self.getInjectedClassNameType(Decl, TST);
        })
        //.def("getAttributedType", []( clang::ASTContext& self, clang::AttributedType::Kind attrKind , clang::QualType modifiedType , clang::QualType equivalentType) -> clang::QualType {
        //   return  self.getAttributedType(attrKind, modifiedType, equivalentType);
        //})
        //.def("getSubstTemplateTypeParmType", [](const clang::ASTContext& self, const clang::TemplateTypeParmType * Replaced , clang::QualType Replacement) -> clang::QualType {
        //   return  self.getSubstTemplateTypeParmType(Replaced, Replacement);
        //})
        //.def("getSubstTemplateTypeParmPackType", []( clang::ASTContext& self, const clang::TemplateTypeParmType * Replaced , const clang::TemplateArgument & ArgPack) -> clang::QualType {
        //   return  self.getSubstTemplateTypeParmPackType(Replaced, ArgPack);
        //})
        .def("getTemplateTypeParmType", [](const clang::ASTContext& self, unsigned int Depth , unsigned int Index , bool ParameterPack , clang::TemplateTypeParmDecl * ParmDecl) -> clang::QualType {
           return  self.getTemplateTypeParmType(Depth, Index, ParameterPack, ParmDecl);
        })
        //.def("getTemplateSpecializationType", [](const clang::ASTContext& self, clang::TemplateName T , const clang::TemplateArgument * Args , unsigned int NumArgs , clang::QualType Canon) -> clang::QualType {
        //   return  self.getTemplateSpecializationType(T, Args, NumArgs, Canon);
        //})
        //.def("getCanonicalTemplateSpecializationType", [](const clang::ASTContext& self, clang::TemplateName T , const clang::TemplateArgument * Args , unsigned int NumArgs) -> clang::QualType {
        //   return  self.getCanonicalTemplateSpecializationType(T, Args, NumArgs);
        //})
        //.def("getTemplateSpecializationType", [](const clang::ASTContext& self, clang::TemplateName T , const clang::TemplateArgumentListInfo & Args , clang::QualType Canon) -> clang::QualType {
        //   return  self.getTemplateSpecializationType(T, Args, Canon);
        //})
        //.def("getTemplateSpecializationTypeInfo", [](const clang::ASTContext& self, clang::TemplateName T , clang::SourceLocation TLoc , const clang::TemplateArgumentListInfo & Args , clang::QualType Canon) -> clang::TypeSourceInfo * {
        //   return  self.getTemplateSpecializationTypeInfo(T, TLoc, Args, Canon);
        //})
        .def("getParenType", [](const clang::ASTContext& self, clang::QualType NamedType) -> clang::QualType {
           return  self.getParenType(NamedType);
        })
        //.def("getElaboratedType", [](const clang::ASTContext& self, clang::ElaboratedTypeKeyword Keyword , clang::NestedNameSpecifier * NNS , clang::QualType NamedType) -> clang::QualType {
        //   return  self.getElaboratedType(Keyword, NNS, NamedType);
        //})
        //.def("getDependentNameType", [](const clang::ASTContext& self, clang::ElaboratedTypeKeyword Keyword , clang::NestedNameSpecifier * NNS , const clang::IdentifierInfo * Name , clang::QualType Canon) -> clang::QualType {
        //   return  self.getDependentNameType(Keyword, NNS, Name, Canon);
        //})
        //.def("getDependentTemplateSpecializationType", [](const clang::ASTContext& self, clang::ElaboratedTypeKeyword Keyword , clang::NestedNameSpecifier * NNS , const clang::IdentifierInfo * Name , const clang::TemplateArgumentListInfo & Args) -> clang::QualType {
        //   return  self.getDependentTemplateSpecializationType(Keyword, NNS, Name, Args);
        //})
        //.def("getDependentTemplateSpecializationType", [](const clang::ASTContext& self, clang::ElaboratedTypeKeyword Keyword , clang::NestedNameSpecifier * NNS , const clang::IdentifierInfo * Name , unsigned int NumArgs , const clang::TemplateArgument * Args) -> clang::QualType {
        //   return  self.getDependentTemplateSpecializationType(Keyword, NNS, Name, NumArgs, Args);
        //})
        //.def("getPackExpansionType", []( clang::ASTContext& self, clang::QualType Pattern , llvm::Optional<unsigned int> NumExpansions) -> clang::QualType {
        //   return  self.getPackExpansionType(Pattern, NumExpansions);
        //})
        //.def("getObjCInterfaceType", [](const clang::ASTContext& self, const clang::ObjCInterfaceDecl * Decl , clang::ObjCInterfaceDecl * PrevDecl) -> clang::QualType {
        //   return  self.getObjCInterfaceType(Decl, PrevDecl);
        //})
        //.def("getObjCObjectType", [](const clang::ASTContext& self, clang::QualType Base , llvm::ArrayRef<clang::QualType> typeArgs , llvm::ArrayRef<clang::ObjCProtocolDecl *> protocols , bool isKindOf) -> clang::QualType {
        //   return  self.getObjCObjectType(Base, typeArgs, protocols, isKindOf);
        //})
        //.def("ObjCObjectAdoptsQTypeProtocols", []( clang::ASTContext& self, clang::QualType QT , clang::ObjCInterfaceDecl * Decl) -> bool {
        //   return  self.ObjCObjectAdoptsQTypeProtocols(QT, Decl);
        //})
        //.def("QIdProtocolsAdoptObjCObjectProtocols", []( clang::ASTContext& self, clang::QualType QT , clang::ObjCInterfaceDecl * IDecl) -> bool {
        //   return  self.QIdProtocolsAdoptObjCObjectProtocols(QT, IDecl);
        //})
        .def("getObjCObjectPointerType", [](const clang::ASTContext& self, clang::QualType OIT) -> clang::QualType {
           return  self.getObjCObjectPointerType(OIT);
        })
        .def("getTypeOfExprType", [](const clang::ASTContext& self, clang::Expr * e) -> clang::QualType {
           return  self.getTypeOfExprType(e);
        })
        .def("getTypeOfType", [](const clang::ASTContext& self, clang::QualType t) -> clang::QualType {
           return  self.getTypeOfType(t);
        })
        .def("getDecltypeType", [](const clang::ASTContext& self, clang::Expr * e , clang::QualType UnderlyingType) -> clang::QualType {
           return  self.getDecltypeType(e, UnderlyingType);
        })
        //.def("getUnaryTransformType", [](const clang::ASTContext& self, clang::QualType BaseType , clang::QualType UnderlyingType , clang::UnaryTransformType::UTTKind UKind) -> clang::QualType {
        //   return  self.getUnaryTransformType(BaseType, UnderlyingType, UKind);
        //})
        .def("getAutoType", [](const clang::ASTContext& self, clang::QualType DeducedType , clang::AutoTypeKeyword Keyword , bool IsDependent) -> clang::QualType {
           return  self.getAutoType(DeducedType, Keyword, IsDependent);
        })
        .def("getAutoDeductType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getAutoDeductType();
        })
        .def("getAutoRRefDeductType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getAutoRRefDeductType();
        })
        .def("getTagDeclType", [](const clang::ASTContext& self, const clang::TagDecl * Decl) -> clang::QualType {
           return  self.getTagDeclType(Decl);
        })
        //.def("getSizeType", [](const clang::ASTContext& self) -> clang::CanQual<clang::Type> {
        //   return  self.getSizeType();
        //})
        //.def("getIntMaxType", [](const clang::ASTContext& self) -> clang::CanQual<clang::Type> {
        //   return  self.getIntMaxType();
        //})
        //.def("getUIntMaxType", [](const clang::ASTContext& self) -> clang::CanQual<clang::Type> {
        //   return  self.getUIntMaxType();
        //})
        .def("getWCharType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getWCharType();
        })
        .def("getWideCharType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getWideCharType();
        })
        .def("getSignedWCharType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getSignedWCharType();
        })
        .def("getUnsignedWCharType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getUnsignedWCharType();
        })
        .def("getWIntType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getWIntType();
        })
        .def("getIntPtrType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getIntPtrType();
        })
        .def("getUIntPtrType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getUIntPtrType();
        })
        .def("getPointerDiffType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getPointerDiffType();
        })
        .def("getProcessIDType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getProcessIDType();
        })
        .def("getCFConstantStringType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getCFConstantStringType();
        })
        .def("getObjCSuperType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getObjCSuperType();
        })
        .def("setObjCSuperType", []( clang::ASTContext& self, clang::QualType ST)  {
             self.setObjCSuperType(ST);
        })
        .def("getRawCFConstantStringType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getRawCFConstantStringType();
        })
        .def("setCFConstantStringType", []( clang::ASTContext& self, clang::QualType T)  {
             self.setCFConstantStringType(T);
        })
        .def("getCFConstantStringDecl", [](const clang::ASTContext& self) -> clang::TypedefDecl * {
           return  self.getCFConstantStringDecl();
        })
        .def("getCFConstantStringTagDecl", [](const clang::ASTContext& self) -> clang::RecordDecl * {
           return  self.getCFConstantStringTagDecl();
        })
        //.def("setObjCConstantStringInterface", []( clang::ASTContext& self, clang::ObjCInterfaceDecl * Decl)  {
        //     self.setObjCConstantStringInterface(Decl);
        //})
        .def("getObjCConstantStringInterface", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getObjCConstantStringInterface();
        })
        .def("getObjCNSStringType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getObjCNSStringType();
        })
        .def("setObjCNSStringType", []( clang::ASTContext& self, clang::QualType T)  {
             self.setObjCNSStringType(T);
        })
        .def("getObjCIdRedefinitionType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getObjCIdRedefinitionType();
        })
        .def("setObjCIdRedefinitionType", []( clang::ASTContext& self, clang::QualType RedefType)  {
             self.setObjCIdRedefinitionType(RedefType);
        })
        .def("getObjCClassRedefinitionType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getObjCClassRedefinitionType();
        })
        .def("setObjCClassRedefinitionType", []( clang::ASTContext& self, clang::QualType RedefType)  {
             self.setObjCClassRedefinitionType(RedefType);
        })
        .def("getObjCSelRedefinitionType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getObjCSelRedefinitionType();
        })
        .def("setObjCSelRedefinitionType", []( clang::ASTContext& self, clang::QualType RedefType)  {
             self.setObjCSelRedefinitionType(RedefType);
        })
        //.def("getNSObjectName", []( clang::ASTContext& self) -> clang::IdentifierInfo * {
        //   return  self.getNSObjectName();
        //})
        //.def("getNSCopyingName", []( clang::ASTContext& self) -> clang::IdentifierInfo * {
        //   return  self.getNSCopyingName();
        //})
        //.def("getBoolName", [](const clang::ASTContext& self) -> clang::IdentifierInfo * {
        //   return  self.getBoolName();
        //})
        //.def("getMakeIntegerSeqName", [](const clang::ASTContext& self) -> clang::IdentifierInfo * {
        //   return  self.getMakeIntegerSeqName();
        //})
        //.def("getTypePackElementName", [](const clang::ASTContext& self) -> clang::IdentifierInfo * {
        //   return  self.getTypePackElementName();
        //})
        .def("getObjCInstanceType", []( clang::ASTContext& self) -> clang::QualType {
           return  self.getObjCInstanceType();
        })
        .def("getObjCInstanceTypeDecl", []( clang::ASTContext& self) -> clang::TypedefDecl * {
           return  self.getObjCInstanceTypeDecl();
        })
        .def("setFILEDecl", []( clang::ASTContext& self, clang::TypeDecl * FILEDecl)  {
             self.setFILEDecl(FILEDecl);
        })
        .def("getFILEType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getFILEType();
        })
        .def("setjmp_bufDecl", []( clang::ASTContext& self, clang::TypeDecl * jmp_bufDecl)  {
             self.setjmp_bufDecl(jmp_bufDecl);
        })
        .def("getjmp_bufType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getjmp_bufType();
        })
        .def("setsigjmp_bufDecl", []( clang::ASTContext& self, clang::TypeDecl * sigjmp_bufDecl)  {
             self.setsigjmp_bufDecl(sigjmp_bufDecl);
        })
        .def("getsigjmp_bufType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getsigjmp_bufType();
        })
        .def("setucontext_tDecl", []( clang::ASTContext& self, clang::TypeDecl * ucontext_tDecl)  {
             self.setucontext_tDecl(ucontext_tDecl);
        })
        .def("getucontext_tType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getucontext_tType();
        })
        .def("getLogicalOperationType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getLogicalOperationType();
        })
        //.def("getObjCEncodingForType", [](const clang::ASTContext& self, clang::QualType T , std::basic_string<char> & S , const clang::FieldDecl * Field , clang::QualType * NotEncodedT)  {
        //     self.getObjCEncodingForType(T, S, Field, NotEncodedT);
        //})
        //.def("getObjCEncodingForPropertyType", [](const clang::ASTContext& self, clang::QualType T , std::basic_string<char> & S)  {
        //     self.getObjCEncodingForPropertyType(T, S);
        //})
        .def("getLegacyIntegralTypeEncoding", [](const clang::ASTContext& self, clang::QualType & t)  {
             self.getLegacyIntegralTypeEncoding(t);
        })
        //.def("getObjCEncodingForTypeQualifier", [](const clang::ASTContext& self, clang::Decl::ObjCDeclQualifier QT , std::basic_string<char> & S)  {
        //     self.getObjCEncodingForTypeQualifier(QT, S);
        //})
        //.def("getObjCEncodingForFunctionDecl", []( clang::ASTContext& self, const clang::FunctionDecl * Decl , std::basic_string<char> & S) -> bool {
        //   return  self.getObjCEncodingForFunctionDecl(Decl, S);
        //})
        //.def("getObjCEncodingForMethodDecl", [](const clang::ASTContext& self, const clang::ObjCMethodDecl * Decl , std::basic_string<char> & S , bool Extended) -> bool {
        //   return  self.getObjCEncodingForMethodDecl(Decl, S, Extended);
        //})
        //.def("getObjCEncodingForBlock", [](const clang::ASTContext& self, const clang::BlockExpr * blockExpr) -> std::basic_string<char> {
        //   return  self.getObjCEncodingForBlock(blockExpr);
        //})
        //.def("getObjCEncodingForPropertyDecl", [](const clang::ASTContext& self, const clang::ObjCPropertyDecl * PD , const clang::Decl * Container , std::basic_string<char> & S)  {
        //     self.getObjCEncodingForPropertyDecl(PD, Container, S);
        //})
        //.def("ProtocolCompatibleWithProtocol", [](const clang::ASTContext& self, clang::ObjCProtocolDecl * lProto , clang::ObjCProtocolDecl * rProto) -> bool {
        //   return  self.ProtocolCompatibleWithProtocol(lProto, rProto);
        //})
        //.def("getObjCPropertyImplDeclForPropertyDecl", [](const clang::ASTContext& self, const clang::ObjCPropertyDecl * PD , const clang::Decl * Container) -> clang::ObjCPropertyImplDecl * {
        //   return  self.getObjCPropertyImplDeclForPropertyDecl(PD, Container);
        //})
        //.def("getObjCEncodingTypeSize", [](const clang::ASTContext& self, clang::QualType T) -> clang::CharUnits {
        //   return  self.getObjCEncodingTypeSize(T);
        //})
        .def("getObjCIdDecl", [](const clang::ASTContext& self) -> clang::TypedefDecl * {
           return  self.getObjCIdDecl();
        })
        .def("getObjCIdType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getObjCIdType();
        })
        .def("getObjCSelDecl", [](const clang::ASTContext& self) -> clang::TypedefDecl * {
           return  self.getObjCSelDecl();
        })
        .def("getObjCSelType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getObjCSelType();
        })
        .def("getObjCClassDecl", [](const clang::ASTContext& self) -> clang::TypedefDecl * {
           return  self.getObjCClassDecl();
        })
        .def("getObjCClassType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getObjCClassType();
        })
        //.def("getObjCProtocolDecl", [](const clang::ASTContext& self) -> clang::ObjCInterfaceDecl * {
        //   return  self.getObjCProtocolDecl();
        //})
        .def("getBOOLDecl", [](const clang::ASTContext& self) -> clang::TypedefDecl * {
           return  self.getBOOLDecl();
        })
        .def("setBOOLDecl", []( clang::ASTContext& self, clang::TypedefDecl * TD)  {
             self.setBOOLDecl(TD);
        })
        .def("getBOOLType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getBOOLType();
        })
        .def("getObjCProtoType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getObjCProtoType();
        })
        .def("getBuiltinVaListDecl", [](const clang::ASTContext& self) -> clang::TypedefDecl * {
           return  self.getBuiltinVaListDecl();
        })
        .def("getBuiltinVaListType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getBuiltinVaListType();
        })
        .def("getVaListTagDecl", [](const clang::ASTContext& self) -> clang::Decl * {
           return  self.getVaListTagDecl();
        })
        .def("getBuiltinMSVaListDecl", [](const clang::ASTContext& self) -> clang::TypedefDecl * {
           return  self.getBuiltinMSVaListDecl();
        })
        .def("getBuiltinMSVaListType", [](const clang::ASTContext& self) -> clang::QualType {
           return  self.getBuiltinMSVaListType();
        })
        .def("getCVRQualifiedType", [](const clang::ASTContext& self, clang::QualType T , unsigned int CVR) -> clang::QualType {
           return  self.getCVRQualifiedType(T, CVR);
        })
        //.def("getQualifiedType", [](const clang::ASTContext& self, clang::SplitQualType split) -> clang::QualType {
        //   return  self.getQualifiedType(split);
        //})
        .def("getQualifiedType", [](const clang::ASTContext& self, clang::QualType T , clang::Qualifiers Qs) -> clang::QualType {
           return  self.getQualifiedType(T, Qs);
        })
        .def("getQualifiedType", [](const clang::ASTContext& self, const clang::Type * T , clang::Qualifiers Qs) -> clang::QualType {
           return  self.getQualifiedType(T, Qs);
        })
        .def("getLifetimeQualifiedType", []( clang::ASTContext& self, clang::QualType type , clang::Qualifiers::ObjCLifetime lifetime) -> clang::QualType {
           return  self.getLifetimeQualifiedType(type, lifetime);
        })
        .def("getUnqualifiedObjCPointerType", [](const clang::ASTContext& self, clang::QualType type) -> clang::QualType {
           return  self.getUnqualifiedObjCPointerType(type);
        })
        //.def("getNameForTemplate", [](const clang::ASTContext& self, clang::TemplateName Name , clang::SourceLocation NameLoc) -> clang::DeclarationNameInfo {
        //   return  self.getNameForTemplate(Name, NameLoc);
        //})
        //.def("getOverloadedTemplateName", [](const clang::ASTContext& self, clang::UnresolvedSetIterator Begin , clang::UnresolvedSetIterator End) -> clang::TemplateName {
        //   return  self.getOverloadedTemplateName(Begin, End);
        //})
        //.def("getQualifiedTemplateName", [](const clang::ASTContext& self, clang::NestedNameSpecifier * NNS , bool TemplateKeyword , clang::TemplateDecl * Template) -> clang::TemplateName {
        //   return  self.getQualifiedTemplateName(NNS, TemplateKeyword, Template);
        //})
        //.def("getDependentTemplateName", [](const clang::ASTContext& self, clang::NestedNameSpecifier * NNS , const clang::IdentifierInfo * Name) -> clang::TemplateName {
        //   return  self.getDependentTemplateName(NNS, Name);
        //})
        //.def("getDependentTemplateName", [](const clang::ASTContext& self, clang::NestedNameSpecifier * NNS , clang::OverloadedOperatorKind Operator) -> clang::TemplateName {
        //   return  self.getDependentTemplateName(NNS, Operator);
        //})
        //.def("getSubstTemplateTemplateParm", [](const clang::ASTContext& self, clang::TemplateTemplateParmDecl * param , clang::TemplateName replacement) -> clang::TemplateName {
        //   return  self.getSubstTemplateTemplateParm(param, replacement);
        //})
        //.def("getSubstTemplateTemplateParmPack", [](const clang::ASTContext& self, clang::TemplateTemplateParmDecl * Param , const clang::TemplateArgument & ArgPack) -> clang::TemplateName {
        //   return  self.getSubstTemplateTemplateParmPack(Param, ArgPack);
        //})
        .def("GetBuiltinType", [](const clang::ASTContext& self, unsigned int ID , clang::ASTContext::GetBuiltinTypeError & Error , unsigned int * IntegerConstantArgs) -> clang::QualType {
           return  self.GetBuiltinType(ID, Error, IntegerConstantArgs);
        })
        .def("getObjCGCAttrKind", [](const clang::ASTContext& self, clang::QualType Ty) -> clang::Qualifiers::GC {
           return  self.getObjCGCAttrKind(Ty);
        })
        .def("areCompatibleVectorTypes", []( clang::ASTContext& self, clang::QualType FirstVec , clang::QualType SecondVec) -> bool {
           return  self.areCompatibleVectorTypes(FirstVec, SecondVec);
        })
        //.def("getFloatTypeSemantics", [](const clang::ASTContext& self, clang::QualType T) -> const llvm::fltSemantics & {
        //   return  self.getFloatTypeSemantics(T);
        //})
        //.def("getTypeInfo", [](const clang::ASTContext& self, const clang::Type * T) -> clang::TypeInfo {
        //   return  self.getTypeInfo(T);
        //})
        //.def("getTypeInfo", [](const clang::ASTContext& self, clang::QualType T) -> clang::TypeInfo {
        //   return  self.getTypeInfo(T);
        //})
        .def("getOpenMPDefaultSimdAlign", [](const clang::ASTContext& self, clang::QualType T) -> unsigned int {
           return  self.getOpenMPDefaultSimdAlign(T);
        })
        .def("getTypeSize", [](const clang::ASTContext& self, clang::QualType T) -> unsigned long {
           return  self.getTypeSize(T);
        })
        .def("getTypeSize", [](const clang::ASTContext& self, const clang::Type * T) -> unsigned long {
           return  self.getTypeSize(T);
        })
        .def("getCharWidth", [](const clang::ASTContext& self) -> unsigned long {
           return  self.getCharWidth();
        })
        //.def("toCharUnitsFromBits", [](const clang::ASTContext& self, long BitSize) -> clang::CharUnits {
        //   return  self.toCharUnitsFromBits(BitSize);
        //})
        //.def("toBits", [](const clang::ASTContext& self, clang::CharUnits CharSize) -> long {
        //   return  self.toBits(CharSize);
        //})
        //.def("getTypeSizeInChars", [](const clang::ASTContext& self, clang::QualType T) -> clang::CharUnits {
        //   return  self.getTypeSizeInChars(T);
        //})
        //.def("getTypeSizeInChars", [](const clang::ASTContext& self, const clang::Type * T) -> clang::CharUnits {
        //   return  self.getTypeSizeInChars(T);
        //})
        .def("getTypeAlign", [](const clang::ASTContext& self, clang::QualType T) -> unsigned int {
           return  self.getTypeAlign(T);
        })
        .def("getTypeAlign", [](const clang::ASTContext& self, const clang::Type * T) -> unsigned int {
           return  self.getTypeAlign(T);
        })
        //.def("getTypeAlignInChars", [](const clang::ASTContext& self, clang::QualType T) -> clang::CharUnits {
        //   return  self.getTypeAlignInChars(T);
        //})
        //.def("getTypeAlignInChars", [](const clang::ASTContext& self, const clang::Type * T) -> clang::CharUnits {
        //   return  self.getTypeAlignInChars(T);
        //})
        //.def("getTypeInfoDataSizeInChars", [](const clang::ASTContext& self, clang::QualType T) -> std::pair<clang::CharUnits, clang::CharUnits> {
        //   return  self.getTypeInfoDataSizeInChars(T);
        //})
        //.def("getTypeInfoInChars", [](const clang::ASTContext& self, const clang::Type * T) -> std::pair<clang::CharUnits, clang::CharUnits> {
        //   return  self.getTypeInfoInChars(T);
        //})
        //.def("getTypeInfoInChars", [](const clang::ASTContext& self, clang::QualType T) -> std::pair<clang::CharUnits, clang::CharUnits> {
        //   return  self.getTypeInfoInChars(T);
        //})
        .def("isAlignmentRequired", [](const clang::ASTContext& self, const clang::Type * T) -> bool {
           return  self.isAlignmentRequired(T);
        })
        .def("isAlignmentRequired", [](const clang::ASTContext& self, clang::QualType T) -> bool {
           return  self.isAlignmentRequired(T);
        })
        .def("getPreferredTypeAlign", [](const clang::ASTContext& self, const clang::Type * T) -> unsigned int {
           return  self.getPreferredTypeAlign(T);
        })
        .def("getTargetDefaultAlignForAttributeAligned", [](const clang::ASTContext& self) -> unsigned int {
           return  self.getTargetDefaultAlignForAttributeAligned();
        })
        .def("getAlignOfGlobalVar", [](const clang::ASTContext& self, clang::QualType T) -> unsigned int {
           return  self.getAlignOfGlobalVar(T);
        })
        //.def("getAlignOfGlobalVarInChars", [](const clang::ASTContext& self, clang::QualType T) -> clang::CharUnits {
        //   return  self.getAlignOfGlobalVarInChars(T);
        //})
        //.def("getDeclAlign", [](const clang::ASTContext& self, const clang::Decl * D , bool ForAlignof) -> clang::CharUnits {
        //   return  self.getDeclAlign(D, ForAlignof);
        //})
        //.def("getASTRecordLayout", [](const clang::ASTContext& self, const clang::RecordDecl * D) -> const clang::ASTRecordLayout & {
        //   return  self.getASTRecordLayout(D);
        //})
        //.def("getASTObjCInterfaceLayout", [](const clang::ASTContext& self, const clang::ObjCInterfaceDecl * D) -> const clang::ASTRecordLayout & {
        //   return  self.getASTObjCInterfaceLayout(D);
        //})
        //.def("DumpRecordLayout", [](const clang::ASTContext& self, const clang::RecordDecl * RD , llvm::raw_ostream & OS , bool Simple)  {
        //     self.DumpRecordLayout(RD, OS, Simple);
        //})
        //.def("getASTObjCImplementationLayout", [](const clang::ASTContext& self, const clang::ObjCImplementationDecl * D) -> const clang::ASTRecordLayout & {
        //   return  self.getASTObjCImplementationLayout(D);
        //})
        .def("getCurrentKeyFunction", []( clang::ASTContext& self, const clang::CXXRecordDecl * RD) -> const clang::CXXMethodDecl * {
           return  self.getCurrentKeyFunction(RD);
        })
        .def("setNonKeyFunction", []( clang::ASTContext& self, const clang::CXXMethodDecl * method)  {
             self.setNonKeyFunction(method);
        })
        //.def("getOffsetOfBaseWithVBPtr", [](const clang::ASTContext& self, const clang::CXXRecordDecl * RD) -> clang::CharUnits {
        //   return  self.getOffsetOfBaseWithVBPtr(RD);
        //})
        .def("getFieldOffset", [](const clang::ASTContext& self, const clang::ValueDecl * FD) -> unsigned long {
           return  self.getFieldOffset(FD);
        })
        .def("isNearlyEmpty", [](const clang::ASTContext& self, const clang::CXXRecordDecl * RD) -> bool {
           return  self.isNearlyEmpty(RD);
        })
        //.def("getVTableContext", []( clang::ASTContext& self) -> clang::VTableContextBase * {
        //   return  self.getVTableContext();
        //})
        //.def("createMangleContext", []( clang::ASTContext& self) -> clang::MangleContext * {
        //   return  self.createMangleContext();
        //})
        //.def("DeepCollectObjCIvars", [](const clang::ASTContext& self, const clang::ObjCInterfaceDecl * OI , bool leafClass , llvm::SmallVectorImpl<const clang::ObjCIvarDecl *> & Ivars)  {
        //     self.DeepCollectObjCIvars(OI, leafClass, Ivars);
        //})
        //.def("CountNonClassIvars", [](const clang::ASTContext& self, const clang::ObjCInterfaceDecl * OI) -> unsigned int {
        //   return  self.CountNonClassIvars(OI);
        //})
        //.def("CollectInheritedProtocols", []( clang::ASTContext& self, const clang::Decl * CDecl , llvm::SmallPtrSet<clang::ObjCProtocolDecl *, 8> & Protocols)  {
        //     self.CollectInheritedProtocols(CDecl, Protocols);
        //})
        //.def("getCanonicalType", [](const clang::ASTContext& self, clang::QualType T) -> clang::CanQual<clang::Type> {
        //   return  self.getCanonicalType(T);
        //})
        .def("getCanonicalType", [](const clang::ASTContext& self, const clang::Type * T) -> const clang::Type * {
           return  self.getCanonicalType(T);
        })
        //.def("getCanonicalParamType", [](const clang::ASTContext& self, clang::QualType T) -> clang::CanQual<clang::Type> {
        //   return  self.getCanonicalParamType(T);
        //})
        .def("hasSameType", [](const clang::ASTContext& self, clang::QualType T1 , clang::QualType T2) -> bool {
           return  self.hasSameType(T1, T2);
        })
        .def("hasSameType", [](const clang::ASTContext& self, const clang::Type * T1 , const clang::Type * T2) -> bool {
           return  self.hasSameType(T1, T2);
        })
        .def("getUnqualifiedArrayType", []( clang::ASTContext& self, clang::QualType T , clang::Qualifiers & Quals) -> clang::QualType {
           return  self.getUnqualifiedArrayType(T, Quals);
        })
        .def("hasSameUnqualifiedType", [](const clang::ASTContext& self, clang::QualType T1 , clang::QualType T2) -> bool {
           return  self.hasSameUnqualifiedType(T1, T2);
        })
        .def("hasSameNullabilityTypeQualifier", [](const clang::ASTContext& self, clang::QualType SubT , clang::QualType SuperT , bool IsParam) -> bool {
           return  self.hasSameNullabilityTypeQualifier(SubT, SuperT, IsParam);
        })
        //.def("ObjCMethodsAreEqual", []( clang::ASTContext& self, const clang::ObjCMethodDecl * MethodDecl , const clang::ObjCMethodDecl * MethodImp) -> bool {
        //   return  self.ObjCMethodsAreEqual(MethodDecl, MethodImp);
        //})
        .def("UnwrapSimilarPointerTypes", []( clang::ASTContext& self, clang::QualType & T1 , clang::QualType & T2) -> bool {
           return  self.UnwrapSimilarPointerTypes(T1, T2);
        })
        //.def("getCanonicalNestedNameSpecifier", [](const clang::ASTContext& self, clang::NestedNameSpecifier * NNS) -> clang::NestedNameSpecifier * {
        //   return  self.getCanonicalNestedNameSpecifier(NNS);
        //})
        .def("getDefaultCallingConvention", [](const clang::ASTContext& self, bool isVariadic , bool IsCXXMethod) -> clang::CallingConv {
           return  self.getDefaultCallingConvention(isVariadic, IsCXXMethod);
        })
        //.def("getCanonicalTemplateName", [](const clang::ASTContext& self, clang::TemplateName Name) -> clang::TemplateName {
        //   return  self.getCanonicalTemplateName(Name);
        //})
        //.def("hasSameTemplateName", []( clang::ASTContext& self, clang::TemplateName X , clang::TemplateName Y) -> bool {
        //   return  self.hasSameTemplateName(X, Y);
        //})
        //.def("getCanonicalTemplateArgument", [](const clang::ASTContext& self, const clang::TemplateArgument & Arg) -> clang::TemplateArgument {
        //   return  self.getCanonicalTemplateArgument(Arg);
        //})
        //.def("getAsArrayType", [](const clang::ASTContext& self, clang::QualType T) -> const clang::ArrayType * {
        //   return  self.getAsArrayType(T);
        //})
        //.def("getAsConstantArrayType", [](const clang::ASTContext& self, clang::QualType T) -> const clang::ConstantArrayType * {
        //   return  self.getAsConstantArrayType(T);
        //})
        //.def("getAsVariableArrayType", [](const clang::ASTContext& self, clang::QualType T) -> const clang::VariableArrayType * {
        //   return  self.getAsVariableArrayType(T);
        //})
        //.def("getAsIncompleteArrayType", [](const clang::ASTContext& self, clang::QualType T) -> const clang::IncompleteArrayType * {
        //   return  self.getAsIncompleteArrayType(T);
        //})
        //.def("getAsDependentSizedArrayType", [](const clang::ASTContext& self, clang::QualType T) -> const clang::DependentSizedArrayType * {
        //   return  self.getAsDependentSizedArrayType(T);
        //})
        //.def("getBaseElementType", [](const clang::ASTContext& self, const clang::ArrayType * VAT) -> clang::QualType {
        //   return  self.getBaseElementType(VAT);
        //})
        .def("getBaseElementType", [](const clang::ASTContext& self, clang::QualType QT) -> clang::QualType {
           return  self.getBaseElementType(QT);
        })
        //.def("getConstantArrayElementCount", [](const clang::ASTContext& self, const clang::ConstantArrayType * CA) -> unsigned long {
        //   return  self.getConstantArrayElementCount(CA);
        //})
        .def("getAdjustedParameterType", [](const clang::ASTContext& self, clang::QualType T) -> clang::QualType {
           return  self.getAdjustedParameterType(T);
        })
        .def("getSignatureParameterType", [](const clang::ASTContext& self, clang::QualType T) -> clang::QualType {
           return  self.getSignatureParameterType(T);
        })
        .def("getExceptionObjectType", [](const clang::ASTContext& self, clang::QualType T) -> clang::QualType {
           return  self.getExceptionObjectType(T);
        })
        .def("getArrayDecayedType", [](const clang::ASTContext& self, clang::QualType T) -> clang::QualType {
           return  self.getArrayDecayedType(T);
        })
        .def("getPromotedIntegerType", [](const clang::ASTContext& self, clang::QualType PromotableType) -> clang::QualType {
           return  self.getPromotedIntegerType(PromotableType);
        })
        .def("getInnerObjCOwnership", [](const clang::ASTContext& self, clang::QualType T) -> clang::Qualifiers::ObjCLifetime {
           return  self.getInnerObjCOwnership(T);
        })
        .def("isPromotableBitField", [](const clang::ASTContext& self, clang::Expr * E) -> clang::QualType {
           return  self.isPromotableBitField(E);
        })
        .def("getIntegerTypeOrder", [](const clang::ASTContext& self, clang::QualType LHS , clang::QualType RHS) -> int {
           return  self.getIntegerTypeOrder(LHS, RHS);
        })
        .def("getFloatingTypeOrder", [](const clang::ASTContext& self, clang::QualType LHS , clang::QualType RHS) -> int {
           return  self.getFloatingTypeOrder(LHS, RHS);
        })
        .def("getFloatingTypeOfSizeWithinDomain", [](const clang::ASTContext& self, clang::QualType typeSize , clang::QualType typeDomain) -> clang::QualType {
           return  self.getFloatingTypeOfSizeWithinDomain(typeSize, typeDomain);
        })
        .def("getTargetAddressSpace", [](const clang::ASTContext& self, clang::QualType T) -> unsigned int {
           return  self.getTargetAddressSpace(T);
        })
        .def("getTargetAddressSpace", [](const clang::ASTContext& self, clang::Qualifiers Q) -> unsigned int {
           return  self.getTargetAddressSpace(Q);
        })
        .def("getTargetAddressSpace", [](const clang::ASTContext& self, unsigned int AS) -> unsigned int {
           return  self.getTargetAddressSpace(AS);
        })
        .def("addressSpaceMapManglingFor", [](const clang::ASTContext& self, unsigned int AS) -> bool {
           return  self.addressSpaceMapManglingFor(AS);
        })
        .def("typesAreCompatible", []( clang::ASTContext& self, clang::QualType T1 , clang::QualType T2 , bool CompareUnqualified) -> bool {
           return  self.typesAreCompatible(T1, T2, CompareUnqualified);
        })
        .def("propertyTypesAreCompatible", (bool (clang::ASTContext::*)(clang::QualType, clang::QualType))&clang::ASTContext::propertyTypesAreCompatible)
        .def("typesAreBlockPointerCompatible", (bool (clang::ASTContext::*)(clang::QualType, clang::QualType))&clang::ASTContext::typesAreBlockPointerCompatible)
        .def("isObjCIdType", [](const clang::ASTContext& self, clang::QualType T) -> bool {
           return  self.isObjCIdType(T);
        })
        .def("isObjCClassType", [](const clang::ASTContext& self, clang::QualType T) -> bool {
           return  self.isObjCClassType(T);
        })
        .def("isObjCSelType", [](const clang::ASTContext& self, clang::QualType T) -> bool {
           return  self.isObjCSelType(T);
        })
        .def("ObjCQualifiedIdTypesAreCompatible", []( clang::ASTContext& self, clang::QualType LHS , clang::QualType RHS , bool ForCompare) -> bool {
           return  self.ObjCQualifiedIdTypesAreCompatible(LHS, RHS, ForCompare);
        })
        .def("ObjCQualifiedClassTypesAreCompatible", []( clang::ASTContext& self, clang::QualType LHS , clang::QualType RHS) -> bool {
           return  self.ObjCQualifiedClassTypesAreCompatible(LHS, RHS);
        })
        //.def("canAssignObjCInterfaces", []( clang::ASTContext& self, const clang::ObjCObjectPointerType * LHSOPT , const clang::ObjCObjectPointerType * RHSOPT) -> bool {
        //   return  self.canAssignObjCInterfaces(LHSOPT, RHSOPT);
        //})
        //.def("canAssignObjCInterfaces", []( clang::ASTContext& self, const clang::ObjCObjectType * LHS , const clang::ObjCObjectType * RHS) -> bool {
        //   return  self.canAssignObjCInterfaces(LHS, RHS);
        //})
        //.def("canAssignObjCInterfacesInBlockPointer", []( clang::ASTContext& self, const clang::ObjCObjectPointerType * LHSOPT , const clang::ObjCObjectPointerType * RHSOPT , bool BlockReturnType) -> bool {
        //   return  self.canAssignObjCInterfacesInBlockPointer(LHSOPT, RHSOPT, BlockReturnType);
        //})
        .def("areComparableObjCPointerTypes", []( clang::ASTContext& self, clang::QualType LHS , clang::QualType RHS) -> bool {
           return  self.areComparableObjCPointerTypes(LHS, RHS);
        })
        //.def("areCommonBaseCompatible", []( clang::ASTContext& self, const clang::ObjCObjectPointerType * LHSOPT , const clang::ObjCObjectPointerType * RHSOPT) -> clang::QualType {
        //   return  self.areCommonBaseCompatible(LHSOPT, RHSOPT);
        //})
        .def("canBindObjCObjectType", []( clang::ASTContext& self, clang::QualType To , clang::QualType From) -> bool {
           return  self.canBindObjCObjectType(To, From);
        })
        .def("mergeTypes", (clang::QualType (clang::ASTContext::*)(clang::QualType, clang::QualType, bool, bool, bool))&clang::ASTContext::mergeTypes)
        .def("mergeFunctionTypes", (clang::QualType (clang::ASTContext::*)(clang::QualType, clang::QualType, bool, bool))&clang::ASTContext::mergeFunctionTypes)
        .def("mergeFunctionParameterTypes", (clang::QualType (clang::ASTContext::*)(clang::QualType, clang::QualType, bool, bool))&clang::ASTContext::mergeFunctionParameterTypes)
        .def("mergeTransparentUnionType", (clang::QualType (clang::ASTContext::*)(clang::QualType, clang::QualType, bool, bool))&clang::ASTContext::mergeTransparentUnionType)
        .def("mergeObjCGCQualifiers", (clang::QualType (clang::ASTContext::*)(clang::QualType, clang::QualType))&clang::ASTContext::mergeObjCGCQualifiers)
        //.def("doFunctionTypesMatchOnExtParameterInfos", []( clang::ASTContext& self, const clang::FunctionProtoType * FromFunctionType , const clang::FunctionProtoType * ToFunctionType) -> bool {
        //   return  self.doFunctionTypesMatchOnExtParameterInfos(FromFunctionType, ToFunctionType);
        //})
        //.def("ResetObjCLayout", []( clang::ASTContext& self, const clang::ObjCContainerDecl * CD)  {
        //     self.ResetObjCLayout(CD);
        //})
        .def("getIntWidth", [](const clang::ASTContext& self, clang::QualType T) -> unsigned int {
           return  self.getIntWidth(T);
        })
        .def("getCorrespondingUnsignedType", [](const clang::ASTContext& self, clang::QualType T) -> clang::QualType {
           return  self.getCorrespondingUnsignedType(T);
        })
        //.def("MakeIntValue", [](const clang::ASTContext& self, unsigned long Value , clang::QualType Type) -> llvm::APSInt {
        //   return  self.MakeIntValue(Value, Type);
        //})
        .def("isSentinelNullExpr", []( clang::ASTContext& self, const clang::Expr * E) -> bool {
           return  self.isSentinelNullExpr(E);
        })
        //.def("getObjCImplementation", []( clang::ASTContext& self, clang::ObjCInterfaceDecl * D) -> clang::ObjCImplementationDecl * {
        //   return  self.getObjCImplementation(D);
        //})
        //.def("getObjCImplementation", []( clang::ASTContext& self, clang::ObjCCategoryDecl * D) -> clang::ObjCCategoryImplDecl * {
        //   return  self.getObjCImplementation(D);
        //})
        .def("AnyObjCImplementation", []( clang::ASTContext& self) -> bool {
           return  self.AnyObjCImplementation();
        })
        //.def("setObjCImplementation", []( clang::ASTContext& self, clang::ObjCInterfaceDecl * IFaceD , clang::ObjCImplementationDecl * ImplD)  {
        //     self.setObjCImplementation(IFaceD, ImplD);
        //})
        //.def("setObjCImplementation", []( clang::ASTContext& self, clang::ObjCCategoryDecl * CatD , clang::ObjCCategoryImplDecl * ImplD)  {
        //     self.setObjCImplementation(CatD, ImplD);
        //})
        //.def("getObjCMethodRedeclaration", [](const clang::ASTContext& self, const clang::ObjCMethodDecl * MD) -> const clang::ObjCMethodDecl * {
        //   return  self.getObjCMethodRedeclaration(MD);
        //})
        //.def("setObjCMethodRedeclaration", []( clang::ASTContext& self, const clang::ObjCMethodDecl * MD , const clang::ObjCMethodDecl * Redecl)  {
        //     self.setObjCMethodRedeclaration(MD, Redecl);
        //})
        //.def("getObjContainingInterface", [](const clang::ASTContext& self, const clang::NamedDecl * ND) -> const clang::ObjCInterfaceDecl * {
        //   return  self.getObjContainingInterface(ND);
        //})
        .def("setBlockVarCopyInits", []( clang::ASTContext& self, clang::VarDecl * VD , clang::Expr * Init)  {
             self.setBlockVarCopyInits(VD, Init);
        })
        .def("getBlockVarCopyInits", []( clang::ASTContext& self, const clang::VarDecl * VD) -> clang::Expr * {
           return  self.getBlockVarCopyInits(VD);
        })
        .def("CreateTypeSourceInfo", [](const clang::ASTContext& self, clang::QualType T , unsigned int Size) -> clang::TypeSourceInfo * {
           return  self.CreateTypeSourceInfo(T, Size);
        })
        .def("getTrivialTypeSourceInfo", [](const clang::ASTContext& self, clang::QualType T , clang::SourceLocation Loc) -> clang::TypeSourceInfo * {
           return  self.getTrivialTypeSourceInfo(T, Loc);
        })
        //.def("AddDeallocation", []( clang::ASTContext& self, void (*)(void *) Callback , void * Data)  {
        //     self.AddDeallocation(Callback, Data);
        //})
        .def("GetGVALinkageForFunction", [](const clang::ASTContext& self, const clang::FunctionDecl * FD) -> clang::GVALinkage {
           return  self.GetGVALinkageForFunction(FD);
        })
        .def("GetGVALinkageForVariable", []( clang::ASTContext& self, const clang::VarDecl * VD) -> clang::GVALinkage {
           return  self.GetGVALinkageForVariable(VD);
        })
        .def("DeclMustBeEmitted", []( clang::ASTContext& self, const clang::Decl * D) -> bool {
           return  self.DeclMustBeEmitted(D);
        })
        .def("getCopyConstructorForExceptionObject", []( clang::ASTContext& self, clang::CXXRecordDecl * RD) -> const clang::CXXConstructorDecl * {
           return  self.getCopyConstructorForExceptionObject(RD);
        })
        .def("addCopyConstructorForExceptionObject", []( clang::ASTContext& self, clang::CXXRecordDecl * RD , clang::CXXConstructorDecl * CD)  {
             self.addCopyConstructorForExceptionObject(RD, CD);
        })
        .def("addDefaultArgExprForConstructor", []( clang::ASTContext& self, const clang::CXXConstructorDecl * CD , unsigned int ParmIdx , clang::Expr * DAE)  {
             self.addDefaultArgExprForConstructor(CD, ParmIdx, DAE);
        })
        .def("getDefaultArgExprForConstructor", []( clang::ASTContext& self, const clang::CXXConstructorDecl * CD , unsigned int ParmIdx) -> clang::Expr * {
           return  self.getDefaultArgExprForConstructor(CD, ParmIdx);
        })
        .def("addTypedefNameForUnnamedTagDecl", []( clang::ASTContext& self, clang::TagDecl * TD , clang::TypedefNameDecl * TND)  {
             self.addTypedefNameForUnnamedTagDecl(TD, TND);
        })
        .def("getTypedefNameForUnnamedTagDecl", []( clang::ASTContext& self, const clang::TagDecl * TD) -> clang::TypedefNameDecl * {
           return  self.getTypedefNameForUnnamedTagDecl(TD);
        })
        .def("addDeclaratorForUnnamedTagDecl", []( clang::ASTContext& self, clang::TagDecl * TD , clang::DeclaratorDecl * DD)  {
             self.addDeclaratorForUnnamedTagDecl(TD, DD);
        })
        .def("getDeclaratorForUnnamedTagDecl", []( clang::ASTContext& self, const clang::TagDecl * TD) -> clang::DeclaratorDecl * {
           return  self.getDeclaratorForUnnamedTagDecl(TD);
        })
        .def("setManglingNumber", []( clang::ASTContext& self, const clang::NamedDecl * ND , unsigned int Number)  {
             self.setManglingNumber(ND, Number);
        })
        .def("getManglingNumber", [](const clang::ASTContext& self, const clang::NamedDecl * ND) -> unsigned int {
           return  self.getManglingNumber(ND);
        })
        .def("setStaticLocalNumber", []( clang::ASTContext& self, const clang::VarDecl * VD , unsigned int Number)  {
             self.setStaticLocalNumber(VD, Number);
        })
        .def("getStaticLocalNumber", [](const clang::ASTContext& self, const clang::VarDecl * VD) -> unsigned int {
           return  self.getStaticLocalNumber(VD);
        })
        //.def("getManglingNumberContext", []( clang::ASTContext& self, const clang::DeclContext * DC) -> clang::MangleNumberingContext & {
        //   return  self.getManglingNumberContext(DC);
        //})
        //.def("createMangleNumberingContext", [](const clang::ASTContext& self) -> clang::MangleNumberingContext * {
        //   return  self.createMangleNumberingContext();
        //})
        .def("setParameterIndex", []( clang::ASTContext& self, const clang::ParmVarDecl * D , unsigned int index)  {
             self.setParameterIndex(D, index);
        })
        .def("getParameterIndex", [](const clang::ASTContext& self, const clang::ParmVarDecl * D) -> unsigned int {
           return  self.getParameterIndex(D);
        })
        //.def("getMaterializedTemporaryValue", []( clang::ASTContext& self, const clang::MaterializeTemporaryExpr * E , bool MayCreate) -> clang::APValue * {
        //   return  self.getMaterializedTemporaryValue(E, MayCreate);
        //})
        //.def("InitBuiltinTypes", []( clang::ASTContext& self, const clang::TargetInfo & Target , const clang::TargetInfo * AuxTarget)  {
        //     self.InitBuiltinTypes(Target, AuxTarget);
        //})
        //.def("getObjCEncodingForMethodParameter", [](const clang::ASTContext& self, clang::Decl::ObjCDeclQualifier QT , clang::QualType T , std::basic_string<char> & S , bool Extended)  {
        //     self.getObjCEncodingForMethodParameter(QT, T, S, Extended);
        //})
        .def("isMSStaticDataMemberInlineDefinition", [](const clang::ASTContext& self, const clang::VarDecl * VD) -> bool {
           return  self.isMSStaticDataMemberInlineDefinition(VD);
        })
        .def("getInlineVariableDefinitionKind", [](const clang::ASTContext& self, const clang::VarDecl * VD) -> clang::ASTContext::InlineVariableDefinitionKind {
           return  self.getInlineVariableDefinitionKind(VD);
        })
    ;

    py::class_<clang::Expr, stmt_deleter<clang::Expr>::type>(m, "Expr" , py::base<clang::Stmt>())
        .def("getType", [](const clang::Expr& self) -> clang::QualType {
           return  self.getType();
        })
        .def("setType", []( clang::Expr& self, clang::QualType t)  {
             self.setType(t);
        })
        .def("isValueDependent", [](const clang::Expr& self) -> bool {
           return  self.isValueDependent();
        })
        .def("setValueDependent", []( clang::Expr& self, bool VD)  {
             self.setValueDependent(VD);
        })
        .def("isTypeDependent", [](const clang::Expr& self) -> bool {
           return  self.isTypeDependent();
        })
        .def("setTypeDependent", []( clang::Expr& self, bool TD)  {
             self.setTypeDependent(TD);
        })
        .def("isInstantiationDependent", [](const clang::Expr& self) -> bool {
           return  self.isInstantiationDependent();
        })
        .def("setInstantiationDependent", []( clang::Expr& self, bool ID)  {
             self.setInstantiationDependent(ID);
        })
        .def("containsUnexpandedParameterPack", [](const clang::Expr& self) -> bool {
           return  self.containsUnexpandedParameterPack();
        })
        .def("setContainsUnexpandedParameterPack", []( clang::Expr& self, bool PP)  {
             self.setContainsUnexpandedParameterPack(PP);
        })
        .def("getExprLoc", [](const clang::Expr& self) -> clang::SourceLocation {
           return  self.getExprLoc();
        })
        .def("isLValue", [](const clang::Expr& self) -> bool {
           return  self.isLValue();
        })
        .def("isRValue", [](const clang::Expr& self) -> bool {
           return  self.isRValue();
        })
        .def("isXValue", [](const clang::Expr& self) -> bool {
           return  self.isXValue();
        })
        .def("isGLValue", [](const clang::Expr& self) -> bool {
           return  self.isGLValue();
        })
        .def("ClassifyLValue", [](const clang::Expr& self, clang::ASTContext & Ctx) -> clang::Expr::LValueClassification {
           return  self.ClassifyLValue(Ctx);
        })
        .def("isModifiableLvalue", [](const clang::Expr& self, clang::ASTContext & Ctx , clang::SourceLocation * Loc) -> clang::Expr::isModifiableLvalueResult {
           return  self.isModifiableLvalue(Ctx, Loc);
        })
        //.def("Classify", [](const clang::Expr& self, clang::ASTContext & Ctx) -> clang::Expr::Classification {
        //   return  self.Classify(Ctx);
        //})
        //.def("ClassifyModifiable", [](const clang::Expr& self, clang::ASTContext & Ctx , clang::SourceLocation & Loc) -> clang::Expr::Classification {
        //   return  self.ClassifyModifiable(Ctx, Loc);
        //})
        .def("getValueKind", [](const clang::Expr& self) -> clang::ExprValueKind {
           return  self.getValueKind();
        })
        .def("getObjectKind", [](const clang::Expr& self) -> clang::ExprObjectKind {
           return  self.getObjectKind();
        })
        .def("isOrdinaryOrBitFieldObject", [](const clang::Expr& self) -> bool {
           return  self.isOrdinaryOrBitFieldObject();
        })
        .def("setValueKind", []( clang::Expr& self, clang::ExprValueKind Cat)  {
             self.setValueKind(Cat);
        })
        .def("setObjectKind", []( clang::Expr& self, clang::ExprObjectKind Cat)  {
             self.setObjectKind(Cat);
        })
        .def("refersToBitField", [](const clang::Expr& self) -> bool {
           return  self.refersToBitField();
        })
        .def("getSourceBitField", []( clang::Expr& self) -> clang::FieldDecl * {
           return  self.getSourceBitField();
        })
        .def("getSourceBitField", [](const clang::Expr& self) -> const clang::FieldDecl * {
           return  self.getSourceBitField();
        })
        //.def("getObjCProperty", [](const clang::Expr& self) -> const clang::ObjCPropertyRefExpr * {
        //   return  self.getObjCProperty();
        //})
        .def("isObjCSelfExpr", [](const clang::Expr& self) -> bool {
           return  self.isObjCSelfExpr();
        })
        .def("refersToVectorElement", [](const clang::Expr& self) -> bool {
           return  self.refersToVectorElement();
        })
        .def("refersToGlobalRegisterVar", [](const clang::Expr& self) -> bool {
           return  self.refersToGlobalRegisterVar();
        })
        .def("hasPlaceholderType", [](const clang::Expr& self) -> bool {
           return  self.hasPlaceholderType();
        })
        //.def("hasPlaceholderType", [](const clang::Expr& self, clang::BuiltinType::Kind K) -> bool {
        //   return  self.hasPlaceholderType(K);
        //})
        .def("isKnownToHaveBooleanValue", [](const clang::Expr& self) -> bool {
           return  self.isKnownToHaveBooleanValue();
        })
        //.def("isIntegerConstantExpr", [](const clang::Expr& self, llvm::APSInt & Result , const clang::ASTContext & Ctx , clang::SourceLocation * Loc , bool isEvaluated) -> bool {
        //   return  self.isIntegerConstantExpr(Result, Ctx, Loc, isEvaluated);
        //})
        .def("isIntegerConstantExpr", [](const clang::Expr& self, const clang::ASTContext & Ctx , clang::SourceLocation * Loc) -> bool {
           return  self.isIntegerConstantExpr(Ctx, Loc);
        })
        .def("isCXX98IntegralConstantExpr", [](const clang::Expr& self, const clang::ASTContext & Ctx) -> bool {
           return  self.isCXX98IntegralConstantExpr(Ctx);
        })
        //.def("isCXX11ConstantExpr", [](const clang::Expr& self, const clang::ASTContext & Ctx , clang::APValue * Result , clang::SourceLocation * Loc) -> bool {
        //   return  self.isCXX11ConstantExpr(Ctx, Result, Loc);
        //})
        //.def("EvaluateAsRValue", [](const clang::Expr& self, clang::Expr::EvalResult & Result , const clang::ASTContext & Ctx) -> bool {
        //   return  self.EvaluateAsRValue(Result, Ctx);
        //})
        .def("EvaluateAsBooleanCondition", [](const clang::Expr& self, bool & Result , const clang::ASTContext & Ctx) -> bool {
           return  self.EvaluateAsBooleanCondition(Result, Ctx);
        })
        //.def("EvaluateAsInt", [](const clang::Expr& self, llvm::APSInt & Result , const clang::ASTContext & Ctx , clang::Expr::SideEffectsKind AllowSideEffects) -> bool {
        //   return  self.EvaluateAsInt(Result, Ctx, AllowSideEffects);
        //})
        //.def("EvaluateAsFloat", [](const clang::Expr& self, llvm::APFloat & Result , const clang::ASTContext & Ctx , clang::Expr::SideEffectsKind AllowSideEffects) -> bool {
        //   return  self.EvaluateAsFloat(Result, Ctx, AllowSideEffects);
        //})
        .def("isEvaluatable", [](const clang::Expr& self, const clang::ASTContext & Ctx , clang::Expr::SideEffectsKind AllowSideEffects) -> bool {
           return  self.isEvaluatable(Ctx, AllowSideEffects);
        })
        .def("HasSideEffects", [](const clang::Expr& self, const clang::ASTContext & Ctx , bool IncludePossibleEffects) -> bool {
           return  self.HasSideEffects(Ctx, IncludePossibleEffects);
        })
        .def("hasNonTrivialCall", [](const clang::Expr& self, const clang::ASTContext & Ctx) -> bool {
           return  self.hasNonTrivialCall(Ctx);
        })
        //.def("EvaluateKnownConstInt", [](const clang::Expr& self, const clang::ASTContext & Ctx , llvm::SmallVectorImpl<std::pair<clang::SourceLocation, clang::PartialDiagnostic> > * Diag) -> llvm::APSInt {
        //   return  self.EvaluateKnownConstInt(Ctx, Diag);
        //})
        .def("EvaluateForOverflow", [](const clang::Expr& self, const clang::ASTContext & Ctx)  {
             self.EvaluateForOverflow(Ctx);
        })
        //.def("EvaluateAsLValue", [](const clang::Expr& self, clang::Expr::EvalResult & Result , const clang::ASTContext & Ctx) -> bool {
        //   return  self.EvaluateAsLValue(Result, Ctx);
        //})
        //.def("EvaluateAsInitializer", [](const clang::Expr& self, clang::APValue & Result , const clang::ASTContext & Ctx , const clang::VarDecl * VD , llvm::SmallVectorImpl<std::pair<clang::SourceLocation, clang::PartialDiagnostic> > & Notes) -> bool {
        //   return  self.EvaluateAsInitializer(Result, Ctx, VD, Notes);
        //})
        //.def("EvaluateWithSubstitution", [](const clang::Expr& self, clang::APValue & Value , clang::ASTContext & Ctx , const clang::FunctionDecl * Callee , llvm::ArrayRef<const clang::Expr *> Args) -> bool {
        //   return  self.EvaluateWithSubstitution(Value, Ctx, Callee, Args);
        //})
        .def("tryEvaluateObjectSize", [](const clang::Expr& self, unsigned long & Result , clang::ASTContext & Ctx , unsigned int Type) -> bool {
           return  self.tryEvaluateObjectSize(Result, Ctx, Type);
        })
        .def("isNullPointerConstant", [](const clang::Expr& self, clang::ASTContext & Ctx , clang::Expr::NullPointerConstantValueDependence NPC) -> clang::Expr::NullPointerConstantKind {
           return  self.isNullPointerConstant(Ctx, NPC);
        })
        .def("isOBJCGCCandidate", [](const clang::Expr& self, clang::ASTContext & Ctx) -> bool {
           return  self.isOBJCGCCandidate(Ctx);
        })
        .def("isBoundMemberFunction", [](const clang::Expr& self, clang::ASTContext & Ctx) -> bool {
           return  self.isBoundMemberFunction(Ctx);
        })
        .def("IgnoreImpCasts", []( clang::Expr& self) -> clang::Expr * {
           return  self.IgnoreImpCasts();
        })
        .def("IgnoreImplicit", []( clang::Expr& self) -> clang::Expr * {
           return  self.IgnoreImplicit();
        })
        .def("IgnoreImplicit", [](const clang::Expr& self) -> const clang::Expr * {
           return  self.IgnoreImplicit();
        })
        .def("IgnoreParens", []( clang::Expr& self) -> clang::Expr * {
           return  self.IgnoreParens();
        })
        .def("IgnoreParenCasts", []( clang::Expr& self) -> clang::Expr * {
           return  self.IgnoreParenCasts();
        })
        .def("IgnoreCasts", []( clang::Expr& self) -> clang::Expr * {
           return  self.IgnoreCasts();
        })
        .def("IgnoreParenImpCasts", []( clang::Expr& self) -> clang::Expr * {
           return  self.IgnoreParenImpCasts();
        })
        .def("IgnoreConversionOperator", []( clang::Expr& self) -> clang::Expr * {
           return  self.IgnoreConversionOperator();
        })
        .def("IgnoreConversionOperator", [](const clang::Expr& self) -> const clang::Expr * {
           return  self.IgnoreConversionOperator();
        })
        .def("IgnoreParenImpCasts", [](const clang::Expr& self) -> const clang::Expr * {
           return  self.IgnoreParenImpCasts();
        })
        .def("IgnoreParenLValueCasts", []( clang::Expr& self) -> clang::Expr * {
           return  self.IgnoreParenLValueCasts();
        })
        .def("IgnoreParenLValueCasts", [](const clang::Expr& self) -> const clang::Expr * {
           return  self.IgnoreParenLValueCasts();
        })
        .def("IgnoreParenNoopCasts", []( clang::Expr& self, clang::ASTContext & Ctx) -> clang::Expr * {
           return  self.IgnoreParenNoopCasts(Ctx);
        })
        .def("ignoreParenBaseCasts", []( clang::Expr& self) -> clang::Expr * {
           return  self.ignoreParenBaseCasts();
        })
        .def("ignoreParenBaseCasts", [](const clang::Expr& self) -> const clang::Expr * {
           return  self.ignoreParenBaseCasts();
        })
        .def("isDefaultArgument", [](const clang::Expr& self) -> bool {
           return  self.isDefaultArgument();
        })
        .def("isTemporaryObject", [](const clang::Expr& self, clang::ASTContext & Ctx , const clang::CXXRecordDecl * TempTy) -> bool {
           return  self.isTemporaryObject(Ctx, TempTy);
        })
        .def("isImplicitCXXThis", [](const clang::Expr& self) -> bool {
           return  self.isImplicitCXXThis();
        })
        .def("IgnoreImpCasts", [](const clang::Expr& self) -> const clang::Expr * {
           return  self.IgnoreImpCasts();
        })
        .def("IgnoreParens", [](const clang::Expr& self) -> const clang::Expr * {
           return  self.IgnoreParens();
        })
        .def("IgnoreParenCasts", [](const clang::Expr& self) -> const clang::Expr * {
           return  self.IgnoreParenCasts();
        })
        .def("IgnoreCasts", [](const clang::Expr& self) -> const clang::Expr * {
           return  self.IgnoreCasts();
        })
        .def("IgnoreParenNoopCasts", [](const clang::Expr& self, clang::ASTContext & Ctx) -> const clang::Expr * {
           return  self.IgnoreParenNoopCasts(Ctx);
        })
        .def("getBestDynamicClassType", [](const clang::Expr& self) -> const clang::CXXRecordDecl * {
           return  self.getBestDynamicClassType();
        })
        //.def("skipRValueSubobjectAdjustments", [](const clang::Expr& self, llvm::SmallVectorImpl<const clang::Expr *> & CommaLHS , llvm::SmallVectorImpl<clang::SubobjectAdjustment> & Adjustments) -> const clang::Expr * {
        //   return  self.skipRValueSubobjectAdjustments(CommaLHS, Adjustments);
        //})
    ;

    py::class_<clang::OpaqueValueExpr, stmt_deleter<clang::OpaqueValueExpr>::type>(m, "OpaqueValueExpr" , py::base<clang::Expr>())
        .def("getLocation", [](const clang::OpaqueValueExpr& self) -> clang::SourceLocation {
           return  self.getLocation();
        })
        .def("getLocStart", [](const clang::OpaqueValueExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::OpaqueValueExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getExprLoc", [](const clang::OpaqueValueExpr& self) -> clang::SourceLocation {
           return  self.getExprLoc();
        })
        //.def("children", []( clang::OpaqueValueExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
        .def("getSourceExpr", [](const clang::OpaqueValueExpr& self) -> clang::Expr * {
           return  self.getSourceExpr();
        })
    ;

    py::class_<clang::DeclRefExpr, stmt_deleter<clang::DeclRefExpr>::type>(m, "DeclRefExpr" , py::base<clang::Expr>())
        .def("getDecl", []( clang::DeclRefExpr& self) -> clang::ValueDecl * {
           return  self.getDecl();
        })
        .def("getDecl", [](const clang::DeclRefExpr& self) -> const clang::ValueDecl * {
           return  self.getDecl();
        })
        .def("setDecl", []( clang::DeclRefExpr& self, clang::ValueDecl * NewD)  {
             self.setDecl(NewD);
        })
        .def("getNameInfo", [](const clang::DeclRefExpr& self) -> clang::DeclarationNameInfo {
           return  self.getNameInfo();
        })
        .def("getLocation", [](const clang::DeclRefExpr& self) -> clang::SourceLocation {
           return  self.getLocation();
        })
        .def("setLocation", []( clang::DeclRefExpr& self, clang::SourceLocation L)  {
             self.setLocation(L);
        })
        .def("getLocStart", [](const clang::DeclRefExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::DeclRefExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("hasQualifier", [](const clang::DeclRefExpr& self) -> bool {
           return  self.hasQualifier();
        })
        //.def("getQualifierLoc", [](const clang::DeclRefExpr& self) -> clang::NestedNameSpecifierLoc {
        //   return  self.getQualifierLoc();
        //})
        //.def("getQualifier", [](const clang::DeclRefExpr& self) -> clang::NestedNameSpecifier * {
        //   return  self.getQualifier();
        //})
        .def("getFoundDecl", []( clang::DeclRefExpr& self) -> clang::NamedDecl * {
           return  self.getFoundDecl();
        })
        .def("getFoundDecl", [](const clang::DeclRefExpr& self) -> const clang::NamedDecl * {
           return  self.getFoundDecl();
        })
        .def("hasTemplateKWAndArgsInfo", [](const clang::DeclRefExpr& self) -> bool {
           return  self.hasTemplateKWAndArgsInfo();
        })
        .def("getTemplateKeywordLoc", [](const clang::DeclRefExpr& self) -> clang::SourceLocation {
           return  self.getTemplateKeywordLoc();
        })
        .def("getLAngleLoc", [](const clang::DeclRefExpr& self) -> clang::SourceLocation {
           return  self.getLAngleLoc();
        })
        .def("getRAngleLoc", [](const clang::DeclRefExpr& self) -> clang::SourceLocation {
           return  self.getRAngleLoc();
        })
        .def("hasTemplateKeyword", [](const clang::DeclRefExpr& self) -> bool {
           return  self.hasTemplateKeyword();
        })
        .def("hasExplicitTemplateArgs", [](const clang::DeclRefExpr& self) -> bool {
           return  self.hasExplicitTemplateArgs();
        })
        //.def("copyTemplateArgumentsInto", [](const clang::DeclRefExpr& self, clang::TemplateArgumentListInfo & List)  {
        //     self.copyTemplateArgumentsInto(List);
        //})
        //.def("getTemplateArgs", [](const clang::DeclRefExpr& self) -> const clang::TemplateArgumentLoc * {
        //   return  self.getTemplateArgs();
        //})
        .def("getNumTemplateArgs", [](const clang::DeclRefExpr& self) -> unsigned int {
           return  self.getNumTemplateArgs();
        })
        .def("hadMultipleCandidates", [](const clang::DeclRefExpr& self) -> bool {
           return  self.hadMultipleCandidates();
        })
        .def("setHadMultipleCandidates", []( clang::DeclRefExpr& self, bool V)  {
             self.setHadMultipleCandidates(V);
        })
        .def("refersToEnclosingVariableOrCapture", [](const clang::DeclRefExpr& self) -> bool {
           return  self.refersToEnclosingVariableOrCapture();
        })
        //.def("children", []( clang::DeclRefExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::PredefinedExpr, stmt_deleter<clang::PredefinedExpr>::type>(m, "PredefinedExpr" , py::base<clang::Expr>())
        .def("getIdentType", [](const clang::PredefinedExpr& self) -> clang::PredefinedExpr::IdentType {
           return  self.getIdentType();
        })
        .def("getLocation", [](const clang::PredefinedExpr& self) -> clang::SourceLocation {
           return  self.getLocation();
        })
        .def("setLocation", []( clang::PredefinedExpr& self, clang::SourceLocation L)  {
             self.setLocation(L);
        })
        .def("getFunctionName", []( clang::PredefinedExpr& self) -> clang::StringLiteral * {
           return  self.getFunctionName();
        })
        .def("getFunctionName", [](const clang::PredefinedExpr& self) -> const clang::StringLiteral * {
           return  self.getFunctionName();
        })
        .def("getLocStart", [](const clang::PredefinedExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::PredefinedExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::PredefinedExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::IntegerLiteral, stmt_deleter<clang::IntegerLiteral>::type>(m, "IntegerLiteral" , py::base<clang::Expr>())
        .def("getLocStart", [](const clang::IntegerLiteral& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::IntegerLiteral& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getLocation", [](const clang::IntegerLiteral& self) -> clang::SourceLocation {
           return  self.getLocation();
        })
        .def("setLocation", []( clang::IntegerLiteral& self, clang::SourceLocation Location)  {
             self.setLocation(Location);
        })
        //.def("children", []( clang::IntegerLiteral& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CharacterLiteral, stmt_deleter<clang::CharacterLiteral>::type>(m, "CharacterLiteral" , py::base<clang::Expr>())
        .def("getLocation", [](const clang::CharacterLiteral& self) -> clang::SourceLocation {
           return  self.getLocation();
        })
        .def("getKind", [](const clang::CharacterLiteral& self) -> clang::CharacterLiteral::CharacterKind {
           return  self.getKind();
        })
        .def("getLocStart", [](const clang::CharacterLiteral& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CharacterLiteral& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getValue", [](const clang::CharacterLiteral& self) -> unsigned int {
           return  self.getValue();
        })
        .def("setLocation", []( clang::CharacterLiteral& self, clang::SourceLocation Location)  {
             self.setLocation(Location);
        })
        .def("setKind", []( clang::CharacterLiteral& self, clang::CharacterLiteral::CharacterKind kind)  {
             self.setKind(kind);
        })
        .def("setValue", []( clang::CharacterLiteral& self, unsigned int Val)  {
             self.setValue(Val);
        })
        //.def("children", []( clang::CharacterLiteral& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::FloatingLiteral, stmt_deleter<clang::FloatingLiteral>::type>(m, "FloatingLiteral" , py::base<clang::Expr>())
        //.def("getValue", [](const clang::FloatingLiteral& self) -> llvm::APFloat {
        //   return  self.getValue();
        //})
        //.def("setValue", []( clang::FloatingLiteral& self, const clang::ASTContext & C , const llvm::APFloat & Val)  {
        //     self.setValue(C, Val);
        //})
        //.def("getRawSemantics", [](const clang::FloatingLiteral& self) -> clang::Stmt::APFloatSemantics {
        //   return  self.getRawSemantics();
        //})
        //.def("setRawSemantics", []( clang::FloatingLiteral& self, clang::Stmt::APFloatSemantics Sem)  {
        //     self.setRawSemantics(Sem);
        //})
        //.def("getSemantics", [](const clang::FloatingLiteral& self) -> const llvm::fltSemantics & {
        //   return  self.getSemantics();
        //})
        //.def("setSemantics", []( clang::FloatingLiteral& self, const llvm::fltSemantics & Sem)  {
        //     self.setSemantics(Sem);
        //})
        .def("isExact", [](const clang::FloatingLiteral& self) -> bool {
           return  self.isExact();
        })
        .def("setExact", []( clang::FloatingLiteral& self, bool E)  {
             self.setExact(E);
        })
        .def("getValueAsApproximateDouble", [](const clang::FloatingLiteral& self) -> double {
           return  self.getValueAsApproximateDouble();
        })
        .def("getLocation", [](const clang::FloatingLiteral& self) -> clang::SourceLocation {
           return  self.getLocation();
        })
        .def("setLocation", []( clang::FloatingLiteral& self, clang::SourceLocation L)  {
             self.setLocation(L);
        })
        .def("getLocStart", [](const clang::FloatingLiteral& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::FloatingLiteral& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::FloatingLiteral& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ImaginaryLiteral, stmt_deleter<clang::ImaginaryLiteral>::type>(m, "ImaginaryLiteral" , py::base<clang::Expr>())
        .def("getSubExpr", [](const clang::ImaginaryLiteral& self) -> const clang::Expr * {
           return  self.getSubExpr();
        })
        .def("getSubExpr", []( clang::ImaginaryLiteral& self) -> clang::Expr * {
           return  self.getSubExpr();
        })
        .def("setSubExpr", []( clang::ImaginaryLiteral& self, clang::Expr * E)  {
             self.setSubExpr(E);
        })
        .def("getLocStart", [](const clang::ImaginaryLiteral& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ImaginaryLiteral& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::ImaginaryLiteral& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::StringLiteral, stmt_deleter<clang::StringLiteral>::type>(m, "StringLiteral" , py::base<clang::Expr>())
        .def("getString", [](const clang::StringLiteral& self) -> llvm::StringRef {
           return  self.getString();
        })
        .def("getBytes", [](const clang::StringLiteral& self) -> llvm::StringRef {
           return  self.getBytes();
        })
        //.def("outputString", [](const clang::StringLiteral& self, llvm::raw_ostream & OS)  {
        //     self.outputString(OS);
        //})
        .def("getCodeUnit", [](const clang::StringLiteral& self, unsigned long i) -> unsigned int {
           return  self.getCodeUnit(i);
        })
        .def("getByteLength", [](const clang::StringLiteral& self) -> unsigned int {
           return  self.getByteLength();
        })
        .def("getLength", [](const clang::StringLiteral& self) -> unsigned int {
           return  self.getLength();
        })
        .def("getCharByteWidth", [](const clang::StringLiteral& self) -> unsigned int {
           return  self.getCharByteWidth();
        })
        .def("setString", []( clang::StringLiteral& self, const clang::ASTContext & C , llvm::StringRef Str , clang::StringLiteral::StringKind Kind , bool IsPascal)  {
             self.setString(C, Str, Kind, IsPascal);
        })
        .def("getKind", [](const clang::StringLiteral& self) -> clang::StringLiteral::StringKind {
           return  self.getKind();
        })
        .def("isAscii", [](const clang::StringLiteral& self) -> bool {
           return  self.isAscii();
        })
        .def("isWide", [](const clang::StringLiteral& self) -> bool {
           return  self.isWide();
        })
        .def("isUTF8", [](const clang::StringLiteral& self) -> bool {
           return  self.isUTF8();
        })
        .def("isUTF16", [](const clang::StringLiteral& self) -> bool {
           return  self.isUTF16();
        })
        .def("isUTF32", [](const clang::StringLiteral& self) -> bool {
           return  self.isUTF32();
        })
        .def("isPascal", [](const clang::StringLiteral& self) -> bool {
           return  self.isPascal();
        })
        .def("containsNonAsciiOrNull", [](const clang::StringLiteral& self) -> bool {
           return  self.containsNonAsciiOrNull();
        })
        .def("getNumConcatenated", [](const clang::StringLiteral& self) -> unsigned int {
           return  self.getNumConcatenated();
        })
        .def("getStrTokenLoc", [](const clang::StringLiteral& self, unsigned int TokNum) -> clang::SourceLocation {
           return  self.getStrTokenLoc(TokNum);
        })
        .def("setStrTokenLoc", []( clang::StringLiteral& self, unsigned int TokNum , clang::SourceLocation L)  {
             self.setStrTokenLoc(TokNum, L);
        })
        //.def("getLocationOfByte", [](const clang::StringLiteral& self, unsigned int ByteNo , const clang::SourceManager & SM , const clang::LangOptions & Features , const clang::TargetInfo & Target , unsigned int * StartToken , unsigned int * StartTokenByteOffset) -> clang::SourceLocation {
        //   return  self.getLocationOfByte(ByteNo, SM, Features, Target, StartToken, StartTokenByteOffset);
        //})
        .def("getLocStart", [](const clang::StringLiteral& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::StringLiteral& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::StringLiteral& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ParenExpr, stmt_deleter<clang::ParenExpr>::type>(m, "ParenExpr" , py::base<clang::Expr>())
        .def("getSubExpr", [](const clang::ParenExpr& self) -> const clang::Expr * {
           return  self.getSubExpr();
        })
        .def("getSubExpr", []( clang::ParenExpr& self) -> clang::Expr * {
           return  self.getSubExpr();
        })
        .def("setSubExpr", []( clang::ParenExpr& self, clang::Expr * E)  {
             self.setSubExpr(E);
        })
        .def("getLocStart", [](const clang::ParenExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ParenExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getLParen", [](const clang::ParenExpr& self) -> clang::SourceLocation {
           return  self.getLParen();
        })
        .def("setLParen", []( clang::ParenExpr& self, clang::SourceLocation Loc)  {
             self.setLParen(Loc);
        })
        .def("getRParen", [](const clang::ParenExpr& self) -> clang::SourceLocation {
           return  self.getRParen();
        })
        .def("setRParen", []( clang::ParenExpr& self, clang::SourceLocation Loc)  {
             self.setRParen(Loc);
        })
        //.def("children", []( clang::ParenExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::UnaryOperator, stmt_deleter<clang::UnaryOperator>::type>(m, "UnaryOperator" , py::base<clang::Expr>())
        .def("getOpcode", [](const clang::UnaryOperator& self) -> clang::UnaryOperatorKind {
           return  self.getOpcode();
        })
        .def("setOpcode", []( clang::UnaryOperator& self, clang::UnaryOperatorKind O)  {
             self.setOpcode(O);
        })
        .def("getSubExpr", [](const clang::UnaryOperator& self) -> clang::Expr * {
           return  self.getSubExpr();
        })
        .def("setSubExpr", []( clang::UnaryOperator& self, clang::Expr * E)  {
             self.setSubExpr(E);
        })
        .def("getOperatorLoc", [](const clang::UnaryOperator& self) -> clang::SourceLocation {
           return  self.getOperatorLoc();
        })
        .def("setOperatorLoc", []( clang::UnaryOperator& self, clang::SourceLocation L)  {
             self.setOperatorLoc(L);
        })
        .def("isPrefix", [](const clang::UnaryOperator& self) -> bool {
           return  self.isPrefix();
        })
        .def("isPostfix", [](const clang::UnaryOperator& self) -> bool {
           return  self.isPostfix();
        })
        .def("isIncrementOp", [](const clang::UnaryOperator& self) -> bool {
           return  self.isIncrementOp();
        })
        .def("isDecrementOp", [](const clang::UnaryOperator& self) -> bool {
           return  self.isDecrementOp();
        })
        .def("isIncrementDecrementOp", [](const clang::UnaryOperator& self) -> bool {
           return  self.isIncrementDecrementOp();
        })
        .def("isArithmeticOp", [](const clang::UnaryOperator& self) -> bool {
           return  self.isArithmeticOp();
        })
        .def("getLocStart", [](const clang::UnaryOperator& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::UnaryOperator& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getExprLoc", [](const clang::UnaryOperator& self) -> clang::SourceLocation {
           return  self.getExprLoc();
        })
        //.def("children", []( clang::UnaryOperator& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::OffsetOfExpr, stmt_deleter<clang::OffsetOfExpr>::type>(m, "OffsetOfExpr" , py::base<clang::Expr>())
        .def("getOperatorLoc", [](const clang::OffsetOfExpr& self) -> clang::SourceLocation {
           return  self.getOperatorLoc();
        })
        .def("setOperatorLoc", []( clang::OffsetOfExpr& self, clang::SourceLocation L)  {
             self.setOperatorLoc(L);
        })
        .def("getRParenLoc", [](const clang::OffsetOfExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("setRParenLoc", []( clang::OffsetOfExpr& self, clang::SourceLocation R)  {
             self.setRParenLoc(R);
        })
        .def("getTypeSourceInfo", [](const clang::OffsetOfExpr& self) -> clang::TypeSourceInfo * {
           return  self.getTypeSourceInfo();
        })
        .def("setTypeSourceInfo", []( clang::OffsetOfExpr& self, clang::TypeSourceInfo * tsi)  {
             self.setTypeSourceInfo(tsi);
        })
        //.def("getComponent", [](const clang::OffsetOfExpr& self, unsigned int Idx) -> const clang::OffsetOfNode & {
        //   return  self.getComponent(Idx);
        //})
        //.def("setComponent", []( clang::OffsetOfExpr& self, unsigned int Idx , clang::OffsetOfNode ON)  {
        //     self.setComponent(Idx, ON);
        //})
        .def("getNumComponents", [](const clang::OffsetOfExpr& self) -> unsigned int {
           return  self.getNumComponents();
        })
        .def("getIndexExpr", []( clang::OffsetOfExpr& self, unsigned int Idx) -> clang::Expr * {
           return  self.getIndexExpr(Idx);
        })
        .def("getIndexExpr", [](const clang::OffsetOfExpr& self, unsigned int Idx) -> const clang::Expr * {
           return  self.getIndexExpr(Idx);
        })
        .def("setIndexExpr", []( clang::OffsetOfExpr& self, unsigned int Idx , clang::Expr * E)  {
             self.setIndexExpr(Idx, E);
        })
        .def("getNumExpressions", [](const clang::OffsetOfExpr& self) -> unsigned int {
           return  self.getNumExpressions();
        })
        .def("getLocStart", [](const clang::OffsetOfExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::OffsetOfExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::OffsetOfExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::UnaryExprOrTypeTraitExpr, stmt_deleter<clang::UnaryExprOrTypeTraitExpr>::type>(m, "UnaryExprOrTypeTraitExpr" , py::base<clang::Expr>())
        .def("getKind", [](const clang::UnaryExprOrTypeTraitExpr& self) -> clang::UnaryExprOrTypeTrait {
           return  self.getKind();
        })
        .def("setKind", []( clang::UnaryExprOrTypeTraitExpr& self, clang::UnaryExprOrTypeTrait K)  {
             self.setKind(K);
        })
        .def("isArgumentType", [](const clang::UnaryExprOrTypeTraitExpr& self) -> bool {
           return  self.isArgumentType();
        })
        .def("getArgumentType", [](const clang::UnaryExprOrTypeTraitExpr& self) -> clang::QualType {
           return  self.getArgumentType();
        })
        .def("getArgumentTypeInfo", [](const clang::UnaryExprOrTypeTraitExpr& self) -> clang::TypeSourceInfo * {
           return  self.getArgumentTypeInfo();
        })
        .def("getArgumentExpr", []( clang::UnaryExprOrTypeTraitExpr& self) -> clang::Expr * {
           return  self.getArgumentExpr();
        })
        .def("getArgumentExpr", [](const clang::UnaryExprOrTypeTraitExpr& self) -> const clang::Expr * {
           return  self.getArgumentExpr();
        })
        .def("setArgument", []( clang::UnaryExprOrTypeTraitExpr& self, clang::Expr * E)  {
             self.setArgument(E);
        })
        .def("setArgument", []( clang::UnaryExprOrTypeTraitExpr& self, clang::TypeSourceInfo * TInfo)  {
             self.setArgument(TInfo);
        })
        .def("getTypeOfArgument", [](const clang::UnaryExprOrTypeTraitExpr& self) -> clang::QualType {
           return  self.getTypeOfArgument();
        })
        .def("getOperatorLoc", [](const clang::UnaryExprOrTypeTraitExpr& self) -> clang::SourceLocation {
           return  self.getOperatorLoc();
        })
        .def("setOperatorLoc", []( clang::UnaryExprOrTypeTraitExpr& self, clang::SourceLocation L)  {
             self.setOperatorLoc(L);
        })
        .def("getRParenLoc", [](const clang::UnaryExprOrTypeTraitExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("setRParenLoc", []( clang::UnaryExprOrTypeTraitExpr& self, clang::SourceLocation L)  {
             self.setRParenLoc(L);
        })
        .def("getLocStart", [](const clang::UnaryExprOrTypeTraitExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::UnaryExprOrTypeTraitExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::UnaryExprOrTypeTraitExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ArraySubscriptExpr, stmt_deleter<clang::ArraySubscriptExpr>::type>(m, "ArraySubscriptExpr" , py::base<clang::Expr>())
        .def("getLHS", []( clang::ArraySubscriptExpr& self) -> clang::Expr * {
           return  self.getLHS();
        })
        .def("getLHS", [](const clang::ArraySubscriptExpr& self) -> const clang::Expr * {
           return  self.getLHS();
        })
        .def("setLHS", []( clang::ArraySubscriptExpr& self, clang::Expr * E)  {
             self.setLHS(E);
        })
        .def("getRHS", []( clang::ArraySubscriptExpr& self) -> clang::Expr * {
           return  self.getRHS();
        })
        .def("getRHS", [](const clang::ArraySubscriptExpr& self) -> const clang::Expr * {
           return  self.getRHS();
        })
        .def("setRHS", []( clang::ArraySubscriptExpr& self, clang::Expr * E)  {
             self.setRHS(E);
        })
        .def("getBase", []( clang::ArraySubscriptExpr& self) -> clang::Expr * {
           return  self.getBase();
        })
        .def("getBase", [](const clang::ArraySubscriptExpr& self) -> const clang::Expr * {
           return  self.getBase();
        })
        .def("getIdx", []( clang::ArraySubscriptExpr& self) -> clang::Expr * {
           return  self.getIdx();
        })
        .def("getIdx", [](const clang::ArraySubscriptExpr& self) -> const clang::Expr * {
           return  self.getIdx();
        })
        .def("getLocStart", [](const clang::ArraySubscriptExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ArraySubscriptExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getRBracketLoc", [](const clang::ArraySubscriptExpr& self) -> clang::SourceLocation {
           return  self.getRBracketLoc();
        })
        .def("setRBracketLoc", []( clang::ArraySubscriptExpr& self, clang::SourceLocation L)  {
             self.setRBracketLoc(L);
        })
        .def("getExprLoc", [](const clang::ArraySubscriptExpr& self) -> clang::SourceLocation {
           return  self.getExprLoc();
        })
        //.def("children", []( clang::ArraySubscriptExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CallExpr, stmt_deleter<clang::CallExpr>::type>(m, "CallExpr" , py::base<clang::Expr>())
        .def("getCallee", [](const clang::CallExpr& self) -> const clang::Expr * {
           return  self.getCallee();
        })
        .def("getCallee", []( clang::CallExpr& self) -> clang::Expr * {
           return  self.getCallee();
        })
        .def("setCallee", []( clang::CallExpr& self, clang::Expr * F)  {
             self.setCallee(F);
        })
        .def("getCalleeDecl", []( clang::CallExpr& self) -> clang::Decl * {
           return  self.getCalleeDecl();
        })
        .def("getCalleeDecl", [](const clang::CallExpr& self) -> const clang::Decl * {
           return  self.getCalleeDecl();
        })
        .def("getDirectCallee", []( clang::CallExpr& self) -> clang::FunctionDecl * {
           return  self.getDirectCallee();
        })
        .def("getDirectCallee", [](const clang::CallExpr& self) -> const clang::FunctionDecl * {
           return  self.getDirectCallee();
        })
        .def("getNumArgs", [](const clang::CallExpr& self) -> unsigned int {
           return  self.getNumArgs();
        })
        .def("getArg", []( clang::CallExpr& self, unsigned int Arg) -> clang::Expr * {
           return  self.getArg(Arg);
        })
        .def("getArg", [](const clang::CallExpr& self, unsigned int Arg) -> const clang::Expr * {
           return  self.getArg(Arg);
        })
        .def("setArg", []( clang::CallExpr& self, unsigned int Arg , clang::Expr * ArgExpr)  {
             self.setArg(Arg, ArgExpr);
        })
        .def("setNumArgs", []( clang::CallExpr& self, const clang::ASTContext & C , unsigned int NumArgs)  {
             self.setNumArgs(C, NumArgs);
        })
        //.def("arguments", []( clang::CallExpr& self) -> llvm::iterator_range<clang::Stmt::ExprIterator> {
        //   return  self.arguments();
        //})
        //.def("arguments", [](const clang::CallExpr& self) -> llvm::iterator_range<clang::Stmt::ConstExprIterator> {
        //   return  self.arguments();
        //})
        //.def("getRawSubExprs", []( clang::CallExpr& self) -> llvm::ArrayRef<clang::Stmt *> {
        //   return  self.getRawSubExprs();
        //})
        .def("getNumCommas", [](const clang::CallExpr& self) -> unsigned int {
           return  self.getNumCommas();
        })
        .def("getBuiltinCallee", [](const clang::CallExpr& self) -> unsigned int {
           return  self.getBuiltinCallee();
        })
        .def("isUnevaluatedBuiltinCall", [](const clang::CallExpr& self, const clang::ASTContext & Ctx) -> bool {
           return  self.isUnevaluatedBuiltinCall(Ctx);
        })
        .def("getCallReturnType", [](const clang::CallExpr& self, const clang::ASTContext & Ctx) -> clang::QualType {
           return  self.getCallReturnType(Ctx);
        })
        .def("getRParenLoc", [](const clang::CallExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("setRParenLoc", []( clang::CallExpr& self, clang::SourceLocation L)  {
             self.setRParenLoc(L);
        })
        .def("getLocStart", [](const clang::CallExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CallExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CallExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::MemberExpr, stmt_deleter<clang::MemberExpr>::type>(m, "MemberExpr" , py::base<clang::Expr>())
        .def("setBase", []( clang::MemberExpr& self, clang::Expr * E)  {
             self.setBase(E);
        })
        .def("getBase", [](const clang::MemberExpr& self) -> clang::Expr * {
           return  self.getBase();
        })
        .def("getMemberDecl", [](const clang::MemberExpr& self) -> clang::ValueDecl * {
           return  self.getMemberDecl();
        })
        .def("setMemberDecl", []( clang::MemberExpr& self, clang::ValueDecl * D)  {
             self.setMemberDecl(D);
        })
        //.def("getFoundDecl", [](const clang::MemberExpr& self) -> clang::DeclAccessPair {
        //   return  self.getFoundDecl();
        //})
        .def("hasQualifier", [](const clang::MemberExpr& self) -> bool {
           return  self.hasQualifier();
        })
        //.def("getQualifierLoc", [](const clang::MemberExpr& self) -> clang::NestedNameSpecifierLoc {
        //   return  self.getQualifierLoc();
        //})
        //.def("getQualifier", [](const clang::MemberExpr& self) -> clang::NestedNameSpecifier * {
        //   return  self.getQualifier();
        //})
        .def("getTemplateKeywordLoc", [](const clang::MemberExpr& self) -> clang::SourceLocation {
           return  self.getTemplateKeywordLoc();
        })
        .def("getLAngleLoc", [](const clang::MemberExpr& self) -> clang::SourceLocation {
           return  self.getLAngleLoc();
        })
        .def("getRAngleLoc", [](const clang::MemberExpr& self) -> clang::SourceLocation {
           return  self.getRAngleLoc();
        })
        .def("hasTemplateKeyword", [](const clang::MemberExpr& self) -> bool {
           return  self.hasTemplateKeyword();
        })
        .def("hasExplicitTemplateArgs", [](const clang::MemberExpr& self) -> bool {
           return  self.hasExplicitTemplateArgs();
        })
        //.def("copyTemplateArgumentsInto", [](const clang::MemberExpr& self, clang::TemplateArgumentListInfo & List)  {
        //     self.copyTemplateArgumentsInto(List);
        //})
        //.def("getTemplateArgs", [](const clang::MemberExpr& self) -> const clang::TemplateArgumentLoc * {
        //   return  self.getTemplateArgs();
        //})
        .def("getNumTemplateArgs", [](const clang::MemberExpr& self) -> unsigned int {
           return  self.getNumTemplateArgs();
        })
        .def("getMemberNameInfo", [](const clang::MemberExpr& self) -> clang::DeclarationNameInfo {
           return  self.getMemberNameInfo();
        })
        .def("getOperatorLoc", [](const clang::MemberExpr& self) -> clang::SourceLocation {
           return  self.getOperatorLoc();
        })
        .def("isArrow", [](const clang::MemberExpr& self) -> bool {
           return  self.isArrow();
        })
        .def("setArrow", []( clang::MemberExpr& self, bool A)  {
             self.setArrow(A);
        })
        .def("getMemberLoc", [](const clang::MemberExpr& self) -> clang::SourceLocation {
           return  self.getMemberLoc();
        })
        .def("setMemberLoc", []( clang::MemberExpr& self, clang::SourceLocation L)  {
             self.setMemberLoc(L);
        })
        .def("getLocStart", [](const clang::MemberExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::MemberExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getExprLoc", [](const clang::MemberExpr& self) -> clang::SourceLocation {
           return  self.getExprLoc();
        })
        .def("isImplicitAccess", [](const clang::MemberExpr& self) -> bool {
           return  self.isImplicitAccess();
        })
        .def("hadMultipleCandidates", [](const clang::MemberExpr& self) -> bool {
           return  self.hadMultipleCandidates();
        })
        .def("setHadMultipleCandidates", []( clang::MemberExpr& self, bool V)  {
             self.setHadMultipleCandidates(V);
        })
        //.def("performsVirtualDispatch", [](const clang::MemberExpr& self, const clang::LangOptions & LO) -> bool {
        //   return  self.performsVirtualDispatch(LO);
        //})
        //.def("children", []( clang::MemberExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CompoundLiteralExpr, stmt_deleter<clang::CompoundLiteralExpr>::type>(m, "CompoundLiteralExpr" , py::base<clang::Expr>())
        .def("getInitializer", [](const clang::CompoundLiteralExpr& self) -> const clang::Expr * {
           return  self.getInitializer();
        })
        .def("getInitializer", []( clang::CompoundLiteralExpr& self) -> clang::Expr * {
           return  self.getInitializer();
        })
        .def("setInitializer", []( clang::CompoundLiteralExpr& self, clang::Expr * E)  {
             self.setInitializer(E);
        })
        .def("isFileScope", [](const clang::CompoundLiteralExpr& self) -> bool {
           return  self.isFileScope();
        })
        .def("setFileScope", []( clang::CompoundLiteralExpr& self, bool FS)  {
             self.setFileScope(FS);
        })
        .def("getLParenLoc", [](const clang::CompoundLiteralExpr& self) -> clang::SourceLocation {
           return  self.getLParenLoc();
        })
        .def("setLParenLoc", []( clang::CompoundLiteralExpr& self, clang::SourceLocation L)  {
             self.setLParenLoc(L);
        })
        .def("getTypeSourceInfo", [](const clang::CompoundLiteralExpr& self) -> clang::TypeSourceInfo * {
           return  self.getTypeSourceInfo();
        })
        .def("setTypeSourceInfo", []( clang::CompoundLiteralExpr& self, clang::TypeSourceInfo * tinfo)  {
             self.setTypeSourceInfo(tinfo);
        })
        .def("getLocStart", [](const clang::CompoundLiteralExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CompoundLiteralExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::CompoundLiteralExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::CastExpr, stmt_deleter<clang::CastExpr>::type>(m, "CastExpr" , py::base<clang::Expr>())
        .def("getCastKind", [](const clang::CastExpr& self) -> clang::CastKind {
           return  self.getCastKind();
        })
        .def("setCastKind", []( clang::CastExpr& self, clang::CastKind K)  {
             self.setCastKind(K);
        })
        .def("getCastKindName", [](const clang::CastExpr& self) -> const char * {
           return  self.getCastKindName();
        })
        .def("getSubExpr", []( clang::CastExpr& self) -> clang::Expr * {
           return  self.getSubExpr();
        })
        .def("getSubExpr", [](const clang::CastExpr& self) -> const clang::Expr * {
           return  self.getSubExpr();
        })
        .def("setSubExpr", []( clang::CastExpr& self, clang::Expr * E)  {
             self.setSubExpr(E);
        })
        .def("getSubExprAsWritten", []( clang::CastExpr& self) -> clang::Expr * {
           return  self.getSubExprAsWritten();
        })
        .def("getSubExprAsWritten", [](const clang::CastExpr& self) -> const clang::Expr * {
           return  self.getSubExprAsWritten();
        })
        .def("path_empty", [](const clang::CastExpr& self) -> bool {
           return  self.path_empty();
        })
        .def("path_size", [](const clang::CastExpr& self) -> unsigned int {
           return  self.path_size();
        })
        //.def("children", []( clang::CastExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ImplicitCastExpr, stmt_deleter<clang::ImplicitCastExpr>::type>(m, "ImplicitCastExpr" , py::base<clang::CastExpr>())
        .def("getLocStart", [](const clang::ImplicitCastExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ImplicitCastExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
    ;

    py::class_<clang::ExplicitCastExpr, stmt_deleter<clang::ExplicitCastExpr>::type>(m, "ExplicitCastExpr" , py::base<clang::CastExpr>())
        .def("getTypeInfoAsWritten", [](const clang::ExplicitCastExpr& self) -> clang::TypeSourceInfo * {
           return  self.getTypeInfoAsWritten();
        })
        .def("setTypeInfoAsWritten", []( clang::ExplicitCastExpr& self, clang::TypeSourceInfo * writtenTy)  {
             self.setTypeInfoAsWritten(writtenTy);
        })
        .def("getTypeAsWritten", [](const clang::ExplicitCastExpr& self) -> clang::QualType {
           return  self.getTypeAsWritten();
        })
    ;

    py::class_<clang::CStyleCastExpr, stmt_deleter<clang::CStyleCastExpr>::type>(m, "CStyleCastExpr" , py::base<clang::ExplicitCastExpr>())
        .def("getLParenLoc", [](const clang::CStyleCastExpr& self) -> clang::SourceLocation {
           return  self.getLParenLoc();
        })
        .def("setLParenLoc", []( clang::CStyleCastExpr& self, clang::SourceLocation L)  {
             self.setLParenLoc(L);
        })
        .def("getRParenLoc", [](const clang::CStyleCastExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("setRParenLoc", []( clang::CStyleCastExpr& self, clang::SourceLocation L)  {
             self.setRParenLoc(L);
        })
        .def("getLocStart", [](const clang::CStyleCastExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CStyleCastExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
    ;

    py::class_<clang::BinaryOperator, stmt_deleter<clang::BinaryOperator>::type>(m, "BinaryOperator" , py::base<clang::Expr>())
        .def("getExprLoc", [](const clang::BinaryOperator& self) -> clang::SourceLocation {
           return  self.getExprLoc();
        })
        .def("getOperatorLoc", [](const clang::BinaryOperator& self) -> clang::SourceLocation {
           return  self.getOperatorLoc();
        })
        .def("setOperatorLoc", []( clang::BinaryOperator& self, clang::SourceLocation L)  {
             self.setOperatorLoc(L);
        })
        .def("getOpcode", [](const clang::BinaryOperator& self) -> clang::BinaryOperatorKind {
           return  self.getOpcode();
        })
        .def("setOpcode", []( clang::BinaryOperator& self, clang::BinaryOperatorKind O)  {
             self.setOpcode(O);
        })
        .def("getLHS", [](const clang::BinaryOperator& self) -> clang::Expr * {
           return  self.getLHS();
        })
        .def("setLHS", []( clang::BinaryOperator& self, clang::Expr * E)  {
             self.setLHS(E);
        })
        .def("getRHS", [](const clang::BinaryOperator& self) -> clang::Expr * {
           return  self.getRHS();
        })
        .def("setRHS", []( clang::BinaryOperator& self, clang::Expr * E)  {
             self.setRHS(E);
        })
        .def("getLocStart", [](const clang::BinaryOperator& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::BinaryOperator& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getOpcodeStr", [](const clang::BinaryOperator& self) -> llvm::StringRef {
           return  self.getOpcodeStr();
        })
        .def("isPtrMemOp", [](const clang::BinaryOperator& self) -> bool {
           return  self.isPtrMemOp();
        })
        .def("isMultiplicativeOp", [](const clang::BinaryOperator& self) -> bool {
           return  self.isMultiplicativeOp();
        })
        .def("isAdditiveOp", [](const clang::BinaryOperator& self) -> bool {
           return  self.isAdditiveOp();
        })
        .def("isShiftOp", [](const clang::BinaryOperator& self) -> bool {
           return  self.isShiftOp();
        })
        .def("isBitwiseOp", [](const clang::BinaryOperator& self) -> bool {
           return  self.isBitwiseOp();
        })
        .def("isRelationalOp", [](const clang::BinaryOperator& self) -> bool {
           return  self.isRelationalOp();
        })
        .def("isEqualityOp", [](const clang::BinaryOperator& self) -> bool {
           return  self.isEqualityOp();
        })
        .def("isComparisonOp", [](const clang::BinaryOperator& self) -> bool {
           return  self.isComparisonOp();
        })
        .def("isLogicalOp", [](const clang::BinaryOperator& self) -> bool {
           return  self.isLogicalOp();
        })
        .def("isAssignmentOp", [](const clang::BinaryOperator& self) -> bool {
           return  self.isAssignmentOp();
        })
        .def("isCompoundAssignmentOp", [](const clang::BinaryOperator& self) -> bool {
           return  self.isCompoundAssignmentOp();
        })
        .def("isShiftAssignOp", [](const clang::BinaryOperator& self) -> bool {
           return  self.isShiftAssignOp();
        })
        //.def("children", []( clang::BinaryOperator& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
        .def("setFPContractable", []( clang::BinaryOperator& self, bool FPC)  {
             self.setFPContractable(FPC);
        })
        .def("isFPContractable", [](const clang::BinaryOperator& self) -> bool {
           return  self.isFPContractable();
        })
    ;

    py::class_<clang::CompoundAssignOperator, stmt_deleter<clang::CompoundAssignOperator>::type>(m, "CompoundAssignOperator" , py::base<clang::BinaryOperator>())
        .def("getComputationLHSType", [](const clang::CompoundAssignOperator& self) -> clang::QualType {
           return  self.getComputationLHSType();
        })
        .def("setComputationLHSType", []( clang::CompoundAssignOperator& self, clang::QualType T)  {
             self.setComputationLHSType(T);
        })
        .def("getComputationResultType", [](const clang::CompoundAssignOperator& self) -> clang::QualType {
           return  self.getComputationResultType();
        })
        .def("setComputationResultType", []( clang::CompoundAssignOperator& self, clang::QualType T)  {
             self.setComputationResultType(T);
        })
    ;

    py::class_<clang::AbstractConditionalOperator, stmt_deleter<clang::AbstractConditionalOperator>::type>(m, "AbstractConditionalOperator" , py::base<clang::Expr>())
        .def("getCond", [](const clang::AbstractConditionalOperator& self) -> clang::Expr * {
           return  self.getCond();
        })
        .def("getTrueExpr", [](const clang::AbstractConditionalOperator& self) -> clang::Expr * {
           return  self.getTrueExpr();
        })
        .def("getFalseExpr", [](const clang::AbstractConditionalOperator& self) -> clang::Expr * {
           return  self.getFalseExpr();
        })
        .def("getQuestionLoc", [](const clang::AbstractConditionalOperator& self) -> clang::SourceLocation {
           return  self.getQuestionLoc();
        })
        .def("getColonLoc", [](const clang::AbstractConditionalOperator& self) -> clang::SourceLocation {
           return  self.getColonLoc();
        })
    ;

    py::class_<clang::ConditionalOperator, stmt_deleter<clang::ConditionalOperator>::type>(m, "ConditionalOperator" , py::base<clang::AbstractConditionalOperator>())
        .def("getCond", [](const clang::ConditionalOperator& self) -> clang::Expr * {
           return  self.getCond();
        })
        .def("getTrueExpr", [](const clang::ConditionalOperator& self) -> clang::Expr * {
           return  self.getTrueExpr();
        })
        .def("getFalseExpr", [](const clang::ConditionalOperator& self) -> clang::Expr * {
           return  self.getFalseExpr();
        })
        .def("getLHS", [](const clang::ConditionalOperator& self) -> clang::Expr * {
           return  self.getLHS();
        })
        .def("getRHS", [](const clang::ConditionalOperator& self) -> clang::Expr * {
           return  self.getRHS();
        })
        .def("getLocStart", [](const clang::ConditionalOperator& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ConditionalOperator& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::ConditionalOperator& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::BinaryConditionalOperator, stmt_deleter<clang::BinaryConditionalOperator>::type>(m, "BinaryConditionalOperator" , py::base<clang::AbstractConditionalOperator>())
        .def("getCommon", [](const clang::BinaryConditionalOperator& self) -> clang::Expr * {
           return  self.getCommon();
        })
        .def("getOpaqueValue", [](const clang::BinaryConditionalOperator& self) -> clang::OpaqueValueExpr * {
           return  self.getOpaqueValue();
        })
        .def("getCond", [](const clang::BinaryConditionalOperator& self) -> clang::Expr * {
           return  self.getCond();
        })
        .def("getTrueExpr", [](const clang::BinaryConditionalOperator& self) -> clang::Expr * {
           return  self.getTrueExpr();
        })
        .def("getFalseExpr", [](const clang::BinaryConditionalOperator& self) -> clang::Expr * {
           return  self.getFalseExpr();
        })
        .def("getLocStart", [](const clang::BinaryConditionalOperator& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::BinaryConditionalOperator& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::BinaryConditionalOperator& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::AddrLabelExpr, stmt_deleter<clang::AddrLabelExpr>::type>(m, "AddrLabelExpr" , py::base<clang::Expr>())
        .def("getAmpAmpLoc", [](const clang::AddrLabelExpr& self) -> clang::SourceLocation {
           return  self.getAmpAmpLoc();
        })
        .def("setAmpAmpLoc", []( clang::AddrLabelExpr& self, clang::SourceLocation L)  {
             self.setAmpAmpLoc(L);
        })
        .def("getLabelLoc", [](const clang::AddrLabelExpr& self) -> clang::SourceLocation {
           return  self.getLabelLoc();
        })
        .def("setLabelLoc", []( clang::AddrLabelExpr& self, clang::SourceLocation L)  {
             self.setLabelLoc(L);
        })
        .def("getLocStart", [](const clang::AddrLabelExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::AddrLabelExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getLabel", [](const clang::AddrLabelExpr& self) -> clang::LabelDecl * {
           return  self.getLabel();
        })
        .def("setLabel", []( clang::AddrLabelExpr& self, clang::LabelDecl * L)  {
             self.setLabel(L);
        })
        //.def("children", []( clang::AddrLabelExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::StmtExpr, stmt_deleter<clang::StmtExpr>::type>(m, "StmtExpr" , py::base<clang::Expr>())
        .def("getSubStmt", []( clang::StmtExpr& self) -> clang::CompoundStmt * {
           return  self.getSubStmt();
        })
        .def("getSubStmt", [](const clang::StmtExpr& self) -> const clang::CompoundStmt * {
           return  self.getSubStmt();
        })
        .def("setSubStmt", []( clang::StmtExpr& self, clang::CompoundStmt * S)  {
             self.setSubStmt(S);
        })
        .def("getLocStart", [](const clang::StmtExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::StmtExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getLParenLoc", [](const clang::StmtExpr& self) -> clang::SourceLocation {
           return  self.getLParenLoc();
        })
        .def("setLParenLoc", []( clang::StmtExpr& self, clang::SourceLocation L)  {
             self.setLParenLoc(L);
        })
        .def("getRParenLoc", [](const clang::StmtExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("setRParenLoc", []( clang::StmtExpr& self, clang::SourceLocation L)  {
             self.setRParenLoc(L);
        })
        //.def("children", []( clang::StmtExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ShuffleVectorExpr, stmt_deleter<clang::ShuffleVectorExpr>::type>(m, "ShuffleVectorExpr" , py::base<clang::Expr>())
        .def("getBuiltinLoc", [](const clang::ShuffleVectorExpr& self) -> clang::SourceLocation {
           return  self.getBuiltinLoc();
        })
        .def("setBuiltinLoc", []( clang::ShuffleVectorExpr& self, clang::SourceLocation L)  {
             self.setBuiltinLoc(L);
        })
        .def("getRParenLoc", [](const clang::ShuffleVectorExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("setRParenLoc", []( clang::ShuffleVectorExpr& self, clang::SourceLocation L)  {
             self.setRParenLoc(L);
        })
        .def("getLocStart", [](const clang::ShuffleVectorExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ShuffleVectorExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getNumSubExprs", [](const clang::ShuffleVectorExpr& self) -> unsigned int {
           return  self.getNumSubExprs();
        })
        .def("getExpr", []( clang::ShuffleVectorExpr& self, unsigned int Index) -> clang::Expr * {
           return  self.getExpr(Index);
        })
        .def("getExpr", [](const clang::ShuffleVectorExpr& self, unsigned int Index) -> const clang::Expr * {
           return  self.getExpr(Index);
        })
        //.def("setExprs", []( clang::ShuffleVectorExpr& self, const clang::ASTContext & C , llvm::ArrayRef<clang::Expr *> Exprs)  {
        //     self.setExprs(C, Exprs);
        //})
        //.def("getShuffleMaskIdx", [](const clang::ShuffleVectorExpr& self, const clang::ASTContext & Ctx , unsigned int N) -> llvm::APSInt {
        //   return  self.getShuffleMaskIdx(Ctx, N);
        //})
        //.def("children", []( clang::ShuffleVectorExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ConvertVectorExpr, stmt_deleter<clang::ConvertVectorExpr>::type>(m, "ConvertVectorExpr" , py::base<clang::Expr>())
        .def("getSrcExpr", [](const clang::ConvertVectorExpr& self) -> clang::Expr * {
           return  self.getSrcExpr();
        })
        .def("getTypeSourceInfo", [](const clang::ConvertVectorExpr& self) -> clang::TypeSourceInfo * {
           return  self.getTypeSourceInfo();
        })
        .def("setTypeSourceInfo", []( clang::ConvertVectorExpr& self, clang::TypeSourceInfo * ti)  {
             self.setTypeSourceInfo(ti);
        })
        .def("getBuiltinLoc", [](const clang::ConvertVectorExpr& self) -> clang::SourceLocation {
           return  self.getBuiltinLoc();
        })
        .def("getRParenLoc", [](const clang::ConvertVectorExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("getLocStart", [](const clang::ConvertVectorExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ConvertVectorExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::ConvertVectorExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ChooseExpr, stmt_deleter<clang::ChooseExpr>::type>(m, "ChooseExpr" , py::base<clang::Expr>())
        .def("isConditionTrue", [](const clang::ChooseExpr& self) -> bool {
           return  self.isConditionTrue();
        })
        .def("setIsConditionTrue", []( clang::ChooseExpr& self, bool isTrue)  {
             self.setIsConditionTrue(isTrue);
        })
        .def("isConditionDependent", [](const clang::ChooseExpr& self) -> bool {
           return  self.isConditionDependent();
        })
        .def("getChosenSubExpr", [](const clang::ChooseExpr& self) -> clang::Expr * {
           return  self.getChosenSubExpr();
        })
        .def("getCond", [](const clang::ChooseExpr& self) -> clang::Expr * {
           return  self.getCond();
        })
        .def("setCond", []( clang::ChooseExpr& self, clang::Expr * E)  {
             self.setCond(E);
        })
        .def("getLHS", [](const clang::ChooseExpr& self) -> clang::Expr * {
           return  self.getLHS();
        })
        .def("setLHS", []( clang::ChooseExpr& self, clang::Expr * E)  {
             self.setLHS(E);
        })
        .def("getRHS", [](const clang::ChooseExpr& self) -> clang::Expr * {
           return  self.getRHS();
        })
        .def("setRHS", []( clang::ChooseExpr& self, clang::Expr * E)  {
             self.setRHS(E);
        })
        .def("getBuiltinLoc", [](const clang::ChooseExpr& self) -> clang::SourceLocation {
           return  self.getBuiltinLoc();
        })
        .def("setBuiltinLoc", []( clang::ChooseExpr& self, clang::SourceLocation L)  {
             self.setBuiltinLoc(L);
        })
        .def("getRParenLoc", [](const clang::ChooseExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("setRParenLoc", []( clang::ChooseExpr& self, clang::SourceLocation L)  {
             self.setRParenLoc(L);
        })
        .def("getLocStart", [](const clang::ChooseExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ChooseExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::ChooseExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::GNUNullExpr, stmt_deleter<clang::GNUNullExpr>::type>(m, "GNUNullExpr" , py::base<clang::Expr>())
        .def("getTokenLocation", [](const clang::GNUNullExpr& self) -> clang::SourceLocation {
           return  self.getTokenLocation();
        })
        .def("setTokenLocation", []( clang::GNUNullExpr& self, clang::SourceLocation L)  {
             self.setTokenLocation(L);
        })
        .def("getLocStart", [](const clang::GNUNullExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::GNUNullExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::GNUNullExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;
}
