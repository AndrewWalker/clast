
////////////////////////////////////////////////////////////////////////////////
// File autogenerated by clastgen
//  Clang - clang version 3.9.0-svn274595-1~exp1 (trunk)
//
// Warning. Changes made here will be overwritten.
////////////////////////////////////////////////////////////////////////////////
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include "internal.h"

#include <clang/AST/AST.h>
#include <clang/ASTMatchers/ASTMatchers.h>
#include <clang/ASTMatchers/ASTMatchFinder.h>


namespace py = pybind11;

void autogenerated_classes_2(pybind11::module& m)
{

    py::class_<clang::VAArgExpr, stmt_deleter<clang::VAArgExpr>::type>(m, "VAArgExpr" , py::base<clang::Expr>())
        .def("getSubExpr", [](const clang::VAArgExpr& self) -> const clang::Expr * {
           return  self.getSubExpr();
        })
        .def("getSubExpr", []( clang::VAArgExpr& self) -> clang::Expr * {
           return  self.getSubExpr();
        })
        .def("setSubExpr", []( clang::VAArgExpr& self, clang::Expr * E)  {
             self.setSubExpr(E);
        })
        .def("isMicrosoftABI", [](const clang::VAArgExpr& self) -> bool {
           return  self.isMicrosoftABI();
        })
        .def("setIsMicrosoftABI", []( clang::VAArgExpr& self, bool IsMS)  {
             self.setIsMicrosoftABI(IsMS);
        })
        .def("getWrittenTypeInfo", [](const clang::VAArgExpr& self) -> clang::TypeSourceInfo * {
           return  self.getWrittenTypeInfo();
        })
        .def("setWrittenTypeInfo", []( clang::VAArgExpr& self, clang::TypeSourceInfo * TI)  {
             self.setWrittenTypeInfo(TI);
        })
        .def("getBuiltinLoc", [](const clang::VAArgExpr& self) -> clang::SourceLocation {
           return  self.getBuiltinLoc();
        })
        .def("setBuiltinLoc", []( clang::VAArgExpr& self, clang::SourceLocation L)  {
             self.setBuiltinLoc(L);
        })
        .def("getRParenLoc", [](const clang::VAArgExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("setRParenLoc", []( clang::VAArgExpr& self, clang::SourceLocation L)  {
             self.setRParenLoc(L);
        })
        .def("getLocStart", [](const clang::VAArgExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::VAArgExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::VAArgExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::InitListExpr, stmt_deleter<clang::InitListExpr>::type>(m, "InitListExpr" , py::base<clang::Expr>())
        .def("getNumInits", [](const clang::InitListExpr& self) -> unsigned int {
           return  self.getNumInits();
        })
        //.def("inits", []( clang::InitListExpr& self) -> llvm::ArrayRef<clang::Expr *> {
        //   return  self.inits();
        //})
        .def("getInit", [](const clang::InitListExpr& self, unsigned int Init) -> const clang::Expr * {
           return  self.getInit(Init);
        })
        .def("getInit", []( clang::InitListExpr& self, unsigned int Init) -> clang::Expr * {
           return  self.getInit(Init);
        })
        .def("setInit", []( clang::InitListExpr& self, unsigned int Init , clang::Expr * expr)  {
             self.setInit(Init, expr);
        })
        .def("reserveInits", []( clang::InitListExpr& self, const clang::ASTContext & C , unsigned int NumInits)  {
             self.reserveInits(C, NumInits);
        })
        .def("resizeInits", []( clang::InitListExpr& self, const clang::ASTContext & Context , unsigned int NumInits)  {
             self.resizeInits(Context, NumInits);
        })
        .def("updateInit", []( clang::InitListExpr& self, const clang::ASTContext & C , unsigned int Init , clang::Expr * expr) -> clang::Expr * {
           return  self.updateInit(C, Init, expr);
        })
        .def("getArrayFiller", []( clang::InitListExpr& self) -> clang::Expr * {
           return  self.getArrayFiller();
        })
        .def("getArrayFiller", [](const clang::InitListExpr& self) -> const clang::Expr * {
           return  self.getArrayFiller();
        })
        .def("setArrayFiller", []( clang::InitListExpr& self, clang::Expr * filler)  {
             self.setArrayFiller(filler);
        })
        .def("hasArrayFiller", [](const clang::InitListExpr& self) -> bool {
           return  self.hasArrayFiller();
        })
        .def("getInitializedFieldInUnion", []( clang::InitListExpr& self) -> clang::FieldDecl * {
           return  self.getInitializedFieldInUnion();
        })
        .def("getInitializedFieldInUnion", [](const clang::InitListExpr& self) -> const clang::FieldDecl * {
           return  self.getInitializedFieldInUnion();
        })
        .def("setInitializedFieldInUnion", []( clang::InitListExpr& self, clang::FieldDecl * FD)  {
             self.setInitializedFieldInUnion(FD);
        })
        .def("isExplicit", []( clang::InitListExpr& self) -> bool {
           return  self.isExplicit();
        })
        .def("isStringLiteralInit", [](const clang::InitListExpr& self) -> bool {
           return  self.isStringLiteralInit();
        })
        .def("getLBraceLoc", [](const clang::InitListExpr& self) -> clang::SourceLocation {
           return  self.getLBraceLoc();
        })
        .def("setLBraceLoc", []( clang::InitListExpr& self, clang::SourceLocation Loc)  {
             self.setLBraceLoc(Loc);
        })
        .def("getRBraceLoc", [](const clang::InitListExpr& self) -> clang::SourceLocation {
           return  self.getRBraceLoc();
        })
        .def("setRBraceLoc", []( clang::InitListExpr& self, clang::SourceLocation Loc)  {
             self.setRBraceLoc(Loc);
        })
        .def("isSemanticForm", [](const clang::InitListExpr& self) -> bool {
           return  self.isSemanticForm();
        })
        .def("getSemanticForm", [](const clang::InitListExpr& self) -> clang::InitListExpr * {
           return  self.getSemanticForm();
        })
        .def("getSyntacticForm", [](const clang::InitListExpr& self) -> clang::InitListExpr * {
           return  self.getSyntacticForm();
        })
        .def("setSyntacticForm", []( clang::InitListExpr& self, clang::InitListExpr * Init)  {
             self.setSyntacticForm(Init);
        })
        .def("hadArrayRangeDesignator", [](const clang::InitListExpr& self) -> bool {
           return  self.hadArrayRangeDesignator();
        })
        .def("sawArrayRangeDesignator", []( clang::InitListExpr& self, bool ARD)  {
             self.sawArrayRangeDesignator(ARD);
        })
        .def("getLocStart", [](const clang::InitListExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::InitListExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::InitListExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::DesignatedInitExpr, stmt_deleter<clang::DesignatedInitExpr>::type>(m, "DesignatedInitExpr" , py::base<clang::Expr>())
        .def("size", [](const clang::DesignatedInitExpr& self) -> unsigned int {
           return  self.size();
        })
        //.def("designators", []( clang::DesignatedInitExpr& self) -> llvm::MutableArrayRef<clang::DesignatedInitExpr::Designator> {
        //   return  self.designators();
        //})
        //.def("designators", [](const clang::DesignatedInitExpr& self) -> llvm::ArrayRef<clang::DesignatedInitExpr::Designator> {
        //   return  self.designators();
        //})
        //.def("getDesignator", []( clang::DesignatedInitExpr& self, unsigned int Idx) -> clang::DesignatedInitExpr::Designator * {
        //   return  self.getDesignator(Idx);
        //})
        //.def("setDesignators", []( clang::DesignatedInitExpr& self, const clang::ASTContext & C , const clang::DesignatedInitExpr::Designator * Desigs , unsigned int NumDesigs)  {
        //     self.setDesignators(C, Desigs, NumDesigs);
        //})
        //.def("getArrayIndex", [](const clang::DesignatedInitExpr& self, const clang::DesignatedInitExpr::Designator & D) -> clang::Expr * {
        //   return  self.getArrayIndex(D);
        //})
        //.def("getArrayRangeStart", [](const clang::DesignatedInitExpr& self, const clang::DesignatedInitExpr::Designator & D) -> clang::Expr * {
        //   return  self.getArrayRangeStart(D);
        //})
        //.def("getArrayRangeEnd", [](const clang::DesignatedInitExpr& self, const clang::DesignatedInitExpr::Designator & D) -> clang::Expr * {
        //   return  self.getArrayRangeEnd(D);
        //})
        .def("getEqualOrColonLoc", [](const clang::DesignatedInitExpr& self) -> clang::SourceLocation {
           return  self.getEqualOrColonLoc();
        })
        .def("setEqualOrColonLoc", []( clang::DesignatedInitExpr& self, clang::SourceLocation L)  {
             self.setEqualOrColonLoc(L);
        })
        .def("usesGNUSyntax", [](const clang::DesignatedInitExpr& self) -> bool {
           return  self.usesGNUSyntax();
        })
        .def("setGNUSyntax", []( clang::DesignatedInitExpr& self, bool GNU)  {
             self.setGNUSyntax(GNU);
        })
        .def("getInit", [](const clang::DesignatedInitExpr& self) -> clang::Expr * {
           return  self.getInit();
        })
        .def("setInit", []( clang::DesignatedInitExpr& self, clang::Expr * init)  {
             self.setInit(init);
        })
        .def("getNumSubExprs", [](const clang::DesignatedInitExpr& self) -> unsigned int {
           return  self.getNumSubExprs();
        })
        .def("getSubExpr", [](const clang::DesignatedInitExpr& self, unsigned int Idx) -> clang::Expr * {
           return  self.getSubExpr(Idx);
        })
        .def("setSubExpr", []( clang::DesignatedInitExpr& self, unsigned int Idx , clang::Expr * E)  {
             self.setSubExpr(Idx, E);
        })
        //.def("ExpandDesignator", []( clang::DesignatedInitExpr& self, const clang::ASTContext & C , unsigned int Idx , const clang::DesignatedInitExpr::Designator * First , const clang::DesignatedInitExpr::Designator * Last)  {
        //     self.ExpandDesignator(C, Idx, First, Last);
        //})
        .def("getDesignatorsSourceRange", [](const clang::DesignatedInitExpr& self) -> clang::SourceRange {
           return  self.getDesignatorsSourceRange();
        })
        .def("getLocStart", [](const clang::DesignatedInitExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::DesignatedInitExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::DesignatedInitExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::NoInitExpr, stmt_deleter<clang::NoInitExpr>::type>(m, "NoInitExpr" , py::base<clang::Expr>())
        .def("getLocStart", [](const clang::NoInitExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::NoInitExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::NoInitExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::DesignatedInitUpdateExpr, stmt_deleter<clang::DesignatedInitUpdateExpr>::type>(m, "DesignatedInitUpdateExpr" , py::base<clang::Expr>())
        .def("getLocStart", [](const clang::DesignatedInitUpdateExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::DesignatedInitUpdateExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getBase", [](const clang::DesignatedInitUpdateExpr& self) -> clang::Expr * {
           return  self.getBase();
        })
        .def("setBase", []( clang::DesignatedInitUpdateExpr& self, clang::Expr * Base)  {
             self.setBase(Base);
        })
        .def("getUpdater", [](const clang::DesignatedInitUpdateExpr& self) -> clang::InitListExpr * {
           return  self.getUpdater();
        })
        .def("setUpdater", []( clang::DesignatedInitUpdateExpr& self, clang::Expr * Updater)  {
             self.setUpdater(Updater);
        })
        //.def("children", []( clang::DesignatedInitUpdateExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ImplicitValueInitExpr, stmt_deleter<clang::ImplicitValueInitExpr>::type>(m, "ImplicitValueInitExpr" , py::base<clang::Expr>())
        .def("getLocStart", [](const clang::ImplicitValueInitExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ImplicitValueInitExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::ImplicitValueInitExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ParenListExpr, stmt_deleter<clang::ParenListExpr>::type>(m, "ParenListExpr" , py::base<clang::Expr>())
        .def("getNumExprs", [](const clang::ParenListExpr& self) -> unsigned int {
           return  self.getNumExprs();
        })
        .def("getExpr", [](const clang::ParenListExpr& self, unsigned int Init) -> const clang::Expr * {
           return  self.getExpr(Init);
        })
        .def("getExpr", []( clang::ParenListExpr& self, unsigned int Init) -> clang::Expr * {
           return  self.getExpr(Init);
        })
        //.def("exprs", []( clang::ParenListExpr& self) -> llvm::ArrayRef<clang::Expr *> {
        //   return  self.exprs();
        //})
        .def("getLParenLoc", [](const clang::ParenListExpr& self) -> clang::SourceLocation {
           return  self.getLParenLoc();
        })
        .def("getRParenLoc", [](const clang::ParenListExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("getLocStart", [](const clang::ParenListExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ParenListExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::ParenListExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::GenericSelectionExpr, stmt_deleter<clang::GenericSelectionExpr>::type>(m, "GenericSelectionExpr" , py::base<clang::Expr>())
        .def("getNumAssocs", [](const clang::GenericSelectionExpr& self) -> unsigned int {
           return  self.getNumAssocs();
        })
        .def("getGenericLoc", [](const clang::GenericSelectionExpr& self) -> clang::SourceLocation {
           return  self.getGenericLoc();
        })
        .def("getDefaultLoc", [](const clang::GenericSelectionExpr& self) -> clang::SourceLocation {
           return  self.getDefaultLoc();
        })
        .def("getRParenLoc", [](const clang::GenericSelectionExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("getAssocExpr", [](const clang::GenericSelectionExpr& self, unsigned int i) -> const clang::Expr * {
           return  self.getAssocExpr(i);
        })
        .def("getAssocExpr", []( clang::GenericSelectionExpr& self, unsigned int i) -> clang::Expr * {
           return  self.getAssocExpr(i);
        })
        .def("getAssocTypeSourceInfo", [](const clang::GenericSelectionExpr& self, unsigned int i) -> const clang::TypeSourceInfo * {
           return  self.getAssocTypeSourceInfo(i);
        })
        .def("getAssocTypeSourceInfo", []( clang::GenericSelectionExpr& self, unsigned int i) -> clang::TypeSourceInfo * {
           return  self.getAssocTypeSourceInfo(i);
        })
        .def("getAssocType", [](const clang::GenericSelectionExpr& self, unsigned int i) -> clang::QualType {
           return  self.getAssocType(i);
        })
        .def("getControllingExpr", [](const clang::GenericSelectionExpr& self) -> const clang::Expr * {
           return  self.getControllingExpr();
        })
        .def("getControllingExpr", []( clang::GenericSelectionExpr& self) -> clang::Expr * {
           return  self.getControllingExpr();
        })
        .def("isResultDependent", [](const clang::GenericSelectionExpr& self) -> bool {
           return  self.isResultDependent();
        })
        .def("getResultIndex", [](const clang::GenericSelectionExpr& self) -> unsigned int {
           return  self.getResultIndex();
        })
        .def("getResultExpr", [](const clang::GenericSelectionExpr& self) -> const clang::Expr * {
           return  self.getResultExpr();
        })
        .def("getResultExpr", []( clang::GenericSelectionExpr& self) -> clang::Expr * {
           return  self.getResultExpr();
        })
        .def("getLocStart", [](const clang::GenericSelectionExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::GenericSelectionExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::GenericSelectionExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::ExtVectorElementExpr, stmt_deleter<clang::ExtVectorElementExpr>::type>(m, "ExtVectorElementExpr" , py::base<clang::Expr>())
        .def("getBase", [](const clang::ExtVectorElementExpr& self) -> const clang::Expr * {
           return  self.getBase();
        })
        .def("getBase", []( clang::ExtVectorElementExpr& self) -> clang::Expr * {
           return  self.getBase();
        })
        .def("setBase", []( clang::ExtVectorElementExpr& self, clang::Expr * E)  {
             self.setBase(E);
        })
        //.def("getAccessor", [](const clang::ExtVectorElementExpr& self) -> clang::IdentifierInfo & {
        //   return  self.getAccessor();
        //})
        //.def("setAccessor", []( clang::ExtVectorElementExpr& self, clang::IdentifierInfo * II)  {
        //     self.setAccessor(II);
        //})
        .def("getAccessorLoc", [](const clang::ExtVectorElementExpr& self) -> clang::SourceLocation {
           return  self.getAccessorLoc();
        })
        .def("setAccessorLoc", []( clang::ExtVectorElementExpr& self, clang::SourceLocation L)  {
             self.setAccessorLoc(L);
        })
        .def("getNumElements", [](const clang::ExtVectorElementExpr& self) -> unsigned int {
           return  self.getNumElements();
        })
        .def("containsDuplicateElements", [](const clang::ExtVectorElementExpr& self) -> bool {
           return  self.containsDuplicateElements();
        })
        //.def("getEncodedElementAccess", [](const clang::ExtVectorElementExpr& self, llvm::SmallVectorImpl<unsigned int> & Elts)  {
        //     self.getEncodedElementAccess(Elts);
        //})
        .def("getLocStart", [](const clang::ExtVectorElementExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::ExtVectorElementExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("isArrow", [](const clang::ExtVectorElementExpr& self) -> bool {
           return  self.isArrow();
        })
        //.def("children", []( clang::ExtVectorElementExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::BlockExpr, stmt_deleter<clang::BlockExpr>::type>(m, "BlockExpr" , py::base<clang::Expr>())
        .def("getBlockDecl", [](const clang::BlockExpr& self) -> const clang::BlockDecl * {
           return  self.getBlockDecl();
        })
        .def("getBlockDecl", []( clang::BlockExpr& self) -> clang::BlockDecl * {
           return  self.getBlockDecl();
        })
        .def("setBlockDecl", []( clang::BlockExpr& self, clang::BlockDecl * BD)  {
             self.setBlockDecl(BD);
        })
        .def("getCaretLocation", [](const clang::BlockExpr& self) -> clang::SourceLocation {
           return  self.getCaretLocation();
        })
        .def("getBody", [](const clang::BlockExpr& self) -> const clang::Stmt * {
           return  self.getBody();
        })
        .def("getBody", []( clang::BlockExpr& self) -> clang::Stmt * {
           return  self.getBody();
        })
        .def("getLocStart", [](const clang::BlockExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::BlockExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("getFunctionType", [](const clang::BlockExpr& self) -> const clang::FunctionProtoType * {
        //   return  self.getFunctionType();
        //})
        //.def("children", []( clang::BlockExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::AsTypeExpr, stmt_deleter<clang::AsTypeExpr>::type>(m, "AsTypeExpr" , py::base<clang::Expr>())
        .def("getSrcExpr", [](const clang::AsTypeExpr& self) -> clang::Expr * {
           return  self.getSrcExpr();
        })
        .def("getBuiltinLoc", [](const clang::AsTypeExpr& self) -> clang::SourceLocation {
           return  self.getBuiltinLoc();
        })
        .def("getRParenLoc", [](const clang::AsTypeExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("getLocStart", [](const clang::AsTypeExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::AsTypeExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::AsTypeExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::PseudoObjectExpr, stmt_deleter<clang::PseudoObjectExpr>::type>(m, "PseudoObjectExpr" , py::base<clang::Expr>())
        .def("getSyntacticForm", []( clang::PseudoObjectExpr& self) -> clang::Expr * {
           return  self.getSyntacticForm();
        })
        .def("getSyntacticForm", [](const clang::PseudoObjectExpr& self) -> const clang::Expr * {
           return  self.getSyntacticForm();
        })
        .def("getResultExprIndex", [](const clang::PseudoObjectExpr& self) -> unsigned int {
           return  self.getResultExprIndex();
        })
        .def("getResultExpr", []( clang::PseudoObjectExpr& self) -> clang::Expr * {
           return  self.getResultExpr();
        })
        .def("getResultExpr", [](const clang::PseudoObjectExpr& self) -> const clang::Expr * {
           return  self.getResultExpr();
        })
        .def("getNumSemanticExprs", [](const clang::PseudoObjectExpr& self) -> unsigned int {
           return  self.getNumSemanticExprs();
        })
        //.def("semantics", []( clang::PseudoObjectExpr& self) -> llvm::iterator_range<clang::Expr *const *> {
        //   return  self.semantics();
        //})
        //.def("semantics", [](const clang::PseudoObjectExpr& self) -> llvm::iterator_range<const clang::Expr *const *> {
        //   return  self.semantics();
        //})
        .def("getSemanticExpr", []( clang::PseudoObjectExpr& self, unsigned int index) -> clang::Expr * {
           return  self.getSemanticExpr(index);
        })
        .def("getSemanticExpr", [](const clang::PseudoObjectExpr& self, unsigned int index) -> const clang::Expr * {
           return  self.getSemanticExpr(index);
        })
        .def("getExprLoc", [](const clang::PseudoObjectExpr& self) -> clang::SourceLocation {
           return  self.getExprLoc();
        })
        .def("getLocStart", [](const clang::PseudoObjectExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::PseudoObjectExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::PseudoObjectExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::AtomicExpr, stmt_deleter<clang::AtomicExpr>::type>(m, "AtomicExpr" , py::base<clang::Expr>())
        .def("getPtr", [](const clang::AtomicExpr& self) -> clang::Expr * {
           return  self.getPtr();
        })
        .def("getOrder", [](const clang::AtomicExpr& self) -> clang::Expr * {
           return  self.getOrder();
        })
        .def("getVal1", [](const clang::AtomicExpr& self) -> clang::Expr * {
           return  self.getVal1();
        })
        .def("getOrderFail", [](const clang::AtomicExpr& self) -> clang::Expr * {
           return  self.getOrderFail();
        })
        .def("getVal2", [](const clang::AtomicExpr& self) -> clang::Expr * {
           return  self.getVal2();
        })
        .def("getWeak", [](const clang::AtomicExpr& self) -> clang::Expr * {
           return  self.getWeak();
        })
        .def("getOp", [](const clang::AtomicExpr& self) -> clang::AtomicExpr::AtomicOp {
           return  self.getOp();
        })
        .def("getNumSubExprs", []( clang::AtomicExpr& self) -> unsigned int {
           return  self.getNumSubExprs();
        })
        .def("isVolatile", [](const clang::AtomicExpr& self) -> bool {
           return  self.isVolatile();
        })
        .def("isCmpXChg", [](const clang::AtomicExpr& self) -> bool {
           return  self.isCmpXChg();
        })
        .def("getBuiltinLoc", [](const clang::AtomicExpr& self) -> clang::SourceLocation {
           return  self.getBuiltinLoc();
        })
        .def("getRParenLoc", [](const clang::AtomicExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("getLocStart", [](const clang::AtomicExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::AtomicExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        //.def("children", []( clang::AtomicExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
    ;

    py::class_<clang::TypoExpr, stmt_deleter<clang::TypoExpr>::type>(m, "TypoExpr" , py::base<clang::Expr>())
        //.def("children", []( clang::TypoExpr& self) -> llvm::iterator_range<clang::StmtIterator> {
        //   return  self.children();
        //})
        .def("getLocStart", [](const clang::TypoExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::TypoExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
    ;

    py::class_<clang::AccessSpecDecl, decl_deleter<clang::AccessSpecDecl>::type>(m, "AccessSpecDecl" , py::base<clang::Decl>())
        .def("getAccessSpecifierLoc", [](const clang::AccessSpecDecl& self) -> clang::SourceLocation {
           return  self.getAccessSpecifierLoc();
        })
        .def("setAccessSpecifierLoc", []( clang::AccessSpecDecl& self, clang::SourceLocation ASLoc)  {
             self.setAccessSpecifierLoc(ASLoc);
        })
        .def("getColonLoc", [](const clang::AccessSpecDecl& self) -> clang::SourceLocation {
           return  self.getColonLoc();
        })
        .def("setColonLoc", []( clang::AccessSpecDecl& self, clang::SourceLocation CLoc)  {
             self.setColonLoc(CLoc);
        })
        .def("getSourceRange", [](const clang::AccessSpecDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
    ;

    py::class_<clang::CXXRecordDecl, decl_deleter<clang::CXXRecordDecl>::type>(m, "CXXRecordDecl" , py::base<clang::RecordDecl>())
        .def("getCanonicalDecl", []( clang::CXXRecordDecl& self) -> clang::CXXRecordDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::CXXRecordDecl& self) -> const clang::CXXRecordDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getPreviousDecl", []( clang::CXXRecordDecl& self) -> clang::CXXRecordDecl * {
           return  self.getPreviousDecl();
        })
        .def("getPreviousDecl", [](const clang::CXXRecordDecl& self) -> const clang::CXXRecordDecl * {
           return  self.getPreviousDecl();
        })
        .def("getMostRecentDecl", []( clang::CXXRecordDecl& self) -> clang::CXXRecordDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getMostRecentDecl", [](const clang::CXXRecordDecl& self) -> const clang::CXXRecordDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getDefinition", [](const clang::CXXRecordDecl& self) -> clang::CXXRecordDecl * {
           return  self.getDefinition();
        })
        .def("hasDefinition", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasDefinition();
        })
        .def("isDynamicClass", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isDynamicClass();
        })
        .def("setIsParsingBaseSpecifiers", []( clang::CXXRecordDecl& self)  {
             self.setIsParsingBaseSpecifiers();
        })
        .def("isParsingBaseSpecifiers", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isParsingBaseSpecifiers();
        })
        .def("getNumBases", [](const clang::CXXRecordDecl& self) -> unsigned int {
           return  self.getNumBases();
        })
        //.def("bases", []( clang::CXXRecordDecl& self) -> llvm::iterator_range<clang::CXXBaseSpecifier *> {
        //   return  self.bases();
        //})
        //.def("bases", [](const clang::CXXRecordDecl& self) -> llvm::iterator_range<const clang::CXXBaseSpecifier *> {
        //   return  self.bases();
        //})
        .def("getNumVBases", [](const clang::CXXRecordDecl& self) -> unsigned int {
           return  self.getNumVBases();
        })
        //.def("vbases", []( clang::CXXRecordDecl& self) -> llvm::iterator_range<clang::CXXBaseSpecifier *> {
        //   return  self.vbases();
        //})
        //.def("vbases", [](const clang::CXXRecordDecl& self) -> llvm::iterator_range<const clang::CXXBaseSpecifier *> {
        //   return  self.vbases();
        //})
        .def("hasAnyDependentBases", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasAnyDependentBases();
        })
        //.def("methods", [](const clang::CXXRecordDecl& self) -> llvm::iterator_range<clang::DeclContext::specific_decl_iterator<clang::CXXMethodDecl> > {
        //   return  self.methods();
        //})
        //.def("ctors", [](const clang::CXXRecordDecl& self) -> llvm::iterator_range<clang::DeclContext::specific_decl_iterator<clang::CXXConstructorDecl> > {
        //   return  self.ctors();
        //})
        //.def("friends", [](const clang::CXXRecordDecl& self) -> llvm::iterator_range<clang::CXXRecordDecl::friend_iterator> {
        //   return  self.friends();
        //})
        .def("pushFriendDecl", []( clang::CXXRecordDecl& self, clang::FriendDecl * FD)  {
             self.pushFriendDecl(FD);
        })
        .def("hasFriends", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasFriends();
        })
        .def("hasSimpleMoveConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasSimpleMoveConstructor();
        })
        .def("hasSimpleMoveAssignment", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasSimpleMoveAssignment();
        })
        .def("hasSimpleDestructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasSimpleDestructor();
        })
        .def("hasDefaultConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasDefaultConstructor();
        })
        .def("needsImplicitDefaultConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.needsImplicitDefaultConstructor();
        })
        .def("hasUserDeclaredConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasUserDeclaredConstructor();
        })
        .def("hasUserProvidedDefaultConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasUserProvidedDefaultConstructor();
        })
        .def("hasUserDeclaredCopyConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasUserDeclaredCopyConstructor();
        })
        .def("needsImplicitCopyConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.needsImplicitCopyConstructor();
        })
        .def("needsOverloadResolutionForCopyConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.needsOverloadResolutionForCopyConstructor();
        })
        .def("implicitCopyConstructorHasConstParam", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.implicitCopyConstructorHasConstParam();
        })
        .def("hasCopyConstructorWithConstParam", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasCopyConstructorWithConstParam();
        })
        .def("hasUserDeclaredMoveOperation", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasUserDeclaredMoveOperation();
        })
        .def("hasUserDeclaredMoveConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasUserDeclaredMoveConstructor();
        })
        .def("hasMoveConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasMoveConstructor();
        })
        .def("setImplicitMoveConstructorIsDeleted", []( clang::CXXRecordDecl& self)  {
             self.setImplicitMoveConstructorIsDeleted();
        })
        .def("needsImplicitMoveConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.needsImplicitMoveConstructor();
        })
        .def("needsOverloadResolutionForMoveConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.needsOverloadResolutionForMoveConstructor();
        })
        .def("hasUserDeclaredCopyAssignment", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasUserDeclaredCopyAssignment();
        })
        .def("needsImplicitCopyAssignment", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.needsImplicitCopyAssignment();
        })
        .def("needsOverloadResolutionForCopyAssignment", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.needsOverloadResolutionForCopyAssignment();
        })
        .def("implicitCopyAssignmentHasConstParam", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.implicitCopyAssignmentHasConstParam();
        })
        .def("hasCopyAssignmentWithConstParam", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasCopyAssignmentWithConstParam();
        })
        .def("hasUserDeclaredMoveAssignment", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasUserDeclaredMoveAssignment();
        })
        .def("hasMoveAssignment", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasMoveAssignment();
        })
        .def("setImplicitMoveAssignmentIsDeleted", []( clang::CXXRecordDecl& self)  {
             self.setImplicitMoveAssignmentIsDeleted();
        })
        .def("needsImplicitMoveAssignment", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.needsImplicitMoveAssignment();
        })
        .def("needsOverloadResolutionForMoveAssignment", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.needsOverloadResolutionForMoveAssignment();
        })
        .def("hasUserDeclaredDestructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasUserDeclaredDestructor();
        })
        .def("needsImplicitDestructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.needsImplicitDestructor();
        })
        .def("needsOverloadResolutionForDestructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.needsOverloadResolutionForDestructor();
        })
        .def("isLambda", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isLambda();
        })
        .def("isGenericLambda", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isGenericLambda();
        })
        .def("getLambdaCallOperator", [](const clang::CXXRecordDecl& self) -> clang::CXXMethodDecl * {
           return  self.getLambdaCallOperator();
        })
        .def("getLambdaStaticInvoker", [](const clang::CXXRecordDecl& self) -> clang::CXXMethodDecl * {
           return  self.getLambdaStaticInvoker();
        })
        //.def("getGenericLambdaTemplateParameterList", [](const clang::CXXRecordDecl& self) -> clang::TemplateParameterList * {
        //   return  self.getGenericLambdaTemplateParameterList();
        //})
        .def("getLambdaCaptureDefault", [](const clang::CXXRecordDecl& self) -> clang::LambdaCaptureDefault {
           return  self.getLambdaCaptureDefault();
        })
        //.def("captures", [](const clang::CXXRecordDecl& self) -> llvm::iterator_range<const clang::LambdaCapture *> {
        //   return  self.captures();
        //})
        .def("removeConversion", []( clang::CXXRecordDecl& self, const clang::NamedDecl * Old)  {
             self.removeConversion(Old);
        })
        //.def("getVisibleConversionFunctions", []( clang::CXXRecordDecl& self) -> llvm::iterator_range<clang::UnresolvedSetIterator> {
        //   return  self.getVisibleConversionFunctions();
        //})
        .def("isAggregate", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isAggregate();
        })
        .def("hasInClassInitializer", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasInClassInitializer();
        })
        .def("hasUninitializedReferenceMember", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasUninitializedReferenceMember();
        })
        .def("isPOD", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isPOD();
        })
        .def("isCLike", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isCLike();
        })
        .def("isEmpty", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isEmpty();
        })
        .def("isPolymorphic", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isPolymorphic();
        })
        .def("isAbstract", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isAbstract();
        })
        .def("isStandardLayout", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isStandardLayout();
        })
        .def("hasMutableFields", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasMutableFields();
        })
        .def("hasVariantMembers", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasVariantMembers();
        })
        .def("hasTrivialDefaultConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasTrivialDefaultConstructor();
        })
        .def("hasNonTrivialDefaultConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasNonTrivialDefaultConstructor();
        })
        .def("hasConstexprNonCopyMoveConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasConstexprNonCopyMoveConstructor();
        })
        .def("defaultedDefaultConstructorIsConstexpr", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.defaultedDefaultConstructorIsConstexpr();
        })
        .def("hasConstexprDefaultConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasConstexprDefaultConstructor();
        })
        .def("hasTrivialCopyConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasTrivialCopyConstructor();
        })
        .def("hasNonTrivialCopyConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasNonTrivialCopyConstructor();
        })
        .def("hasTrivialMoveConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasTrivialMoveConstructor();
        })
        .def("hasNonTrivialMoveConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasNonTrivialMoveConstructor();
        })
        .def("hasTrivialCopyAssignment", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasTrivialCopyAssignment();
        })
        .def("hasNonTrivialCopyAssignment", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasNonTrivialCopyAssignment();
        })
        .def("hasTrivialMoveAssignment", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasTrivialMoveAssignment();
        })
        .def("hasNonTrivialMoveAssignment", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasNonTrivialMoveAssignment();
        })
        .def("hasTrivialDestructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasTrivialDestructor();
        })
        .def("hasNonTrivialDestructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasNonTrivialDestructor();
        })
        .def("allowConstDefaultInit", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.allowConstDefaultInit();
        })
        .def("hasIrrelevantDestructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasIrrelevantDestructor();
        })
        .def("hasNonLiteralTypeFieldsOrBases", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasNonLiteralTypeFieldsOrBases();
        })
        .def("hasInheritedConstructor", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasInheritedConstructor();
        })
        .def("hasInheritedAssignment", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.hasInheritedAssignment();
        })
        .def("isTriviallyCopyable", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isTriviallyCopyable();
        })
        .def("isTrivial", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isTrivial();
        })
        .def("isLiteral", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isLiteral();
        })
        .def("getInstantiatedFromMemberClass", [](const clang::CXXRecordDecl& self) -> clang::CXXRecordDecl * {
           return  self.getInstantiatedFromMemberClass();
        })
        //.def("getMemberSpecializationInfo", [](const clang::CXXRecordDecl& self) -> clang::MemberSpecializationInfo * {
        //   return  self.getMemberSpecializationInfo();
        //})
        .def("setInstantiationOfMemberClass", []( clang::CXXRecordDecl& self, clang::CXXRecordDecl * RD , clang::TemplateSpecializationKind TSK)  {
             self.setInstantiationOfMemberClass(RD, TSK);
        })
        .def("getDescribedClassTemplate", [](const clang::CXXRecordDecl& self) -> clang::ClassTemplateDecl * {
           return  self.getDescribedClassTemplate();
        })
        .def("setDescribedClassTemplate", []( clang::CXXRecordDecl& self, clang::ClassTemplateDecl * Template)  {
             self.setDescribedClassTemplate(Template);
        })
        .def("getTemplateSpecializationKind", [](const clang::CXXRecordDecl& self) -> clang::TemplateSpecializationKind {
           return  self.getTemplateSpecializationKind();
        })
        .def("setTemplateSpecializationKind", []( clang::CXXRecordDecl& self, clang::TemplateSpecializationKind TSK)  {
             self.setTemplateSpecializationKind(TSK);
        })
        .def("getTemplateInstantiationPattern", [](const clang::CXXRecordDecl& self) -> const clang::CXXRecordDecl * {
           return  self.getTemplateInstantiationPattern();
        })
        .def("getTemplateInstantiationPattern", []( clang::CXXRecordDecl& self) -> clang::CXXRecordDecl * {
           return  self.getTemplateInstantiationPattern();
        })
        .def("getDestructor", [](const clang::CXXRecordDecl& self) -> clang::CXXDestructorDecl * {
           return  self.getDestructor();
        })
        .def("isAnyDestructorNoReturn", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isAnyDestructorNoReturn();
        })
        .def("isLocalClass", [](const clang::CXXRecordDecl& self) -> const clang::FunctionDecl * {
           return  self.isLocalClass();
        })
        .def("isLocalClass", []( clang::CXXRecordDecl& self) -> clang::FunctionDecl * {
           return  self.isLocalClass();
        })
        .def("isCurrentInstantiation", [](const clang::CXXRecordDecl& self, const clang::DeclContext * CurContext) -> bool {
           return  self.isCurrentInstantiation(CurContext);
        })
        .def("isDerivedFrom", [](const clang::CXXRecordDecl& self, const clang::CXXRecordDecl * Base) -> bool {
           return  self.isDerivedFrom(Base);
        })
        //.def("isDerivedFrom", [](const clang::CXXRecordDecl& self, const clang::CXXRecordDecl * Base , clang::CXXBasePaths & Paths) -> bool {
        //   return  self.isDerivedFrom(Base, Paths);
        //})
        .def("isVirtuallyDerivedFrom", [](const clang::CXXRecordDecl& self, const clang::CXXRecordDecl * Base) -> bool {
           return  self.isVirtuallyDerivedFrom(Base);
        })
        .def("isProvablyNotDerivedFrom", [](const clang::CXXRecordDecl& self, const clang::CXXRecordDecl * Base) -> bool {
           return  self.isProvablyNotDerivedFrom(Base);
        })
        //.def("forallBases", [](const clang::CXXRecordDecl& self, llvm::function_ref<bool (const clang::CXXRecordDecl *)> BaseMatches , bool AllowShortCircuit) -> bool {
        //   return  self.forallBases(BaseMatches, AllowShortCircuit);
        //})
        //.def("lookupInBases", [](const clang::CXXRecordDecl& self, llvm::function_ref<bool (const clang::CXXBaseSpecifier *, clang::CXXBasePath &)> BaseMatches , clang::CXXBasePaths & Paths) -> bool {
        //   return  self.lookupInBases(BaseMatches, Paths);
        //})
        //.def("getFinalOverriders", [](const clang::CXXRecordDecl& self, clang::CXXFinalOverriderMap & FinaOverriders)  {
        //     self.getFinalOverriders(FinaOverriders);
        //})
        //.def("getIndirectPrimaryBases", [](const clang::CXXRecordDecl& self, clang::CXXIndirectPrimaryBaseSet & Bases)  {
        //     self.getIndirectPrimaryBases(Bases);
        //})
        .def("viewInheritance", [](const clang::CXXRecordDecl& self, clang::ASTContext & Context)  {
             self.viewInheritance(Context);
        })
        .def("finishedDefaultedOrDeletedMember", []( clang::CXXRecordDecl& self, clang::CXXMethodDecl * MD)  {
             self.finishedDefaultedOrDeletedMember(MD);
        })
        .def("completeDefinition", []( clang::CXXRecordDecl& self)  {
             self.completeDefinition();
        })
        //.def("completeDefinition", []( clang::CXXRecordDecl& self, clang::CXXFinalOverriderMap * FinalOverriders)  {
        //     self.completeDefinition(FinalOverriders);
        //})
        .def("mayBeAbstract", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.mayBeAbstract();
        })
        .def("getLambdaManglingNumber", [](const clang::CXXRecordDecl& self) -> unsigned int {
           return  self.getLambdaManglingNumber();
        })
        .def("getLambdaContextDecl", [](const clang::CXXRecordDecl& self) -> clang::Decl * {
           return  self.getLambdaContextDecl();
        })
        .def("setLambdaMangling", []( clang::CXXRecordDecl& self, unsigned int ManglingNumber , clang::Decl * ContextDecl)  {
             self.setLambdaMangling(ManglingNumber, ContextDecl);
        })
        //.def("getMSInheritanceModel", [](const clang::CXXRecordDecl& self) -> clang::MSInheritanceAttr::Spelling {
        //   return  self.getMSInheritanceModel();
        //})
        //.def("calculateInheritanceModel", [](const clang::CXXRecordDecl& self) -> clang::MSInheritanceAttr::Spelling {
        //   return  self.calculateInheritanceModel();
        //})
        .def("nullFieldOffsetIsZero", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.nullFieldOffsetIsZero();
        })
        //.def("getMSVtorDispMode", [](const clang::CXXRecordDecl& self) -> clang::MSVtorDispAttr::Mode {
        //   return  self.getMSVtorDispMode();
        //})
        .def("isDependentLambda", [](const clang::CXXRecordDecl& self) -> bool {
           return  self.isDependentLambda();
        })
        .def("getLambdaTypeInfo", [](const clang::CXXRecordDecl& self) -> clang::TypeSourceInfo * {
           return  self.getLambdaTypeInfo();
        })
    ;

    py::class_<clang::CXXMethodDecl, decl_deleter<clang::CXXMethodDecl>::type>(m, "CXXMethodDecl" , py::base<clang::FunctionDecl>())
        .def("isStatic", [](const clang::CXXMethodDecl& self) -> bool {
           return  self.isStatic();
        })
        .def("isInstance", [](const clang::CXXMethodDecl& self) -> bool {
           return  self.isInstance();
        })
        .def("isConst", [](const clang::CXXMethodDecl& self) -> bool {
           return  self.isConst();
        })
        .def("isVolatile", [](const clang::CXXMethodDecl& self) -> bool {
           return  self.isVolatile();
        })
        .def("isVirtual", [](const clang::CXXMethodDecl& self) -> bool {
           return  self.isVirtual();
        })
        .def("isUsualDeallocationFunction", [](const clang::CXXMethodDecl& self) -> bool {
           return  self.isUsualDeallocationFunction();
        })
        .def("isCopyAssignmentOperator", [](const clang::CXXMethodDecl& self) -> bool {
           return  self.isCopyAssignmentOperator();
        })
        .def("isMoveAssignmentOperator", [](const clang::CXXMethodDecl& self) -> bool {
           return  self.isMoveAssignmentOperator();
        })
        .def("getCanonicalDecl", []( clang::CXXMethodDecl& self) -> clang::CXXMethodDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::CXXMethodDecl& self) -> const clang::CXXMethodDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getMostRecentDecl", []( clang::CXXMethodDecl& self) -> clang::CXXMethodDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getMostRecentDecl", [](const clang::CXXMethodDecl& self) -> const clang::CXXMethodDecl * {
           return  self.getMostRecentDecl();
        })
        .def("isUserProvided", [](const clang::CXXMethodDecl& self) -> bool {
           return  self.isUserProvided();
        })
        .def("addOverriddenMethod", []( clang::CXXMethodDecl& self, const clang::CXXMethodDecl * MD)  {
             self.addOverriddenMethod(MD);
        })
        .def("size_overridden_methods", [](const clang::CXXMethodDecl& self) -> unsigned int {
           return  self.size_overridden_methods();
        })
        //.def("overridden_methods", [](const clang::CXXMethodDecl& self) -> llvm::iterator_range<const clang::CXXMethodDecl *const *> {
        //   return  self.overridden_methods();
        //})
        .def("getParent", [](const clang::CXXMethodDecl& self) -> const clang::CXXRecordDecl * {
           return  self.getParent();
        })
        .def("getParent", []( clang::CXXMethodDecl& self) -> clang::CXXRecordDecl * {
           return  self.getParent();
        })
        .def("getThisType", [](const clang::CXXMethodDecl& self, clang::ASTContext & C) -> clang::QualType {
           return  self.getThisType(C);
        })
        .def("getTypeQualifiers", [](const clang::CXXMethodDecl& self) -> unsigned int {
           return  self.getTypeQualifiers();
        })
        .def("getRefQualifier", [](const clang::CXXMethodDecl& self) -> clang::RefQualifierKind {
           return  self.getRefQualifier();
        })
        .def("hasInlineBody", [](const clang::CXXMethodDecl& self) -> bool {
           return  self.hasInlineBody();
        })
        .def("isLambdaStaticInvoker", [](const clang::CXXMethodDecl& self) -> bool {
           return  self.isLambdaStaticInvoker();
        })
        .def("getCorrespondingMethodInClass", []( clang::CXXMethodDecl& self, const clang::CXXRecordDecl * RD , bool MayBeBase) -> clang::CXXMethodDecl * {
           return  self.getCorrespondingMethodInClass(RD, MayBeBase);
        })
        .def("getCorrespondingMethodInClass", [](const clang::CXXMethodDecl& self, const clang::CXXRecordDecl * RD , bool MayBeBase) -> const clang::CXXMethodDecl * {
           return  self.getCorrespondingMethodInClass(RD, MayBeBase);
        })
    ;

    py::class_<clang::CXXConstructorDecl, decl_deleter<clang::CXXConstructorDecl>::type>(m, "CXXConstructorDecl" , py::base<clang::CXXMethodDecl>())
        .def("isExplicitSpecified", [](const clang::CXXConstructorDecl& self) -> bool {
           return  self.isExplicitSpecified();
        })
        .def("isExplicit", [](const clang::CXXConstructorDecl& self) -> bool {
           return  self.isExplicit();
        })
        //.def("inits", []( clang::CXXConstructorDecl& self) -> llvm::iterator_range<clang::CXXCtorInitializer **> {
        //   return  self.inits();
        //})
        //.def("inits", [](const clang::CXXConstructorDecl& self) -> llvm::iterator_range<clang::CXXCtorInitializer *const *> {
        //   return  self.inits();
        //})
        .def("getNumCtorInitializers", [](const clang::CXXConstructorDecl& self) -> unsigned int {
           return  self.getNumCtorInitializers();
        })
        .def("setNumCtorInitializers", []( clang::CXXConstructorDecl& self, unsigned int numCtorInitializers)  {
             self.setNumCtorInitializers(numCtorInitializers);
        })
        .def("isDelegatingConstructor", [](const clang::CXXConstructorDecl& self) -> bool {
           return  self.isDelegatingConstructor();
        })
        .def("getTargetConstructor", [](const clang::CXXConstructorDecl& self) -> clang::CXXConstructorDecl * {
           return  self.getTargetConstructor();
        })
        .def("isDefaultConstructor", [](const clang::CXXConstructorDecl& self) -> bool {
           return  self.isDefaultConstructor();
        })
        .def("isCopyConstructor", [](const clang::CXXConstructorDecl& self, unsigned int & TypeQuals) -> bool {
           return  self.isCopyConstructor(TypeQuals);
        })
        .def("isCopyConstructor", [](const clang::CXXConstructorDecl& self) -> bool {
           return  self.isCopyConstructor();
        })
        .def("isMoveConstructor", [](const clang::CXXConstructorDecl& self, unsigned int & TypeQuals) -> bool {
           return  self.isMoveConstructor(TypeQuals);
        })
        .def("isMoveConstructor", [](const clang::CXXConstructorDecl& self) -> bool {
           return  self.isMoveConstructor();
        })
        .def("isCopyOrMoveConstructor", [](const clang::CXXConstructorDecl& self, unsigned int & TypeQuals) -> bool {
           return  self.isCopyOrMoveConstructor(TypeQuals);
        })
        .def("isCopyOrMoveConstructor", [](const clang::CXXConstructorDecl& self) -> bool {
           return  self.isCopyOrMoveConstructor();
        })
        .def("isConvertingConstructor", [](const clang::CXXConstructorDecl& self, bool AllowExplicit) -> bool {
           return  self.isConvertingConstructor(AllowExplicit);
        })
        .def("isSpecializationCopyingObject", [](const clang::CXXConstructorDecl& self) -> bool {
           return  self.isSpecializationCopyingObject();
        })
        .def("isInheritingConstructor", [](const clang::CXXConstructorDecl& self) -> bool {
           return  self.isInheritingConstructor();
        })
        //.def("getInheritedConstructor", [](const clang::CXXConstructorDecl& self) -> clang::InheritedConstructor {
        //   return  self.getInheritedConstructor();
        //})
        .def("getCanonicalDecl", []( clang::CXXConstructorDecl& self) -> clang::CXXConstructorDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::CXXConstructorDecl& self) -> const clang::CXXConstructorDecl * {
           return  self.getCanonicalDecl();
        })
    ;

    py::class_<clang::CXXDestructorDecl, decl_deleter<clang::CXXDestructorDecl>::type>(m, "CXXDestructorDecl" , py::base<clang::CXXMethodDecl>())
        .def("setOperatorDelete", []( clang::CXXDestructorDecl& self, clang::FunctionDecl * OD)  {
             self.setOperatorDelete(OD);
        })
        .def("getOperatorDelete", [](const clang::CXXDestructorDecl& self) -> const clang::FunctionDecl * {
           return  self.getOperatorDelete();
        })
    ;

    py::class_<clang::CXXConversionDecl, decl_deleter<clang::CXXConversionDecl>::type>(m, "CXXConversionDecl" , py::base<clang::CXXMethodDecl>())
        .def("isExplicitSpecified", [](const clang::CXXConversionDecl& self) -> bool {
           return  self.isExplicitSpecified();
        })
        .def("isExplicit", [](const clang::CXXConversionDecl& self) -> bool {
           return  self.isExplicit();
        })
        .def("getConversionType", [](const clang::CXXConversionDecl& self) -> clang::QualType {
           return  self.getConversionType();
        })
        .def("isLambdaToBlockPointerConversion", [](const clang::CXXConversionDecl& self) -> bool {
           return  self.isLambdaToBlockPointerConversion();
        })
    ;

    py::class_<clang::LinkageSpecDecl, decl_deleter<clang::LinkageSpecDecl>::type>(m, "LinkageSpecDecl" , py::base<clang::Decl>())
        .def("getLanguage", [](const clang::LinkageSpecDecl& self) -> clang::LinkageSpecDecl::LanguageIDs {
           return  self.getLanguage();
        })
        .def("setLanguage", []( clang::LinkageSpecDecl& self, clang::LinkageSpecDecl::LanguageIDs L)  {
             self.setLanguage(L);
        })
        .def("hasBraces", [](const clang::LinkageSpecDecl& self) -> bool {
           return  self.hasBraces();
        })
        .def("getExternLoc", [](const clang::LinkageSpecDecl& self) -> clang::SourceLocation {
           return  self.getExternLoc();
        })
        .def("getRBraceLoc", [](const clang::LinkageSpecDecl& self) -> clang::SourceLocation {
           return  self.getRBraceLoc();
        })
        .def("setExternLoc", []( clang::LinkageSpecDecl& self, clang::SourceLocation L)  {
             self.setExternLoc(L);
        })
        .def("setRBraceLoc", []( clang::LinkageSpecDecl& self, clang::SourceLocation L)  {
             self.setRBraceLoc(L);
        })
        .def("getLocEnd", [](const clang::LinkageSpecDecl& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getSourceRange", [](const clang::LinkageSpecDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
    ;

    py::class_<clang::UsingDirectiveDecl, decl_deleter<clang::UsingDirectiveDecl>::type>(m, "UsingDirectiveDecl" , py::base<clang::NamedDecl>())
        //.def("getQualifierLoc", [](const clang::UsingDirectiveDecl& self) -> clang::NestedNameSpecifierLoc {
        //   return  self.getQualifierLoc();
        //})
        //.def("getQualifier", [](const clang::UsingDirectiveDecl& self) -> clang::NestedNameSpecifier * {
        //   return  self.getQualifier();
        //})
        .def("getNominatedNamespaceAsWritten", []( clang::UsingDirectiveDecl& self) -> clang::NamedDecl * {
           return  self.getNominatedNamespaceAsWritten();
        })
        .def("getNominatedNamespaceAsWritten", [](const clang::UsingDirectiveDecl& self) -> const clang::NamedDecl * {
           return  self.getNominatedNamespaceAsWritten();
        })
        .def("getNominatedNamespace", []( clang::UsingDirectiveDecl& self) -> clang::NamespaceDecl * {
           return  self.getNominatedNamespace();
        })
        .def("getNominatedNamespace", [](const clang::UsingDirectiveDecl& self) -> const clang::NamespaceDecl * {
           return  self.getNominatedNamespace();
        })
        .def("getCommonAncestor", []( clang::UsingDirectiveDecl& self) -> clang::DeclContext * {
           return  self.getCommonAncestor();
        })
        .def("getCommonAncestor", [](const clang::UsingDirectiveDecl& self) -> const clang::DeclContext * {
           return  self.getCommonAncestor();
        })
        .def("getUsingLoc", [](const clang::UsingDirectiveDecl& self) -> clang::SourceLocation {
           return  self.getUsingLoc();
        })
        .def("getNamespaceKeyLocation", [](const clang::UsingDirectiveDecl& self) -> clang::SourceLocation {
           return  self.getNamespaceKeyLocation();
        })
        .def("getIdentLocation", [](const clang::UsingDirectiveDecl& self) -> clang::SourceLocation {
           return  self.getIdentLocation();
        })
        .def("getSourceRange", [](const clang::UsingDirectiveDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
    ;

    py::class_<clang::NamespaceAliasDecl, decl_deleter<clang::NamespaceAliasDecl>::type>(m, "NamespaceAliasDecl" , py::base<clang::NamedDecl>())
        .def("getCanonicalDecl", []( clang::NamespaceAliasDecl& self) -> clang::NamespaceAliasDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::NamespaceAliasDecl& self) -> const clang::NamespaceAliasDecl * {
           return  self.getCanonicalDecl();
        })
        //.def("getQualifierLoc", [](const clang::NamespaceAliasDecl& self) -> clang::NestedNameSpecifierLoc {
        //   return  self.getQualifierLoc();
        //})
        //.def("getQualifier", [](const clang::NamespaceAliasDecl& self) -> clang::NestedNameSpecifier * {
        //   return  self.getQualifier();
        //})
        .def("getNamespace", []( clang::NamespaceAliasDecl& self) -> clang::NamespaceDecl * {
           return  self.getNamespace();
        })
        .def("getNamespace", [](const clang::NamespaceAliasDecl& self) -> const clang::NamespaceDecl * {
           return  self.getNamespace();
        })
        .def("getAliasLoc", [](const clang::NamespaceAliasDecl& self) -> clang::SourceLocation {
           return  self.getAliasLoc();
        })
        .def("getNamespaceLoc", [](const clang::NamespaceAliasDecl& self) -> clang::SourceLocation {
           return  self.getNamespaceLoc();
        })
        .def("getTargetNameLoc", [](const clang::NamespaceAliasDecl& self) -> clang::SourceLocation {
           return  self.getTargetNameLoc();
        })
        .def("getAliasedNamespace", [](const clang::NamespaceAliasDecl& self) -> clang::NamedDecl * {
           return  self.getAliasedNamespace();
        })
        .def("getSourceRange", [](const clang::NamespaceAliasDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
    ;

    py::class_<clang::UsingShadowDecl, decl_deleter<clang::UsingShadowDecl>::type>(m, "UsingShadowDecl" , py::base<clang::NamedDecl>())
        .def("getCanonicalDecl", []( clang::UsingShadowDecl& self) -> clang::UsingShadowDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::UsingShadowDecl& self) -> const clang::UsingShadowDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getTargetDecl", [](const clang::UsingShadowDecl& self) -> clang::NamedDecl * {
           return  self.getTargetDecl();
        })
        .def("setTargetDecl", []( clang::UsingShadowDecl& self, clang::NamedDecl * ND)  {
             self.setTargetDecl(ND);
        })
        .def("getUsingDecl", [](const clang::UsingShadowDecl& self) -> clang::UsingDecl * {
           return  self.getUsingDecl();
        })
        .def("getNextUsingShadowDecl", [](const clang::UsingShadowDecl& self) -> clang::UsingShadowDecl * {
           return  self.getNextUsingShadowDecl();
        })
    ;

    py::class_<clang::ConstructorUsingShadowDecl, decl_deleter<clang::ConstructorUsingShadowDecl>::type>(m, "ConstructorUsingShadowDecl" , py::base<clang::UsingShadowDecl>())
        .def("getParent", [](const clang::ConstructorUsingShadowDecl& self) -> const clang::CXXRecordDecl * {
           return  self.getParent();
        })
        .def("getParent", []( clang::ConstructorUsingShadowDecl& self) -> clang::CXXRecordDecl * {
           return  self.getParent();
        })
        .def("getNominatedBaseClassShadowDecl", [](const clang::ConstructorUsingShadowDecl& self) -> clang::ConstructorUsingShadowDecl * {
           return  self.getNominatedBaseClassShadowDecl();
        })
        .def("getConstructedBaseClassShadowDecl", [](const clang::ConstructorUsingShadowDecl& self) -> clang::ConstructorUsingShadowDecl * {
           return  self.getConstructedBaseClassShadowDecl();
        })
        .def("getNominatedBaseClass", [](const clang::ConstructorUsingShadowDecl& self) -> clang::CXXRecordDecl * {
           return  self.getNominatedBaseClass();
        })
        .def("getConstructedBaseClass", [](const clang::ConstructorUsingShadowDecl& self) -> clang::CXXRecordDecl * {
           return  self.getConstructedBaseClass();
        })
        .def("constructsVirtualBase", [](const clang::ConstructorUsingShadowDecl& self) -> bool {
           return  self.constructsVirtualBase();
        })
        .def("getConstructor", [](const clang::ConstructorUsingShadowDecl& self) -> clang::CXXConstructorDecl * {
           return  self.getConstructor();
        })
        .def("setConstructor", []( clang::ConstructorUsingShadowDecl& self, clang::NamedDecl * Ctor)  {
             self.setConstructor(Ctor);
        })
    ;

    py::class_<clang::UsingDecl, decl_deleter<clang::UsingDecl>::type>(m, "UsingDecl" , py::base<clang::NamedDecl>())
        .def("getUsingLoc", [](const clang::UsingDecl& self) -> clang::SourceLocation {
           return  self.getUsingLoc();
        })
        .def("setUsingLoc", []( clang::UsingDecl& self, clang::SourceLocation L)  {
             self.setUsingLoc(L);
        })
        //.def("getQualifierLoc", [](const clang::UsingDecl& self) -> clang::NestedNameSpecifierLoc {
        //   return  self.getQualifierLoc();
        //})
        //.def("getQualifier", [](const clang::UsingDecl& self) -> clang::NestedNameSpecifier * {
        //   return  self.getQualifier();
        //})
        .def("getNameInfo", [](const clang::UsingDecl& self) -> clang::DeclarationNameInfo {
           return  self.getNameInfo();
        })
        .def("isAccessDeclaration", [](const clang::UsingDecl& self) -> bool {
           return  self.isAccessDeclaration();
        })
        .def("hasTypename", [](const clang::UsingDecl& self) -> bool {
           return  self.hasTypename();
        })
        .def("setTypename", []( clang::UsingDecl& self, bool TN)  {
             self.setTypename(TN);
        })
        //.def("shadows", [](const clang::UsingDecl& self) -> llvm::iterator_range<clang::UsingDecl::shadow_iterator> {
        //   return  self.shadows();
        //})
        .def("shadow_size", [](const clang::UsingDecl& self) -> unsigned int {
           return  self.shadow_size();
        })
        .def("addShadowDecl", []( clang::UsingDecl& self, clang::UsingShadowDecl * S)  {
             self.addShadowDecl(S);
        })
        .def("removeShadowDecl", []( clang::UsingDecl& self, clang::UsingShadowDecl * S)  {
             self.removeShadowDecl(S);
        })
        .def("getSourceRange", [](const clang::UsingDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getCanonicalDecl", []( clang::UsingDecl& self) -> clang::UsingDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::UsingDecl& self) -> const clang::UsingDecl * {
           return  self.getCanonicalDecl();
        })
    ;

    py::class_<clang::UnresolvedUsingValueDecl, decl_deleter<clang::UnresolvedUsingValueDecl>::type>(m, "UnresolvedUsingValueDecl" , py::base<clang::ValueDecl>())
        .def("getUsingLoc", [](const clang::UnresolvedUsingValueDecl& self) -> clang::SourceLocation {
           return  self.getUsingLoc();
        })
        .def("setUsingLoc", []( clang::UnresolvedUsingValueDecl& self, clang::SourceLocation L)  {
             self.setUsingLoc(L);
        })
        .def("isAccessDeclaration", [](const clang::UnresolvedUsingValueDecl& self) -> bool {
           return  self.isAccessDeclaration();
        })
        //.def("getQualifierLoc", [](const clang::UnresolvedUsingValueDecl& self) -> clang::NestedNameSpecifierLoc {
        //   return  self.getQualifierLoc();
        //})
        //.def("getQualifier", [](const clang::UnresolvedUsingValueDecl& self) -> clang::NestedNameSpecifier * {
        //   return  self.getQualifier();
        //})
        .def("getNameInfo", [](const clang::UnresolvedUsingValueDecl& self) -> clang::DeclarationNameInfo {
           return  self.getNameInfo();
        })
        .def("getSourceRange", [](const clang::UnresolvedUsingValueDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getCanonicalDecl", []( clang::UnresolvedUsingValueDecl& self) -> clang::UnresolvedUsingValueDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::UnresolvedUsingValueDecl& self) -> const clang::UnresolvedUsingValueDecl * {
           return  self.getCanonicalDecl();
        })
    ;

    py::class_<clang::UnresolvedUsingTypenameDecl, decl_deleter<clang::UnresolvedUsingTypenameDecl>::type>(m, "UnresolvedUsingTypenameDecl" , py::base<clang::TypeDecl>())
        .def("getUsingLoc", [](const clang::UnresolvedUsingTypenameDecl& self) -> clang::SourceLocation {
           return  self.getUsingLoc();
        })
        .def("getTypenameLoc", [](const clang::UnresolvedUsingTypenameDecl& self) -> clang::SourceLocation {
           return  self.getTypenameLoc();
        })
        //.def("getQualifierLoc", [](const clang::UnresolvedUsingTypenameDecl& self) -> clang::NestedNameSpecifierLoc {
        //   return  self.getQualifierLoc();
        //})
        //.def("getQualifier", [](const clang::UnresolvedUsingTypenameDecl& self) -> clang::NestedNameSpecifier * {
        //   return  self.getQualifier();
        //})
        .def("getCanonicalDecl", []( clang::UnresolvedUsingTypenameDecl& self) -> clang::UnresolvedUsingTypenameDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::UnresolvedUsingTypenameDecl& self) -> const clang::UnresolvedUsingTypenameDecl * {
           return  self.getCanonicalDecl();
        })
    ;

    py::class_<clang::StaticAssertDecl, decl_deleter<clang::StaticAssertDecl>::type>(m, "StaticAssertDecl" , py::base<clang::Decl>())
        .def("getAssertExpr", []( clang::StaticAssertDecl& self) -> clang::Expr * {
           return  self.getAssertExpr();
        })
        .def("getAssertExpr", [](const clang::StaticAssertDecl& self) -> const clang::Expr * {
           return  self.getAssertExpr();
        })
        .def("getMessage", []( clang::StaticAssertDecl& self) -> clang::StringLiteral * {
           return  self.getMessage();
        })
        .def("getMessage", [](const clang::StaticAssertDecl& self) -> const clang::StringLiteral * {
           return  self.getMessage();
        })
        .def("isFailed", [](const clang::StaticAssertDecl& self) -> bool {
           return  self.isFailed();
        })
        .def("getRParenLoc", [](const clang::StaticAssertDecl& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("getSourceRange", [](const clang::StaticAssertDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
    ;

    py::class_<clang::MSPropertyDecl, decl_deleter<clang::MSPropertyDecl>::type>(m, "MSPropertyDecl" , py::base<clang::DeclaratorDecl>())
        .def("hasGetter", [](const clang::MSPropertyDecl& self) -> bool {
           return  self.hasGetter();
        })
        //.def("getGetterId", [](const clang::MSPropertyDecl& self) -> clang::IdentifierInfo * {
        //   return  self.getGetterId();
        //})
        .def("hasSetter", [](const clang::MSPropertyDecl& self) -> bool {
           return  self.hasSetter();
        })
        //.def("getSetterId", [](const clang::MSPropertyDecl& self) -> clang::IdentifierInfo * {
        //   return  self.getSetterId();
        //})
    ;

    py::class_<clang::TemplateDecl, decl_deleter<clang::TemplateDecl>::type>(m, "TemplateDecl" , py::base<clang::NamedDecl>())
        //.def("getTemplateParameters", [](const clang::TemplateDecl& self) -> clang::TemplateParameterList * {
        //   return  self.getTemplateParameters();
        //})
        .def("getTemplatedDecl", [](const clang::TemplateDecl& self) -> clang::NamedDecl * {
           return  self.getTemplatedDecl();
        })
        .def("getSourceRange", [](const clang::TemplateDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("isConcept", [](const clang::TemplateDecl& self) -> bool {
           return  self.isConcept();
        })
        .def("setConcept", []( clang::TemplateDecl& self)  {
             self.setConcept();
        })
        //.def("init", []( clang::TemplateDecl& self, clang::NamedDecl * templatedDecl , clang::TemplateParameterList * templateParams)  {
        //     self.init(templatedDecl, templateParams);
        //})
    ;

    py::class_<clang::RedeclarableTemplateDecl, decl_deleter<clang::RedeclarableTemplateDecl>::type>(m, "RedeclarableTemplateDecl" , py::base<clang::TemplateDecl>())
        .def("getCanonicalDecl", []( clang::RedeclarableTemplateDecl& self) -> clang::RedeclarableTemplateDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::RedeclarableTemplateDecl& self) -> const clang::RedeclarableTemplateDecl * {
           return  self.getCanonicalDecl();
        })
        .def("isMemberSpecialization", [](const clang::RedeclarableTemplateDecl& self) -> bool {
           return  self.isMemberSpecialization();
        })
        .def("setMemberSpecialization", []( clang::RedeclarableTemplateDecl& self)  {
             self.setMemberSpecialization();
        })
        .def("getInstantiatedFromMemberTemplate", [](const clang::RedeclarableTemplateDecl& self) -> clang::RedeclarableTemplateDecl * {
           return  self.getInstantiatedFromMemberTemplate();
        })
        .def("setInstantiatedFromMemberTemplate", []( clang::RedeclarableTemplateDecl& self, clang::RedeclarableTemplateDecl * TD)  {
             self.setInstantiatedFromMemberTemplate(TD);
        })
    ;

    py::class_<clang::FunctionTemplateDecl, decl_deleter<clang::FunctionTemplateDecl>::type>(m, "FunctionTemplateDecl" , py::base<clang::RedeclarableTemplateDecl>())
        .def("LoadLazySpecializations", [](const clang::FunctionTemplateDecl& self)  {
             self.LoadLazySpecializations();
        })
        .def("getTemplatedDecl", [](const clang::FunctionTemplateDecl& self) -> clang::FunctionDecl * {
           return  self.getTemplatedDecl();
        })
        .def("isThisDeclarationADefinition", [](const clang::FunctionTemplateDecl& self) -> bool {
           return  self.isThisDeclarationADefinition();
        })
        .def("getCanonicalDecl", []( clang::FunctionTemplateDecl& self) -> clang::FunctionTemplateDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::FunctionTemplateDecl& self) -> const clang::FunctionTemplateDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getPreviousDecl", []( clang::FunctionTemplateDecl& self) -> clang::FunctionTemplateDecl * {
           return  self.getPreviousDecl();
        })
        .def("getPreviousDecl", [](const clang::FunctionTemplateDecl& self) -> const clang::FunctionTemplateDecl * {
           return  self.getPreviousDecl();
        })
        .def("getMostRecentDecl", []( clang::FunctionTemplateDecl& self) -> clang::FunctionTemplateDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getMostRecentDecl", [](const clang::FunctionTemplateDecl& self) -> const clang::FunctionTemplateDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getInstantiatedFromMemberTemplate", [](const clang::FunctionTemplateDecl& self) -> clang::FunctionTemplateDecl * {
           return  self.getInstantiatedFromMemberTemplate();
        })
        //.def("specializations", [](const clang::FunctionTemplateDecl& self) -> llvm::iterator_range<clang::RedeclarableTemplateDecl::SpecIterator<clang::FunctionTemplateSpecializationInfo, clang::RedeclarableTemplateDecl::SpecEntryTraits<clang::FunctionTemplateSpecializationInfo>, clang::FunctionDecl> > {
        //   return  self.specializations();
        //})
        //.def("getInjectedTemplateArgs", []( clang::FunctionTemplateDecl& self) -> llvm::ArrayRef<clang::TemplateArgument> {
        //   return  self.getInjectedTemplateArgs();
        //})
    ;

    py::class_<clang::TemplateTypeParmDecl, decl_deleter<clang::TemplateTypeParmDecl>::type>(m, "TemplateTypeParmDecl" , py::base<clang::TypeDecl>())
        .def("wasDeclaredWithTypename", [](const clang::TemplateTypeParmDecl& self) -> bool {
           return  self.wasDeclaredWithTypename();
        })
        //.def("getDefaultArgStorage", [](const clang::TemplateTypeParmDecl& self) -> const clang::DefaultArgStorage<clang::TemplateTypeParmDecl, clang::TypeSourceInfo *> & {
        //   return  self.getDefaultArgStorage();
        //})
        .def("hasDefaultArgument", [](const clang::TemplateTypeParmDecl& self) -> bool {
           return  self.hasDefaultArgument();
        })
        .def("getDefaultArgument", [](const clang::TemplateTypeParmDecl& self) -> clang::QualType {
           return  self.getDefaultArgument();
        })
        .def("getDefaultArgumentInfo", [](const clang::TemplateTypeParmDecl& self) -> clang::TypeSourceInfo * {
           return  self.getDefaultArgumentInfo();
        })
        .def("getDefaultArgumentLoc", [](const clang::TemplateTypeParmDecl& self) -> clang::SourceLocation {
           return  self.getDefaultArgumentLoc();
        })
        .def("defaultArgumentWasInherited", [](const clang::TemplateTypeParmDecl& self) -> bool {
           return  self.defaultArgumentWasInherited();
        })
        .def("setDefaultArgument", []( clang::TemplateTypeParmDecl& self, clang::TypeSourceInfo * DefArg)  {
             self.setDefaultArgument(DefArg);
        })
        .def("setInheritedDefaultArgument", []( clang::TemplateTypeParmDecl& self, const clang::ASTContext & C , clang::TemplateTypeParmDecl * Prev)  {
             self.setInheritedDefaultArgument(C, Prev);
        })
        .def("removeDefaultArgument", []( clang::TemplateTypeParmDecl& self)  {
             self.removeDefaultArgument();
        })
        .def("setDeclaredWithTypename", []( clang::TemplateTypeParmDecl& self, bool withTypename)  {
             self.setDeclaredWithTypename(withTypename);
        })
        .def("getDepth", [](const clang::TemplateTypeParmDecl& self) -> unsigned int {
           return  self.getDepth();
        })
        .def("getIndex", [](const clang::TemplateTypeParmDecl& self) -> unsigned int {
           return  self.getIndex();
        })
        .def("isParameterPack", [](const clang::TemplateTypeParmDecl& self) -> bool {
           return  self.isParameterPack();
        })
        .def("getSourceRange", [](const clang::TemplateTypeParmDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
    ;

    py::class_<clang::NonTypeTemplateParmDecl, decl_deleter<clang::NonTypeTemplateParmDecl>::type>(m, "NonTypeTemplateParmDecl" , py::base<clang::DeclaratorDecl>())
        .def("getSourceRange", [](const clang::NonTypeTemplateParmDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        //.def("getDefaultArgStorage", [](const clang::NonTypeTemplateParmDecl& self) -> const clang::DefaultArgStorage<clang::NonTypeTemplateParmDecl, clang::Expr *> & {
        //   return  self.getDefaultArgStorage();
        //})
        .def("hasDefaultArgument", [](const clang::NonTypeTemplateParmDecl& self) -> bool {
           return  self.hasDefaultArgument();
        })
        .def("getDefaultArgument", [](const clang::NonTypeTemplateParmDecl& self) -> clang::Expr * {
           return  self.getDefaultArgument();
        })
        .def("getDefaultArgumentLoc", [](const clang::NonTypeTemplateParmDecl& self) -> clang::SourceLocation {
           return  self.getDefaultArgumentLoc();
        })
        .def("defaultArgumentWasInherited", [](const clang::NonTypeTemplateParmDecl& self) -> bool {
           return  self.defaultArgumentWasInherited();
        })
        .def("setDefaultArgument", []( clang::NonTypeTemplateParmDecl& self, clang::Expr * DefArg)  {
             self.setDefaultArgument(DefArg);
        })
        .def("setInheritedDefaultArgument", []( clang::NonTypeTemplateParmDecl& self, const clang::ASTContext & C , clang::NonTypeTemplateParmDecl * Parm)  {
             self.setInheritedDefaultArgument(C, Parm);
        })
        .def("removeDefaultArgument", []( clang::NonTypeTemplateParmDecl& self)  {
             self.removeDefaultArgument();
        })
        .def("isParameterPack", [](const clang::NonTypeTemplateParmDecl& self) -> bool {
           return  self.isParameterPack();
        })
        .def("isPackExpansion", [](const clang::NonTypeTemplateParmDecl& self) -> bool {
           return  self.isPackExpansion();
        })
        .def("isExpandedParameterPack", [](const clang::NonTypeTemplateParmDecl& self) -> bool {
           return  self.isExpandedParameterPack();
        })
        .def("getNumExpansionTypes", [](const clang::NonTypeTemplateParmDecl& self) -> unsigned int {
           return  self.getNumExpansionTypes();
        })
        .def("getExpansionType", [](const clang::NonTypeTemplateParmDecl& self, unsigned int I) -> clang::QualType {
           return  self.getExpansionType(I);
        })
        .def("getExpansionTypeSourceInfo", [](const clang::NonTypeTemplateParmDecl& self, unsigned int I) -> clang::TypeSourceInfo * {
           return  self.getExpansionTypeSourceInfo(I);
        })
    ;

    py::class_<clang::TemplateTemplateParmDecl, decl_deleter<clang::TemplateTemplateParmDecl>::type>(m, "TemplateTemplateParmDecl" , py::base<clang::TemplateDecl>())
        .def("isParameterPack", [](const clang::TemplateTemplateParmDecl& self) -> bool {
           return  self.isParameterPack();
        })
        .def("isPackExpansion", [](const clang::TemplateTemplateParmDecl& self) -> bool {
           return  self.isPackExpansion();
        })
        .def("isExpandedParameterPack", [](const clang::TemplateTemplateParmDecl& self) -> bool {
           return  self.isExpandedParameterPack();
        })
        .def("getNumExpansionTemplateParameters", [](const clang::TemplateTemplateParmDecl& self) -> unsigned int {
           return  self.getNumExpansionTemplateParameters();
        })
        //.def("getExpansionTemplateParameters", [](const clang::TemplateTemplateParmDecl& self, unsigned int I) -> clang::TemplateParameterList * {
        //   return  self.getExpansionTemplateParameters(I);
        //})
        //.def("getDefaultArgStorage", [](const clang::TemplateTemplateParmDecl& self) -> const clang::DefaultArgStorage<clang::TemplateTemplateParmDecl, clang::TemplateArgumentLoc *> & {
        //   return  self.getDefaultArgStorage();
        //})
        .def("hasDefaultArgument", [](const clang::TemplateTemplateParmDecl& self) -> bool {
           return  self.hasDefaultArgument();
        })
        //.def("getDefaultArgument", [](const clang::TemplateTemplateParmDecl& self) -> const clang::TemplateArgumentLoc & {
        //   return  self.getDefaultArgument();
        //})
        .def("getDefaultArgumentLoc", [](const clang::TemplateTemplateParmDecl& self) -> clang::SourceLocation {
           return  self.getDefaultArgumentLoc();
        })
        .def("defaultArgumentWasInherited", [](const clang::TemplateTemplateParmDecl& self) -> bool {
           return  self.defaultArgumentWasInherited();
        })
        //.def("setDefaultArgument", []( clang::TemplateTemplateParmDecl& self, const clang::ASTContext & C , const clang::TemplateArgumentLoc & DefArg)  {
        //     self.setDefaultArgument(C, DefArg);
        //})
        .def("setInheritedDefaultArgument", []( clang::TemplateTemplateParmDecl& self, const clang::ASTContext & C , clang::TemplateTemplateParmDecl * Prev)  {
             self.setInheritedDefaultArgument(C, Prev);
        })
        .def("removeDefaultArgument", []( clang::TemplateTemplateParmDecl& self)  {
             self.removeDefaultArgument();
        })
        .def("getSourceRange", [](const clang::TemplateTemplateParmDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
    ;

    py::class_<clang::BuiltinTemplateDecl, decl_deleter<clang::BuiltinTemplateDecl>::type>(m, "BuiltinTemplateDecl" , py::base<clang::TemplateDecl>())
        .def("getSourceRange", [](const clang::BuiltinTemplateDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("getBuiltinTemplateKind", [](const clang::BuiltinTemplateDecl& self) -> clang::BuiltinTemplateKind {
           return  self.getBuiltinTemplateKind();
        })
    ;

    py::class_<clang::ClassTemplateSpecializationDecl, decl_deleter<clang::ClassTemplateSpecializationDecl>::type>(m, "ClassTemplateSpecializationDecl" , py::base<clang::CXXRecordDecl>())
        //.def("getNameForDiagnostic", [](const clang::ClassTemplateSpecializationDecl& self, llvm::raw_ostream & OS , const clang::PrintingPolicy & Policy , bool Qualified)  {
        //     self.getNameForDiagnostic(OS, Policy, Qualified);
        //})
        .def("getMostRecentDecl", []( clang::ClassTemplateSpecializationDecl& self) -> clang::ClassTemplateSpecializationDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getSpecializedTemplate", [](const clang::ClassTemplateSpecializationDecl& self) -> clang::ClassTemplateDecl * {
           return  self.getSpecializedTemplate();
        })
        //.def("getTemplateArgs", [](const clang::ClassTemplateSpecializationDecl& self) -> const clang::TemplateArgumentList & {
        //   return  self.getTemplateArgs();
        //})
        .def("getSpecializationKind", [](const clang::ClassTemplateSpecializationDecl& self) -> clang::TemplateSpecializationKind {
           return  self.getSpecializationKind();
        })
        .def("isExplicitSpecialization", [](const clang::ClassTemplateSpecializationDecl& self) -> bool {
           return  self.isExplicitSpecialization();
        })
        .def("isExplicitInstantiationOrSpecialization", [](const clang::ClassTemplateSpecializationDecl& self) -> bool {
           return  self.isExplicitInstantiationOrSpecialization();
        })
        .def("setSpecializationKind", []( clang::ClassTemplateSpecializationDecl& self, clang::TemplateSpecializationKind TSK)  {
             self.setSpecializationKind(TSK);
        })
        .def("getPointOfInstantiation", [](const clang::ClassTemplateSpecializationDecl& self) -> clang::SourceLocation {
           return  self.getPointOfInstantiation();
        })
        .def("setPointOfInstantiation", []( clang::ClassTemplateSpecializationDecl& self, clang::SourceLocation Loc)  {
             self.setPointOfInstantiation(Loc);
        })
        //.def("getInstantiatedFrom", [](const clang::ClassTemplateSpecializationDecl& self) -> llvm::PointerUnion<clang::ClassTemplateDecl *, clang::ClassTemplatePartialSpecializationDecl *> {
        //   return  self.getInstantiatedFrom();
        //})
        //.def("getSpecializedTemplateOrPartial", [](const clang::ClassTemplateSpecializationDecl& self) -> llvm::PointerUnion<clang::ClassTemplateDecl *, clang::ClassTemplatePartialSpecializationDecl *> {
        //   return  self.getSpecializedTemplateOrPartial();
        //})
        //.def("getTemplateInstantiationArgs", [](const clang::ClassTemplateSpecializationDecl& self) -> const clang::TemplateArgumentList & {
        //   return  self.getTemplateInstantiationArgs();
        //})
        //.def("setInstantiationOf", []( clang::ClassTemplateSpecializationDecl& self, clang::ClassTemplatePartialSpecializationDecl * PartialSpec , const clang::TemplateArgumentList * TemplateArgs)  {
        //     self.setInstantiationOf(PartialSpec, TemplateArgs);
        //})
        .def("setInstantiationOf", []( clang::ClassTemplateSpecializationDecl& self, clang::ClassTemplateDecl * TemplDecl)  {
             self.setInstantiationOf(TemplDecl);
        })
        .def("setTypeAsWritten", []( clang::ClassTemplateSpecializationDecl& self, clang::TypeSourceInfo * T)  {
             self.setTypeAsWritten(T);
        })
        .def("getTypeAsWritten", [](const clang::ClassTemplateSpecializationDecl& self) -> clang::TypeSourceInfo * {
           return  self.getTypeAsWritten();
        })
        .def("getExternLoc", [](const clang::ClassTemplateSpecializationDecl& self) -> clang::SourceLocation {
           return  self.getExternLoc();
        })
        .def("setExternLoc", []( clang::ClassTemplateSpecializationDecl& self, clang::SourceLocation Loc)  {
             self.setExternLoc(Loc);
        })
        .def("setTemplateKeywordLoc", []( clang::ClassTemplateSpecializationDecl& self, clang::SourceLocation Loc)  {
             self.setTemplateKeywordLoc(Loc);
        })
        .def("getTemplateKeywordLoc", [](const clang::ClassTemplateSpecializationDecl& self) -> clang::SourceLocation {
           return  self.getTemplateKeywordLoc();
        })
        .def("getSourceRange", [](const clang::ClassTemplateSpecializationDecl& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        //.def("Profile", [](const clang::ClassTemplateSpecializationDecl& self, llvm::FoldingSetNodeID & ID)  {
        //     self.Profile(ID);
        //})
    ;

    py::class_<clang::ClassTemplatePartialSpecializationDecl, decl_deleter<clang::ClassTemplatePartialSpecializationDecl>::type>(m, "ClassTemplatePartialSpecializationDecl" , py::base<clang::ClassTemplateSpecializationDecl>())
        .def("getMostRecentDecl", []( clang::ClassTemplatePartialSpecializationDecl& self) -> clang::ClassTemplatePartialSpecializationDecl * {
           return  self.getMostRecentDecl();
        })
        //.def("getTemplateParameters", [](const clang::ClassTemplatePartialSpecializationDecl& self) -> clang::TemplateParameterList * {
        //   return  self.getTemplateParameters();
        //})
        //.def("getTemplateArgsAsWritten", [](const clang::ClassTemplatePartialSpecializationDecl& self) -> const clang::ASTTemplateArgumentListInfo * {
        //   return  self.getTemplateArgsAsWritten();
        //})
        .def("getInstantiatedFromMember", [](const clang::ClassTemplatePartialSpecializationDecl& self) -> clang::ClassTemplatePartialSpecializationDecl * {
           return  self.getInstantiatedFromMember();
        })
        .def("getInstantiatedFromMemberTemplate", [](const clang::ClassTemplatePartialSpecializationDecl& self) -> clang::ClassTemplatePartialSpecializationDecl * {
           return  self.getInstantiatedFromMemberTemplate();
        })
        .def("setInstantiatedFromMember", []( clang::ClassTemplatePartialSpecializationDecl& self, clang::ClassTemplatePartialSpecializationDecl * PartialSpec)  {
             self.setInstantiatedFromMember(PartialSpec);
        })
        .def("isMemberSpecialization", []( clang::ClassTemplatePartialSpecializationDecl& self) -> bool {
           return  self.isMemberSpecialization();
        })
        .def("setMemberSpecialization", []( clang::ClassTemplatePartialSpecializationDecl& self)  {
             self.setMemberSpecialization();
        })
        .def("getInjectedSpecializationType", [](const clang::ClassTemplatePartialSpecializationDecl& self) -> clang::QualType {
           return  self.getInjectedSpecializationType();
        })
    ;

    py::class_<clang::ClassTemplateDecl, decl_deleter<clang::ClassTemplateDecl>::type>(m, "ClassTemplateDecl" , py::base<clang::RedeclarableTemplateDecl>())
        .def("LoadLazySpecializations", [](const clang::ClassTemplateDecl& self)  {
             self.LoadLazySpecializations();
        })
        .def("getTemplatedDecl", [](const clang::ClassTemplateDecl& self) -> clang::CXXRecordDecl * {
           return  self.getTemplatedDecl();
        })
        .def("isThisDeclarationADefinition", [](const clang::ClassTemplateDecl& self) -> bool {
           return  self.isThisDeclarationADefinition();
        })
        .def("AddSpecialization", []( clang::ClassTemplateDecl& self, clang::ClassTemplateSpecializationDecl * D , void * InsertPos)  {
             self.AddSpecialization(D, InsertPos);
        })
        .def("getCanonicalDecl", []( clang::ClassTemplateDecl& self) -> clang::ClassTemplateDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::ClassTemplateDecl& self) -> const clang::ClassTemplateDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getPreviousDecl", []( clang::ClassTemplateDecl& self) -> clang::ClassTemplateDecl * {
           return  self.getPreviousDecl();
        })
        .def("getPreviousDecl", [](const clang::ClassTemplateDecl& self) -> const clang::ClassTemplateDecl * {
           return  self.getPreviousDecl();
        })
        .def("getMostRecentDecl", []( clang::ClassTemplateDecl& self) -> clang::ClassTemplateDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getMostRecentDecl", [](const clang::ClassTemplateDecl& self) -> const clang::ClassTemplateDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getInstantiatedFromMemberTemplate", [](const clang::ClassTemplateDecl& self) -> clang::ClassTemplateDecl * {
           return  self.getInstantiatedFromMemberTemplate();
        })
        .def("AddPartialSpecialization", []( clang::ClassTemplateDecl& self, clang::ClassTemplatePartialSpecializationDecl * D , void * InsertPos)  {
             self.AddPartialSpecialization(D, InsertPos);
        })
        //.def("getPartialSpecializations", []( clang::ClassTemplateDecl& self, llvm::SmallVectorImpl<clang::ClassTemplatePartialSpecializationDecl *> & PS)  {
        //     self.getPartialSpecializations(PS);
        //})
        .def("findPartialSpecialization", []( clang::ClassTemplateDecl& self, clang::QualType T) -> clang::ClassTemplatePartialSpecializationDecl * {
           return  self.findPartialSpecialization(T);
        })
        .def("findPartialSpecInstantiatedFromMember", []( clang::ClassTemplateDecl& self, clang::ClassTemplatePartialSpecializationDecl * D) -> clang::ClassTemplatePartialSpecializationDecl * {
           return  self.findPartialSpecInstantiatedFromMember(D);
        })
        .def("getInjectedClassNameSpecialization", []( clang::ClassTemplateDecl& self) -> clang::QualType {
           return  self.getInjectedClassNameSpecialization();
        })
        //.def("specializations", [](const clang::ClassTemplateDecl& self) -> llvm::iterator_range<clang::RedeclarableTemplateDecl::SpecIterator<clang::ClassTemplateSpecializationDecl, clang::RedeclarableTemplateDecl::SpecEntryTraits<clang::ClassTemplateSpecializationDecl>, clang::ClassTemplateSpecializationDecl> > {
        //   return  self.specializations();
        //})
    ;

    py::class_<clang::FriendTemplateDecl, decl_deleter<clang::FriendTemplateDecl>::type>(m, "FriendTemplateDecl" , py::base<clang::Decl>())
        .def("getFriendType", [](const clang::FriendTemplateDecl& self) -> clang::TypeSourceInfo * {
           return  self.getFriendType();
        })
        .def("getFriendDecl", [](const clang::FriendTemplateDecl& self) -> clang::NamedDecl * {
           return  self.getFriendDecl();
        })
        .def("getFriendLoc", [](const clang::FriendTemplateDecl& self) -> clang::SourceLocation {
           return  self.getFriendLoc();
        })
        //.def("getTemplateParameterList", [](const clang::FriendTemplateDecl& self, unsigned int i) -> clang::TemplateParameterList * {
        //   return  self.getTemplateParameterList(i);
        //})
        .def("getNumTemplateParameters", [](const clang::FriendTemplateDecl& self) -> unsigned int {
           return  self.getNumTemplateParameters();
        })
    ;

    py::class_<clang::TypeAliasTemplateDecl, decl_deleter<clang::TypeAliasTemplateDecl>::type>(m, "TypeAliasTemplateDecl" , py::base<clang::RedeclarableTemplateDecl>())
        .def("getTemplatedDecl", [](const clang::TypeAliasTemplateDecl& self) -> clang::TypeAliasDecl * {
           return  self.getTemplatedDecl();
        })
        .def("getCanonicalDecl", []( clang::TypeAliasTemplateDecl& self) -> clang::TypeAliasTemplateDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::TypeAliasTemplateDecl& self) -> const clang::TypeAliasTemplateDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getPreviousDecl", []( clang::TypeAliasTemplateDecl& self) -> clang::TypeAliasTemplateDecl * {
           return  self.getPreviousDecl();
        })
        .def("getPreviousDecl", [](const clang::TypeAliasTemplateDecl& self) -> const clang::TypeAliasTemplateDecl * {
           return  self.getPreviousDecl();
        })
        .def("getInstantiatedFromMemberTemplate", [](const clang::TypeAliasTemplateDecl& self) -> clang::TypeAliasTemplateDecl * {
           return  self.getInstantiatedFromMemberTemplate();
        })
    ;

    py::class_<clang::ClassScopeFunctionSpecializationDecl, decl_deleter<clang::ClassScopeFunctionSpecializationDecl>::type>(m, "ClassScopeFunctionSpecializationDecl" , py::base<clang::Decl>())
        .def("getSpecialization", [](const clang::ClassScopeFunctionSpecializationDecl& self) -> clang::CXXMethodDecl * {
           return  self.getSpecialization();
        })
        .def("hasExplicitTemplateArgs", [](const clang::ClassScopeFunctionSpecializationDecl& self) -> bool {
           return  self.hasExplicitTemplateArgs();
        })
        //.def("templateArgs", [](const clang::ClassScopeFunctionSpecializationDecl& self) -> const clang::TemplateArgumentListInfo & {
        //   return  self.templateArgs();
        //})
    ;

    py::class_<clang::VarTemplateSpecializationDecl, decl_deleter<clang::VarTemplateSpecializationDecl>::type>(m, "VarTemplateSpecializationDecl" , py::base<clang::VarDecl>())
        //.def("getNameForDiagnostic", [](const clang::VarTemplateSpecializationDecl& self, llvm::raw_ostream & OS , const clang::PrintingPolicy & Policy , bool Qualified)  {
        //     self.getNameForDiagnostic(OS, Policy, Qualified);
        //})
        .def("getMostRecentDecl", []( clang::VarTemplateSpecializationDecl& self) -> clang::VarTemplateSpecializationDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getSpecializedTemplate", [](const clang::VarTemplateSpecializationDecl& self) -> clang::VarTemplateDecl * {
           return  self.getSpecializedTemplate();
        })
        //.def("getTemplateArgs", [](const clang::VarTemplateSpecializationDecl& self) -> const clang::TemplateArgumentList & {
        //   return  self.getTemplateArgs();
        //})
        //.def("setTemplateArgsInfo", []( clang::VarTemplateSpecializationDecl& self, const clang::TemplateArgumentListInfo & ArgsInfo)  {
        //     self.setTemplateArgsInfo(ArgsInfo);
        //})
        //.def("getTemplateArgsInfo", [](const clang::VarTemplateSpecializationDecl& self) -> const clang::TemplateArgumentListInfo & {
        //   return  self.getTemplateArgsInfo();
        //})
        .def("getSpecializationKind", [](const clang::VarTemplateSpecializationDecl& self) -> clang::TemplateSpecializationKind {
           return  self.getSpecializationKind();
        })
        .def("isExplicitSpecialization", [](const clang::VarTemplateSpecializationDecl& self) -> bool {
           return  self.isExplicitSpecialization();
        })
        .def("isExplicitInstantiationOrSpecialization", [](const clang::VarTemplateSpecializationDecl& self) -> bool {
           return  self.isExplicitInstantiationOrSpecialization();
        })
        .def("setSpecializationKind", []( clang::VarTemplateSpecializationDecl& self, clang::TemplateSpecializationKind TSK)  {
             self.setSpecializationKind(TSK);
        })
        .def("getPointOfInstantiation", [](const clang::VarTemplateSpecializationDecl& self) -> clang::SourceLocation {
           return  self.getPointOfInstantiation();
        })
        .def("setPointOfInstantiation", []( clang::VarTemplateSpecializationDecl& self, clang::SourceLocation Loc)  {
             self.setPointOfInstantiation(Loc);
        })
        //.def("getInstantiatedFrom", [](const clang::VarTemplateSpecializationDecl& self) -> llvm::PointerUnion<clang::VarTemplateDecl *, clang::VarTemplatePartialSpecializationDecl *> {
        //   return  self.getInstantiatedFrom();
        //})
        //.def("getSpecializedTemplateOrPartial", [](const clang::VarTemplateSpecializationDecl& self) -> llvm::PointerUnion<clang::VarTemplateDecl *, clang::VarTemplatePartialSpecializationDecl *> {
        //   return  self.getSpecializedTemplateOrPartial();
        //})
        //.def("getTemplateInstantiationArgs", [](const clang::VarTemplateSpecializationDecl& self) -> const clang::TemplateArgumentList & {
        //   return  self.getTemplateInstantiationArgs();
        //})
        //.def("setInstantiationOf", []( clang::VarTemplateSpecializationDecl& self, clang::VarTemplatePartialSpecializationDecl * PartialSpec , const clang::TemplateArgumentList * TemplateArgs)  {
        //     self.setInstantiationOf(PartialSpec, TemplateArgs);
        //})
        .def("setInstantiationOf", []( clang::VarTemplateSpecializationDecl& self, clang::VarTemplateDecl * TemplDecl)  {
             self.setInstantiationOf(TemplDecl);
        })
        .def("setTypeAsWritten", []( clang::VarTemplateSpecializationDecl& self, clang::TypeSourceInfo * T)  {
             self.setTypeAsWritten(T);
        })
        .def("getTypeAsWritten", [](const clang::VarTemplateSpecializationDecl& self) -> clang::TypeSourceInfo * {
           return  self.getTypeAsWritten();
        })
        .def("getExternLoc", [](const clang::VarTemplateSpecializationDecl& self) -> clang::SourceLocation {
           return  self.getExternLoc();
        })
        .def("setExternLoc", []( clang::VarTemplateSpecializationDecl& self, clang::SourceLocation Loc)  {
             self.setExternLoc(Loc);
        })
        .def("setTemplateKeywordLoc", []( clang::VarTemplateSpecializationDecl& self, clang::SourceLocation Loc)  {
             self.setTemplateKeywordLoc(Loc);
        })
        .def("getTemplateKeywordLoc", [](const clang::VarTemplateSpecializationDecl& self) -> clang::SourceLocation {
           return  self.getTemplateKeywordLoc();
        })
        //.def("Profile", [](const clang::VarTemplateSpecializationDecl& self, llvm::FoldingSetNodeID & ID)  {
        //     self.Profile(ID);
        //})
    ;

    py::class_<clang::VarTemplatePartialSpecializationDecl, decl_deleter<clang::VarTemplatePartialSpecializationDecl>::type>(m, "VarTemplatePartialSpecializationDecl" , py::base<clang::VarTemplateSpecializationDecl>())
        .def("getMostRecentDecl", []( clang::VarTemplatePartialSpecializationDecl& self) -> clang::VarTemplatePartialSpecializationDecl * {
           return  self.getMostRecentDecl();
        })
        //.def("getTemplateParameters", [](const clang::VarTemplatePartialSpecializationDecl& self) -> clang::TemplateParameterList * {
        //   return  self.getTemplateParameters();
        //})
        //.def("getTemplateArgsAsWritten", [](const clang::VarTemplatePartialSpecializationDecl& self) -> const clang::ASTTemplateArgumentListInfo * {
        //   return  self.getTemplateArgsAsWritten();
        //})
        .def("getInstantiatedFromMember", [](const clang::VarTemplatePartialSpecializationDecl& self) -> clang::VarTemplatePartialSpecializationDecl * {
           return  self.getInstantiatedFromMember();
        })
        .def("setInstantiatedFromMember", []( clang::VarTemplatePartialSpecializationDecl& self, clang::VarTemplatePartialSpecializationDecl * PartialSpec)  {
             self.setInstantiatedFromMember(PartialSpec);
        })
        .def("isMemberSpecialization", []( clang::VarTemplatePartialSpecializationDecl& self) -> bool {
           return  self.isMemberSpecialization();
        })
        .def("setMemberSpecialization", []( clang::VarTemplatePartialSpecializationDecl& self)  {
             self.setMemberSpecialization();
        })
    ;

    py::class_<clang::VarTemplateDecl, decl_deleter<clang::VarTemplateDecl>::type>(m, "VarTemplateDecl" , py::base<clang::RedeclarableTemplateDecl>())
        .def("LoadLazySpecializations", [](const clang::VarTemplateDecl& self)  {
             self.LoadLazySpecializations();
        })
        .def("getTemplatedDecl", [](const clang::VarTemplateDecl& self) -> clang::VarDecl * {
           return  self.getTemplatedDecl();
        })
        .def("isThisDeclarationADefinition", [](const clang::VarTemplateDecl& self) -> bool {
           return  self.isThisDeclarationADefinition();
        })
        .def("getDefinition", []( clang::VarTemplateDecl& self) -> clang::VarTemplateDecl * {
           return  self.getDefinition();
        })
        .def("AddSpecialization", []( clang::VarTemplateDecl& self, clang::VarTemplateSpecializationDecl * D , void * InsertPos)  {
             self.AddSpecialization(D, InsertPos);
        })
        .def("getCanonicalDecl", []( clang::VarTemplateDecl& self) -> clang::VarTemplateDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getCanonicalDecl", [](const clang::VarTemplateDecl& self) -> const clang::VarTemplateDecl * {
           return  self.getCanonicalDecl();
        })
        .def("getPreviousDecl", []( clang::VarTemplateDecl& self) -> clang::VarTemplateDecl * {
           return  self.getPreviousDecl();
        })
        .def("getPreviousDecl", [](const clang::VarTemplateDecl& self) -> const clang::VarTemplateDecl * {
           return  self.getPreviousDecl();
        })
        .def("getMostRecentDecl", []( clang::VarTemplateDecl& self) -> clang::VarTemplateDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getMostRecentDecl", [](const clang::VarTemplateDecl& self) -> const clang::VarTemplateDecl * {
           return  self.getMostRecentDecl();
        })
        .def("getInstantiatedFromMemberTemplate", [](const clang::VarTemplateDecl& self) -> clang::VarTemplateDecl * {
           return  self.getInstantiatedFromMemberTemplate();
        })
        .def("AddPartialSpecialization", []( clang::VarTemplateDecl& self, clang::VarTemplatePartialSpecializationDecl * D , void * InsertPos)  {
             self.AddPartialSpecialization(D, InsertPos);
        })
        //.def("getPartialSpecializations", []( clang::VarTemplateDecl& self, llvm::SmallVectorImpl<clang::VarTemplatePartialSpecializationDecl *> & PS)  {
        //     self.getPartialSpecializations(PS);
        //})
        .def("findPartialSpecInstantiatedFromMember", []( clang::VarTemplateDecl& self, clang::VarTemplatePartialSpecializationDecl * D) -> clang::VarTemplatePartialSpecializationDecl * {
           return  self.findPartialSpecInstantiatedFromMember(D);
        })
        //.def("specializations", [](const clang::VarTemplateDecl& self) -> llvm::iterator_range<clang::RedeclarableTemplateDecl::SpecIterator<clang::VarTemplateSpecializationDecl, clang::RedeclarableTemplateDecl::SpecEntryTraits<clang::VarTemplateSpecializationDecl>, clang::VarTemplateSpecializationDecl> > {
        //   return  self.specializations();
        //})
    ;

    py::class_<clang::CXXOperatorCallExpr, stmt_deleter<clang::CXXOperatorCallExpr>::type>(m, "CXXOperatorCallExpr" , py::base<clang::CallExpr>())
        .def("getOperator", [](const clang::CXXOperatorCallExpr& self) -> clang::OverloadedOperatorKind {
           return  self.getOperator();
        })
        .def("getOperatorLoc", [](const clang::CXXOperatorCallExpr& self) -> clang::SourceLocation {
           return  self.getOperatorLoc();
        })
        .def("getExprLoc", [](const clang::CXXOperatorCallExpr& self) -> clang::SourceLocation {
           return  self.getExprLoc();
        })
        .def("getLocStart", [](const clang::CXXOperatorCallExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXOperatorCallExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getSourceRange", [](const clang::CXXOperatorCallExpr& self) -> clang::SourceRange {
           return  self.getSourceRange();
        })
        .def("setFPContractable", []( clang::CXXOperatorCallExpr& self, bool FPC)  {
             self.setFPContractable(FPC);
        })
        .def("isFPContractable", [](const clang::CXXOperatorCallExpr& self) -> bool {
           return  self.isFPContractable();
        })
    ;

    py::class_<clang::CXXMemberCallExpr, stmt_deleter<clang::CXXMemberCallExpr>::type>(m, "CXXMemberCallExpr" , py::base<clang::CallExpr>())
        .def("getImplicitObjectArgument", [](const clang::CXXMemberCallExpr& self) -> clang::Expr * {
           return  self.getImplicitObjectArgument();
        })
        .def("getMethodDecl", [](const clang::CXXMemberCallExpr& self) -> clang::CXXMethodDecl * {
           return  self.getMethodDecl();
        })
        .def("getRecordDecl", [](const clang::CXXMemberCallExpr& self) -> clang::CXXRecordDecl * {
           return  self.getRecordDecl();
        })
        .def("getExprLoc", [](const clang::CXXMemberCallExpr& self) -> clang::SourceLocation {
           return  self.getExprLoc();
        })
    ;

    py::class_<clang::CUDAKernelCallExpr, stmt_deleter<clang::CUDAKernelCallExpr>::type>(m, "CUDAKernelCallExpr" , py::base<clang::CallExpr>())
        .def("getConfig", [](const clang::CUDAKernelCallExpr& self) -> const clang::CallExpr * {
           return  self.getConfig();
        })
        .def("getConfig", []( clang::CUDAKernelCallExpr& self) -> clang::CallExpr * {
           return  self.getConfig();
        })
        .def("setConfig", []( clang::CUDAKernelCallExpr& self, clang::CallExpr * E)  {
             self.setConfig(E);
        })
    ;

    py::class_<clang::CXXNamedCastExpr, stmt_deleter<clang::CXXNamedCastExpr>::type>(m, "CXXNamedCastExpr" , py::base<clang::ExplicitCastExpr>())
        .def("getCastName", [](const clang::CXXNamedCastExpr& self) -> const char * {
           return  self.getCastName();
        })
        .def("getOperatorLoc", [](const clang::CXXNamedCastExpr& self) -> clang::SourceLocation {
           return  self.getOperatorLoc();
        })
        .def("getRParenLoc", [](const clang::CXXNamedCastExpr& self) -> clang::SourceLocation {
           return  self.getRParenLoc();
        })
        .def("getLocStart", [](const clang::CXXNamedCastExpr& self) -> clang::SourceLocation {
           return  self.getLocStart();
        })
        .def("getLocEnd", [](const clang::CXXNamedCastExpr& self) -> clang::SourceLocation {
           return  self.getLocEnd();
        })
        .def("getAngleBrackets", [](const clang::CXXNamedCastExpr& self) -> clang::SourceRange {
           return  self.getAngleBrackets();
        })
    ;
}
